IMPLEMENTATION GUIDE VERSION 9.6

9.

123

Feature Symbology
The definition of feature symbology is strictly separated from its geometry. It results in the very flexible
system where features are symbolized just before their presentation. The symbology definition is feature
type based. It can be either static (the same for all instances of the feature type in any scale) or dynamic
(varies according to the current scale and/or feature attribute values). Every feature type can define one
default static and one default dynamic symbology. While the static symbology is the part of the feature
type definition, the dynamic symbology refers special LIDS metadata section (in thematization.xml).



9.1

It is not necessary to define symbology in its full form. It is possible to define any subset of symbology
properties (partial symbolizers) and the system itself fills the missing properties from some super
symbology definition in any part of metadata. The super symbology varies for various symbology
definitions.

Static Symbology
The LIDS symbology definition is based on OGC Symbology Encoding (SE) specification. It means the
LIDS symbology definition is very easily shareable among other systems and tools supporting the SE
standard. Each LIDS geometry type has its own type of symbology definition. There are four basic
symbology types in LIDS: point, curve, surface, text.

9.1.1

Curve symbology
Example: Curve symbology definition.
<ber:featureType id="ft_5012100" name="Main pipeline segment"
parentId="ft_5012000" abstract="false">
<ber:description>Main pipeline segment</ber:description>
<ber:masterGraphics nillable="true">
<ber:curveGraphicType>
<ber:symbology>
<ber:lineSymbolizer>
<se:Stroke>
<se:GraphicStroke>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ls_0"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
</se:GraphicStroke>
<se:SvgParameter name="stroke">#1C32FF</se:SvgParameter>
<se:SvgParameter name="stroke-opacity">1</se:SvgParameter>
<se:SvgParameter name="stroke-width">2</se:SvgParameter>

Implementation Guide

9 – FEATURE SYMBOLOGY

124

</se:Stroke>
</ber:lineSymbolizer>
</ber:symbology>
</ber:curveGraphicType>
</ber:masterGraphics>
...
</ber:featureType>

•
•
•
•

symbology – Encapsulates complete static symbology definition.
lineSymbolizer – SE based symbology definition for curve geometries. Only the above set of
subelements is supported in LIDS.
GraphicStroke – The only one of the SE linestroke types that is supported by LIDS. It references
the linestyle for stroke rendering defined as LIDS resource.
The Stroke definition contains the following set of SVG Parameters:
stroke – Specifies the solid color that will be used for a stroke. The color value is RGB-encoded
using two hexadecimal digits per primary-color component, in the order Red, Green, Blue,
prefixed with a hash (#) sign.
stroke-opacity – Specifies the level of translucency to use when rendering the stroke. The value is
encoded as a float between 0.0 and 1.0 with 0.0 representing completely transparent and 1.0
representing completely opaque.
stroke-width – Specifies the absolute width (thickness) of a stroke in pixels encoded as a float.
Maximum value 31.

Line width
Line width is defined in LIDS as unitless index values between 0 and 31. However, in some situations
it’s necessary to convert these width indexes to different units.



The line width used for displaying can be different than the one used for printing. It’s possible to map a
display width to the printing width (specified in device independent points DIP - 1/96 inch). The
mapping is common for whole project and is defined in lineWeights element in presentation.xml.
Example: Line weights for printing mapping.
<ber:plotting>
<!-- Default symbolizer for north arrow in map output -->
<ber:defaultNortharrow>
<ber:pointSymbolizer>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#fontname/66"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
<ber:rgbColor>#C80000</ber:rgbColor>
<ber:symbolHeight>36</ber:symbolHeight>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

125

</ber:pointSymbolizer>
</ber:defaultNortharrow>
<!-- Line weights mapping -->
<ber:lineWeights>
<ber:lineWeight display="0" print="0.025"/>
<ber:lineWeight display="1" print="0.125"/>
<ber:lineWeight display="2" print="0.25"/>
<ber:lineWeight display="3" print="0.35"/>
<ber:lineWeight display="4" print="0.5"/>
<ber:lineWeight display="5" print="0.75"/>
<ber:lineWeight display="6" print="1"/>
</ber:lineWeights>
</ber:plotting>



DWG file format defines line weights in mm. It’s possible to map line weight indexes used in LIDS to
the DWG line weights in mm. This mapping is considered when exporting / importing DWG and when
displaying DWG. The mapping is common for whole project and is defined in dwgLineWeights element
in presentation.xml.
Example: Line weights for DWG mapping.
<ber:dwgLineWeights>
<ber:dwgLineWeight display="0" dwg="0"/>
<ber:dwgLineWeight display="1" dwg="0.13"/>
<ber:dwgLineWeight display="2" dwg="0.30"/>
<ber:dwgLineWeight display="3" dwg="0.40"/>
<ber:dwgLineWeight display="4" dwg="0.53"/>
<ber:dwgLineWeight display="5" dwg="0.70"/>
<ber:dwgLineWeight display="6" dwg="0.80"/>
</ber:dwgLineWeights>

User line style
To display line features, it is possible to use user line styles. These are specified by a data model. Each
style must be stated in resource.xml together with list of available formats and name of files containing
the style definition. Style definition files are stored as project resource files on application server and
are cached by LIDS client when logging in to the project
The list of supported formats differs for different client applications:
• LIDS Edit with MicroStation or Bentley PowerMap: RSC format
• LIDS Edit with AutoCAD Map: LIN format
• LIDS Explorer: own definitions of user line styles in XML files

Implementation Guide

9 – FEATURE SYMBOLOGY

126



Definition in XML format must be prepared for purposes of map outputs for any type of client
application.
Description of XML format follows.
Line symbology can refer to predefined user line styles listed in resource.xml. It’s necessary to specify
basic information about line style in resource.xml. Detailed definition of each style listed in resource.xml
is prepared as a special xml-file (of our own format).
Example: Line style basic information in resource.xml.
...
<ber:lineStyle id="ls_MIGRACNI_BARIERA" name="ls_MIGRACNI_BARIERA">
<ber:formatArray>
<ber:format name="xml" file="ls_uap.xml"/>
</ber:formatArray>
</ber:lineStyle>
...
</ber:lineStyleArray>



Since version 7.1.6 there is one exception: solid style is supported as a system line style so it doesn't
need any xml-definition (style ls_0 in past).
User line style logically consists of one or more line components optionally shifted from a curve's axis
and of an optional start and end symbol. Line components are defined separately in definition file with
possibility to share them by more style definitions within one xml-file.
User line style consists of following parts:
•

•
•

At least one line component (its definition reference) for which these properties can be singly set:
• perpendicular distance of shifting from a curve's axis - component will be drawn in this distance
• gap at the beginning of curve - component parts drawing will start after this gap
• gap at the end of curve - component parts drawing ends before this gap
optionally symbol to be drawn at the beginning of curve
optionally symbol to be drawn at the end of curve

Start / end symbol properties:
•
•
•
•
•

definition of used symbol
used units (e.g. meters or pixels)
symbol size
symbol indent (distance in x and y direction from the beginning / end of curve towards the center of
used symbol)
symbol rotation - it can be of two types:
• relative – rotation by specified angle towards the given curve's segment
• absolute – rotation towards global coordinate system

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

127

Line component definition consists of:
•
•

•

•

•

Used units (e.g. meters or pixels)
Optionally line component parts, so called dash-stroke, that defines size and relay of single parts.
The parts can be of following types:
• solid line
• gap
• symbol
• text
Drawing mode
• continuous – the parts are drawn continuously along the whole curve; in inner vertexes a dashstroke is eventually “wrapped”
• by segments – the parts are drawn continuously along the single curve segments; in inner vertex
a dash-stroke begins from its first part
• center in segment – for a single curve segment a dash-stroke is drawn just once and centered;
segment length must be greater than a sum of lengths of dash-stroke parts
Optional parameter of minimal length – in combination with drawing mode it can influence whether
single parts of line components will be drawn
• continuous mode – a dash-stroke is drawn if a total length of curve is grater or equal to specified
minimal length
• by segments mode – a dash-stroke is drawn for the segment if segment length is grater or equal
to specified minimal length
• center in segment mode – a dash-stroke is drawn only if at once segment length is grater or
equal to a sum of lengths of dash-stroke parts and is grater or equal to specified minimal length
Way how to solve situation when there is not enough space for a dash-stroke part or when some of
size conditions (mentioned above) is not fulfilled. Possible ways:
• render solid line
• render nothing (default behavior)

Dash-stroke part definition – symbol:
•
•
•
•

definition of used symbol
symbol size - units are taken over from the parent line component
symbol indent (distance in x and y direction from the dash-stroke part center towards the center of
used symbol)
symbol rotation - it can be of two types:
• relative – rotation by specified angle towards the given curve's segment
• absolute – rotation towards global coordinate system

Dash-stroke part definition – text:
•
•
•
•
•

displayed text
used font
text height – it is taken over from the parent line component
text indent (distance in x and y direction from the dash-stroke part center towards the center of used
text)
text rotation - it can be of two types:

Implementation Guide

9 – FEATURE SYMBOLOGY

128
•
•

relative – rotation by specified angle towards the given curve's segment
absolute – rotation towards global coordinate system



Symbols and texts are not clipped within a dash-stroke part (i.e. they can exceed dash-stroke part size).



Line weight specified by a feature symbology is not applied to symbol / text parts of a dash-stroke.
Example: Line style with text component.

<ber:lineStyleArray>
...
<ber:lineStyle id="ls_PAM_REZERVACE_VPR">
<ber:components>
<ber:component refId="comp_pr_vpr">
<ber:perpendicularOffset>0.0</ber:perpendicularOffset>
</ber:component>
</ber:components>
</ber:lineStyle>
...
</ber:lineStyleArray>
...
<ber:componentArray>
...
<ber:component id="comp_pr_vpr"
uom="http://www.opengeospatial.org/se/units/pixel">
<ber:stroke-dasharray>14 -5 14 -5 20[text_1] -5 14 -5 14 -5</ber:strokedasharray>
<ber:segmentMode>continue</ber:segmentMode>
<ber:requiredLength>50</ber:requiredLength>
<ber:outOfStrokeGlue>solid</ber:outOfStrokeGlue>
<ber:strokeArray>
<ber:textStroke id="text_1">
<ber:textSymbolizer>
<se:Label>VPR</se:Label>
<se:Font>
<se:SvgParameter name="font-family">Arial</se:SvgParameter>
<se:SvgParameter name="font-size">7</se:SvgParameter>
</se:Font>
<se:LabelPlacement>
<se:PointPlacement>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

129

<se:Displacement>
<se:DisplacementX>0</se:DisplacementX>
<se:DisplacementY>0</se:DisplacementY>
</se:Displacement>
</se:PointPlacement>
</se:LabelPlacement>
<ber:rotation type="relative">0</ber:rotation>
</ber:textSymbolizer>
</ber:textStroke>
</ber:strokeArray>
</ber:component>
...
</ber:componentArray>

Example: Line style with symbol component

<ber:lineStyleArray>
...
<ber:lineStyle id="ls_VLEK">
<ber:components>
<ber:component refId="comp_vlek">
<ber:perpendicularOffset>0</ber:perpendicularOffset>
</ber:component>
</ber:components>
</ber:lineStyle>
...
</ber:lineStyleArray>
...
<ber:componentArray>
...
<ber:component id="comp_vlek"
uom="http://www.opengeospatial.org/se/units/pixel">
<ber:stroke-dasharray>10 6[symbol_1] 50</ber:stroke-dasharray>
<ber:segmentMode>continue</ber:segmentMode>
<ber:requiredLength>20</ber:requiredLength>
<ber:outOfStrokeGlue>solid</ber:outOfStrokeGlue>
<ber:strokeArray>
<ber:pointStroke id="symbol_1">
<ber:pointSymbolizer>

Implementation Guide

9 – FEATURE SYMBOLOGY

130

<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ber_LIDSuap2/104"/>
<se:Format/>
</se:ExternalGraphic>
<se:Size>6</se:Size>
<se:Displacement>
<se:DisplacementX>0</se:DisplacementX>
<se:DisplacementY>0</se:DisplacementY>
</se:Displacement>
</se:Graphic>
<ber:rotation type="relative">0</ber:rotation>
</ber:pointSymbolizer>
</ber:pointStroke>
</ber:strokeArray>
</ber:component>
...
</ber:componentArray>

Example: Complex line style

<ber:lineStyleArray>
...
<ber:lineStyle id="ls_ZELEZ_DRAHA">
<ber:components>
<ber:component refId="comp_zeldraha_top">
<ber:perpendicularOffset>2</ber:perpendicularOffset>
</ber:component>
<ber:component refId="comp_zeldraha">
<ber:perpendicularOffset>0</ber:perpendicularOffset>
</ber:component>
<ber:component refId="comp_zeldraha_bottom">
<ber:perpendicularOffset>-2</ber:perpendicularOffset>
</ber:component>
</ber:components>
<ber:startSymbol>
<ber:pointSymbolizer uom="http://www.opengeospatial.org/se/units/pixel">
<se:Graphic>
<se:ExternalGraphic>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

131

<se:OnlineResource xlink:href="resource.xml#ber_LIDSuap1/102"/>
<se:Format/>
</se:ExternalGraphic>
<se:Size>10</se:Size>
<se:Displacement>
<se:DisplacementX>0</se:DisplacementX>
<se:DisplacementY>0</se:DisplacementY>
</se:Displacement>
</se:Graphic>
<ber:rotation type="relative">0</ber:rotation>
</ber:pointSymbolizer>
</ber:startSymbol>
<ber:endSymbol>
<ber:pointSymbolizer uom="http://www.opengeospatial.org/se/units/pixel">
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ber_LIDSuap1/102"/>
<se:Format/>
</se:ExternalGraphic>
<se:Size>10</se:Size>
<se:Displacement>
<se:DisplacementX>0</se:DisplacementX>
<se:DisplacementY>0</se:DisplacementY>
</se:Displacement>
</se:Graphic>
<ber:rotation type="relative">0</ber:rotation>
</ber:pointSymbolizer>
</ber:endSymbol>
</ber:lineStyle>
...
</ber:lineStyleArray>
...
<ber:componentArray>
...
<ber:component id="comp_zeldraha"
uom="http://www.opengeospatial.org/se/units/pixel">
<ber:stroke-dasharray>-1 10[symbol_1] -14</ber:stroke-dasharray>
<ber:segmentMode>continue</ber:segmentMode>
<ber:outOfStrokeGlue>segment</ber:outOfStrokeGlue>
<ber:strokeArray>
<ber:pointStroke id="symbol_1">
<ber:pointSymbolizer>
<se:Graphic>
<se:ExternalGraphic>

Implementation Guide

9 – FEATURE SYMBOLOGY

132

<se:OnlineResource xlink:href="resource.xml#ber_LIDSuap1/98"/>
<se:Format/>
</se:ExternalGraphic>
<se:Size>20</se:Size>
<se:Displacement>
<se:DisplacementX>0</se:DisplacementX>
<se:DisplacementY>0</se:DisplacementY>
</se:Displacement>
</se:Graphic>
<ber:rotation type="relative">0</ber:rotation>
</ber:pointSymbolizer>
</ber:pointStroke>
</ber:strokeArray>
</ber:component>
<ber:component id="comp_zeldraha_top"
uom="http://www.opengeospatial.org/se/units/pixel">
<ber:stroke-dasharray>3000</ber:stroke-dasharray>
<ber:segmentMode>continue</ber:segmentMode>
<ber:outOfStrokeGlue>solid</ber:outOfStrokeGlue>
</ber:component>
<ber:component id="comp_zeldraha_bottom"
uom="http://www.opengeospatial.org/se/units/pixel">
<ber:stroke-dasharray>3000</ber:stroke-dasharray>
<ber:segmentMode>continue</ber:segmentMode>
<ber:outOfStrokeGlue>solid</ber:outOfStrokeGlue>
</ber:component>
...
</ber:componentArray>

9.1.2

Surface symbology
Example: Surface symbology definition.
<ber:featureType id="ft_5060000" name="Service organization unit"
parentId="ft_5000002" abstract="false">
<ber:description>Service organization unit</ber:description>
...
<ber:masterGraphics nillable="true">
<ber:surfaceGraphicType>
<ber:symbology>
<ber:polygonSymbolizer>
<ber:fill>
<se:SvgParameter name="fill">#808080</se:SvgParameter>
<se:SvgParameter name="fill-opacity">0.5</se:SvgParameter>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

133

<ber:fillStyle>solid</ber:fillStyle>
</ber:fill>
<se:Stroke>
<se:GraphicStroke>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ls_0"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
</se:GraphicStroke>
<se:SvgParameter name="stroke">#D5B862</se:SvgParameter>
<se:SvgParameter name="stroke-opacity">1</se:SvgParameter>
<se:SvgParameter name="stroke-width">2</se:SvgParameter>
</se:Stroke>
</ber:polygonSymbolizer>
</ber:symbology>
</ber:surfaceGraphicType>
</ber:masterGraphics>
...
</ber:featureType>

Example: Pattern fill.
<ber:polygonSymbolizer>
...
<ber:patternFill>
<se:GraphicFill>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#fs_symbol_1"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
</se:GraphicFill>
<se:SvgParameter name="fill">#FF8040</se:SvgParameter>
</ber:patternFill>

•
•

polygonSymbolizer – SE based symbology definition for surface geometries. Only the above set of
subelements is supported in LIDS.
fill – Specifies how the area of the surface will be filled. The meanings of its SvgParameters are
similar to the Stroke parameters discussed in conjunction with curve symbology above. Here, the
SvgParameter names are fill instead of stroke and fill-opacity instead of stroke-opacity.
The fillStyle parameter has two possible values, solid and none, which define filled/unfilled areas.

Implementation Guide

9 – FEATURE SYMBOLOGY

134
•



patternFill – Combination of pattern defined by a reference to an external style and fill defined by
SvgParameter.

Fill style set to none can be combined with fill color and opacity definition. It looks like senseless
definition but it can be useful in project default symbolizer definition (presentation.xml).
•

Stroke – Specifies how the surface border will be stroked. The set and meaning of its SvgParameters
is discussed in curve symbology definition above.

User line style
To display surface border, it is possible to use user line styles.
For more details see chapter 9.1.1.2

Hatching and pattern style
Hatching or pattern style can be also a part of surface symbology. It’s necessary to specify basic
information about hatching / pattern style in resource.xml.
Example: Fill style basic information in resource.xml.
<ber:fillStyleArray>
...
<ber:fillStyle id=" fs_symbol_1" name="patern with symbol_no. 101">
<ber:formatArray>
<ber:format name="xml" file="fillstyle.xml"/>
</ber:formatArray>
</ber:fillStyle>
...
</ber:fillStyleArray>

Detailed definition of each style listed in resource.xml is prepared (analogously to user line style
definition) as a special xml-file (of our own format). The same definition file is used by all LIDS clients.



Definition file uses project units hence a fill is zoom-dependent.
Single hatching / pattern style is defined as a one of following types:
• Hatch - simple line
• Hatch - double line
• Pattern - symbol
Hatch – simple line
A style consists of a simple line which is rotated and displayed repeatedly in defined spacing. A line can
be drawn including its weight (in pixels) and simple user line style based on one dash-stroke component
only.
Parameters:
• rotation

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6
•
•
•

135

spacing (distance to the next line)
line style
line weight

Hatch – double line (cross-hatch)
A style consists of two lines that are rotated and displayed repeatedly in defined spacing. A line can be
drawn including its weight (in pixels) and simple user line style based on one dash-stroke component
only. Both lines share a weight and a line style.
Parameters:
• 1. line - rotation
• 1. line - spacing (distance to the next line)
• 2. line - rotation
• 2. line - spacing (distance to the next line)
• line style
• line weight
Pattern
A style is based on iterative drawing of a tile which contains defined symbol in its center. A symbol is
aligned according to a tile center and it has its size and rotation. A size and rotation is defined for a tile
as well.
Optionally it is possible to specify an indent of even rows compared to odd rows.
Parameters:
• symbol definition (font, character, justification)
• symbol size
• symbol rotation
• tile rotation
• x-step for a tile
• y-step for a tile
• indent (for even rows only)





One definition file can contain more style definitions.

Too detailed style definition can influence drawing performance especially in LIDS Edit over
MicroStation environment.

Pattern styles are implemented as cells in LIDS Edit. A cell library is on fly generated for each definition
xml-file and it is stored in Data project directory. These libraries are newly generated only when time
stamp of definition file has been changed.

Implementation Guide

136

9 – FEATURE SYMBOLOGY

Example: Fill style – hatch pattern.

<ber:crosshatchPattern id="fs_crosshatch_30_150_5">
<ber:lines>
<ber:distance>5</ber:distance>
<ber:rotation>30</ber:rotation>
</ber:lines>
<ber:crosslines>
<ber:distance>5</ber:distance>
<ber:rotation>150</ber:rotation>
</ber:crosslines>
<ber:lineSymbolizer>
<se:Stroke>
<se:GraphicStroke>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="system.linestyle#solid"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
</se:GraphicStroke>
<se:SvgParameter name="stroke-width">1</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
</ber:crosshatchPattern>

Example: Fill style – symbol pattern.

<ber:symbolPattern id="fs_pattern_tuz_4000">
<ber:grid>
<ber:distanceX>28</ber:distanceX>
<ber:distanceY>28</ber:distanceY>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

137

<ber:rotation>0</ber:rotation>
<ber:evenOffset>14</ber:evenOffset>
</ber:grid>
<ber:pointSymbolizer uom="http://www.opengeospatial.org/se/units/pixel">
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ber_arimr/87/center-center"/>
<se:Format/>
</se:ExternalGraphic>
<se:Size>7</se:Size>
<se:Rotation>0</se:Rotation>
</se:Graphic>
</ber:pointSymbolizer>
</ber:symbolPattern>

Example: Fill style – text Pattern.

<ber:symbolPattern id="fs_pattern_dr_4000">
<ber:grid>
<ber:distanceX>28</ber:distanceX>
<ber:distanceY>28</ber:distanceY>
<ber:rotation>0</ber:rotation>
<ber:evenOffset>14</ber:evenOffset>
</ber:grid>
<ber:pointSymbolizer uom="http://www.opengeospatial.org/se/units/pixel">
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ber_arimr/110/centercenter"/>
<se:Format/>
</se:ExternalGraphic>
<se:Size>7</se:Size>
<se:Rotation>0</se:Rotation>
</se:Graphic>
</ber:pointSymbolizer>
</ber:symbolPattern>

Implementation Guide

9 – FEATURE SYMBOLOGY

138



It is not possible to use Text symbolizer to create a pattern. Text must be defined as Point Symbolizer.

9.1.3

Point symbology
Example: Point symbology definition.
<ber:featureType id="ft_5010100" name="Pumping station"
parentId="ft_5010000" abstract="false">
<ber:description>Pumping station</ber:description>
...
<ber:masterGraphics nillable="true">
<ber:pointGraphicType>
<ber:symbology>
<ber:pointSymbolizer>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource
xlink:href="resource.xml#ber_LIDSdemo/36/center-center/masked"/>
<se:Format/>
</se:ExternalGraphic>
<se:Opacity>1.0</se:Opacity>
</se:Graphic>
<ber:rgbColor>#1C32FF</ber:rgbColor>
<ber:symbolHeight>10</ber:symbolHeight>
</ber:pointSymbolizer>
</ber:symbology>
</ber:pointGraphicType>
</ber:masterGraphics>
...
</ber:featureType>

•

•
•
•
•
•

pointSymbolizer – SE based symbology definition for point geometries. It is used to draw a symbol
at a point. As LIDS symbol is in fact a character in a symbol font, the standard SE definition is
modified as described below.
Graphic - SE definition of the rendered symbol.
ExternalGraphic – SE based reference to the LIDS symbol. The format of the reference is
resource.xml#symbol_font_id/symbol_position/symbol_anchor_point/masked.
Opacity – Specifies the opacity to use for rending the symbol. It has the same semantics as the
stroke-opacity and fill-opacity SvgParameters discussed above.
rgbColor – LIDS extension of the standard SE point symbology. Defines the symbol color similarly
to stroke and fill SvgParameters discussed above.
symbolHeight - LIDS extension of the standard SE point symbology. Specifies the absolute size of
the symbol in the project base units.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

139

It’s necessary to specify basic information about symbol font in resource.xml.
Example: Symbol font basic information in resource.xml.
<ber:symbolFontArray>
<ber:symbolFont id="ttf_outline" name=" ttf outline">
<ber:formatArray>
<ber:format file="ttf outline.ttf" name="ttf"/>
</ber:formatArray>
</ber:symbolFont>
...
</ber:symbolFontArray>


9.1.4

Symbol fonts can be either installed in operating system or can be stored as a resource on AS and
downloaded only when necessary. For more details see chapter 28.5.

Text symbology
Example: Text symbology definition.
<ber:featureType id="ft_5084000" name="Sketch text"
parentId="ft_5080000" abstract="false">
<ber:description>Sketch text</ber:description>
<ber:masterGraphics nillable="false">
<ber:textGraphicType>
<ber:symbology>
<ber:textSymbolizer>
<se:Font>
<se:SvgParameter name="font-family">Arial</se:SvgParameter>
<se:SvgParameter name="font-style">normal</se:SvgParameter>
<se:SvgParameter name="font-weight">normal</se:SvgParameter>
</se:Font>
<se:Fill>
<se:SvgParameter name="fill">#00FF00</se:SvgParameter>
<se:SvgParameter name="fill-opacity">1</se:SvgParameter>
</se:Fill>
<ber:fontHeight>1.5</ber:fontHeight>
<ber:lineSpacing>0.25</ber:lineSpacing>
<ber:mask>
<ber:style>outline</ber:style>
</ber:mask>

Implementation Guide

140

9 – FEATURE SYMBOLOGY
</ber:textSymbolizer>
</ber:symbology>
</ber:textGraphicType>
</ber:masterGraphics>

</ber:featureType>

•
•

•
•
•
•

textSymbolizer – SE based symbology definition for styling text labels. Only the above set of
subelements is supported in LIDS.
Font - Identifies a font of a certain family, style, and size. The font-family SvgParameter gives the
family name of a font to use. The font can be either any font installed in clients and server (WMS)
operating systems or font registered in project resources. The font-style SvgParameter gives the
style to use for a font. The allowed values are normal and italic. The font-weight SvgParameter
gives the boldness to use for a font. Allowed values are normal and bold.
Fill – Defines color and opacity of the text. The SvgParameters are discussed above (see surface
symbology definition).
fontHeight – LIDS extension of the standard SE font definition. Defines the font height in the
project base units.
lineSpacing – LIDS extension of the standard SE font definition. Height of the space between any
two neighbor text lines in the project base units. Applies to multiline texts only.
mask – LIDS extension of the standard SE font definition. Defines the text masking. Parameters are
<ber:style> (with possible values fill, none, outline, outline-fill), <ber:shape> (circle, ellipse,
multiRectangle, rectangle) and <se:Stroke>.

Example: Text symbology with reference to external style.
<ber:textSymbolizer>
<se:Fill>
<se:SvgParameter name="fill">#00FFFF</se:SvgParameter>
</se:Fill>
<ber:fontHeight>0.5</ber:fontHeight>
<ber:lineSpacing>0.25</ber:lineSpacing>
<ber:mask>
<ber:style>outline-fill</ber:style>
<ber:shape>multiRectangle</ber:shape>
<se:Stroke>
<se:GraphicStroke>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="system.linestyle#solid"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
</se:GraphicStroke>
<se:SvgParameter name="stroke-width">1</se:SvgParameter>
</se:Stroke>
</ber:mask>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

141

</ber:textSymbolizer>

9.1.5

Collection symbology
In case of collection graphics, symbology for every component can be defined. Besides the component
symbologies, a common symbology can be defined. The common symbology has two properties
common to all symbologies – color and opacity. The common symbology is super symbology of the
component symbologies. It means that components can take color and opacity over from the common
symbology.
Example: Displayable attribute symbology definition.
<ber:graphicTypeArray>
<ber:graphicType id="gtda_5012102" name="W_DA_5012102">
<ber:class refId="DA"/>
<ber:collectionGraphicType>
<ber:symbology>
<ber:commonSymbolizer>
<ber:rgbColor>#1C32FF</ber:rgbColor>
<se:Opacity>1</se:Opacity>
</ber:commonSymbolizer>
</ber:symbology>
<ber:graphicTypeComponentArray>
<ber:graphicTypeComponent id="gtda_5012102_2" name="Label Line"
roleId="labelLine">
<ber:curveGraphicType>
<ber:symbology>
<ber:lineSymbolizer>
<se:Stroke>
<se:GraphicStroke>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ls_0"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
</se:GraphicStroke>
<se:SvgParameter name="stroke-width">1</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
</ber:symbology>
</ber:curveGraphicType>
</ber:graphicTypeComponent>
<ber:graphicTypeComponent id="gtda_5012102_1" name="DA Text"

Implementation Guide

142

9 – FEATURE SYMBOLOGY
roleId="text">
<ber:textGraphicType>
<ber:symbology>
<ber:textSymbolizer>
<ber:fontHeight>1</ber:fontHeight>
</ber:textSymbolizer>
</ber:symbology>
</ber:textGraphicType>
</ber:graphicTypeComponent>
</ber:graphicTypeComponentArray>
</ber:collectionGraphicType>
</ber:graphicType>
</ber:graphicTypeArray>

•
•

commonSymbolizer – Defines the symbology common for all the collection components.
lineSymbolizer, textSymbolizer – Defines symbologies for collection components. Color and
opacity are taken over from common symbology.

In case of collection graphics in graphic tags, derived symbolizer (derivedSymbolizer) can be used
instead of common symbolizer. It says that the collection color and opacity are taken over from their
feature symbology.



All symbolizers can be defined as hidden (optional Boolean attribute).

Example: Reference to a Collection class Extended dimension.
<ber:featureType id="ft_5031002" name="Extended dimension - simple"
parentId="ft_5030000" abstract="false">
<ber:description>Dimension created by dimensioning tool</ber:description>
<ber:container refId="ct_5030000"/>
<ber:masterGraphics nillable="false">
<ber:class refId="ExtDimension"/>
<ber:collectionGraphicType>
<ber:symbology>
<ber:commonSymbolizer>
<ber:rgbColor>#3F7FFF</ber:rgbColor>
</ber:commonSymbolizer>
</ber:symbology>
<ber:graphicTypeComponentArray>
<ber:graphicTypeComponent id="gt_20" name="Dimension Text">
<ber:textGraphicType>
<ber:symbology>
<ber:textSymbolizer>
<se:Font>
<se:SvgParameter name="font-style">italic</se:SvgParameter>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

143

</se:Font>
<se:Fill>
<se:SvgParameter name="fill">#3F7FFF</se:SvgParameter>
</se:Fill>
<ber:fontHeight>1.5</ber:fontHeight>
</ber:textSymbolizer>
</ber:symbology>
<ber:defaultTextProperties>
<ber:anchorPoint>center-bottom</ber:anchorPoint>
</ber:defaultTextProperties>
</ber:textGraphicType>
</ber:graphicTypeComponent>
<ber:graphicTypeComponent id="gt_30" name="Symbol-arrow">
<ber:pointGraphicType>
<ber:symbology>
<ber:pointSymbolizer>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource
xlink:href="resource.xml#ber_LIDSdemo/50/right-center"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
<ber:rgbColor>#3F7FFF</ber:rgbColor>
<ber:symbolHeight>3</ber:symbolHeight>
</ber:pointSymbolizer>
</ber:symbology>
</ber:pointGraphicType>
</ber:graphicTypeComponent>
<ber:graphicTypeComponent id="gt_10" name="Dimension Line">
<ber:curveGraphicType/>
</ber:graphicTypeComponent>
</ber:graphicTypeComponentArray>
</ber:collectionGraphicType>
</ber:masterGraphics>
...
</ber:featureType>

Implementation Guide

144

9.2

9 – FEATURE SYMBOLOGY

Dynamic Symbology
Dynamic symbology, or in other words thematic mapping, enables dynamic changes of static symbology
according to actual view scale or values of semantic feature attributes. The dynamic symbology is
defined in special metadata file thematization.xml.

9.2.1

Feature type styles
In dynamic symbology every feature type can have any number of feature type styles defined. Feature
type style defines how instances of one feature type are symbolized. The logical model of feature type
style looks like this:

Feature Type Style

Scale Range 1

Semantic Class 1

Attribute Condition 1
FT Symbology 1
DA Symbology 1

Semantic Class N

Attribute Condition N
FT Symbology N
DA Symbology N

Scale Range M

Else Semantic Class
FT Symbology X
DA Symbology X

On the first level, all the possible scales are divided into joined but not overlapping ranges. In every
scale range, features are classified according to their semantic attributes into a set of classes. Every class
is defined by its semantic condition and holds a symbology for the symbolized feature type and
symbologies (optionally) for its graphic tags. In every scale range, a completely different symbology
including completely different classification into semantic classes can be defined. But only one type of
semantic classification is allowed in one scale range.
Features are dynamically symbolized in these steps:
1. First of all, the scale range is chosen according to actual view scale.
2. Only the semantic classes belonging to the chosen scale range are taken into account. The
system tries to classify every feature instance to one of the semantic classes. If it succeeds, the
feature is symbolized with the specified symbology.
3. In case that the feature does not pass through any of the semantic classes conditions, it is
symbolized with so called else class symbology.



If else class symbology is not explicitly defined, the features belonging to the else class are symbolized
with their static symbology.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6
9.2.2

145

Semantic classification
Depending on the types of attribute conditions there are three types of semantic classification allowed.
General classification
General classification allows its classes to define any semantic attributes conditions. The conditions
must be written down in the form of logical addition (OR operation) of logical multiplications (AND
operation) of single attribute conditions. For example:
(material = 'copper' AND length > 3) OR (material = 'aluminum')
The conditions are written in the form of OGC filters in xml metadata.
Discrete classification
Discrete classification classifies features according to any number of its attributes that must have codelist
reference type. Only one equal (= operation) is allowed for every feature attribute in one semantic class.
The logical multiplication (AND operation) of single attribute conditions then defines the resulting class
condition. In other words it is possible to assign different symbology to any combination of discrete
values of codelist reference type attributes.
Interval classification
Interval classification classifies features according one of their attributes that must have decimal data
type. Any class then represents an interval of the attribute possible values.
Combined classification
Combined classification allows to classify features using all of classification methods mentioned above.
For each property can be selected different classification method; the final symbology of the feature
type is a combination of those individual methods.

9.2.3

Themes
Themes are collections of previously discussed feature type styles. Usually, themes group feature type
styles for feature types which are used at the same time. Themes are typically applied to layers
(templates, selection sets) so that it’s not necessary to apply individual feature type styles.


9.2.4

One theme can not incude two feature type styles for the same feature type.

Rules
Here, it is necessary to switch from previously defined logical model to physical structure of xml file.
To adhere to SE standard as much as possible, the above discussed logical model of feature type style
is physically written down in the set of SE rules. Generally, the rule contains both scale and attribute
condition and symbolizers of appropriate types. Still the logical model must be reconstructible from the
rules.

Implementation Guide

146

9 – FEATURE SYMBOLOGY

There are six types of rules:
• Static Rule (staticRule) – Does not contain neither scale nor attribute condition. Just changes feature
type static symbology with another static symbology in a feature type style. Cannot be combined
with any other rule within a feature type style.
• Scale Only Rule (scaleOnlyRule) – Does not contain any attribute condition. Changes symbology
according to view scale only. Cannot be combined with any other rule within a scale range.
• General Rule (rule)– Contains an attribute condition and optionally a scale condition. Used for
general semantic classification. Can be combined only with other general rules within a scale range.
• Discrete Rule (discreteRule)- Contains an attribute condition and optionally a scale condition. Used
for discrete semantic classification. Can be combined only with other discrete rules within a scale
range.
• Interval Rule (intervalRule)- Contains an attribute condition and optionally a scale condition. Used
for interval semantic classification. Can be combined only with other interval rules within a scale
range.
• Combined Rule (combinedRule) – Used for combined semantic classification. Cannot be combined
with any other rule within a scale range. Combined semantic classification is discussed in special
chapter 9.2.6.



The rules must be defined in such way that at most one rule for any feature and view scale is defined.
In the following example, dynamic symbology for feature type Main Pipeline Segment is defined. Three
scale ranges with following classifications are defined:
• Further than 1:2000
Main pipeline segments are not displayed in this scale range at all so scaleOnlyRule with
hiddenScale set to true is used and no symbology is defined.
• From 1:2000 to 1:1000
No semantic classification of main pipeline segments is required in this scale range so
scaleOnlyRule with required symbology is used.
• Closer than 1:1000
Main pipeline segment are symbolized according their lengths (at_5012002) in three classes:
shorter than 5 m, from 5 m to 10 m and longer than 10 m. So interval classification with three
intervalRule elements is defined.
Example: Dynamic symbology definition (thematization.xml).
<ber:featureTypeStyleArray>
<ber:featureTypeStyle>
<se:Name>fs_1</se:Name>
<se:Title>Main Pipeline Segment</se:Title>
<se:Abstract>Main Pipeline Segment</se:Abstract>
<se:FeatureTypeName>ft_5012100</se:FeatureTypeName>
<ber:intervalRule defaultScale="true">
<se:Title>Length[m]: 0-5</se:Title>
<ogc:Filter>
<ogc:PropertyIsLessThanOrEqualTo>
<ogc:PropertyName>at_5012002</ogc:PropertyName>
<ogc:Literal>5</ogc:Literal>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

147

</ogc:PropertyIsLessThanOrEqualTo>
</ogc:Filter>
<se:MaxScaleDenominator>1000</se:MaxScaleDenominator>
<ber:lineSymbolizer>
<se:Stroke>
<se:GraphicStroke>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ls_0"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
</se:GraphicStroke>
<se:SvgParameter name="stroke">#ff0000</se:SvgParameter>
<se:SvgParameter name="stroke-opacity">1.0</se:SvgParameter>
<se:SvgParameter name="stroke-width">1</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
</ber:intervalRule>
<ber:intervalRule defaultScale="true">
<se:Title>Length[m]: 5-10</se:Title>
<ogc:Filter>
<ogc:PropertyIsBetween>
<ogc:PropertyName>at_5012002</ogc:PropertyName>
<ogc:LowerBoundary>
<ogc:Literal>5</ogc:Literal>
</ogc:LowerBoundary>
<ogc:UpperBoundary>
<ogc:Literal>10</ogc:Literal>
</ogc:UpperBoundary>
</ogc:PropertyIsBetween>
</ogc:Filter>
<se:MaxScaleDenominator>1000</se:MaxScaleDenominator>
<ber:lineSymbolizer>
<se:Stroke>
<se:GraphicStroke>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ls_2"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
</se:GraphicStroke>

Implementation Guide

148

9 – FEATURE SYMBOLOGY
<se:SvgParameter name="stroke">#00FF00</se:SvgParameter>
<se:SvgParameter name="stroke-opacity">1.0</se:SvgParameter>
<se:SvgParameter name="stroke-width">2</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
</ber:intervalRule>
<ber:intervalRule defaultScale="true">
<se:Title>Length[m]: 10-&gt;</se:Title>
<ogc:Filter>
<ogc:PropertyIsGreaterThan>
<ogc:PropertyName>at_5012002</ogc:PropertyName>
<ogc:Literal>10</ogc:Literal>
</ogc:PropertyIsGreaterThan>
</ogc:Filter>
<se:MaxScaleDenominator>1000</se:MaxScaleDenominator>
<ber:lineSymbolizer>
<se:Stroke>
<se:GraphicStroke>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ls_3"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
</se:GraphicStroke>
<se:SvgParameter name="stroke">#0000ff</se:SvgParameter>
<se:SvgParameter name="stroke-opacity">1.0</se:SvgParameter>
<se:SvgParameter name="stroke-width">3</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
</ber:intervalRule>
<ber:scaleOnlyRule>
<se:MinScaleDenominator>1000</se:MinScaleDenominator>
<se:MaxScaleDenominator>2000</se:MaxScaleDenominator>
<ber:lineSymbolizer>
<se:Stroke>
<se:GraphicStroke>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ls_0"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

149

</se:GraphicStroke>
<se:SvgParameter name="stroke">#0000ff</se:SvgParameter>
<se:SvgParameter name="stroke-opacity">1.0</se:SvgParameter>
<se:SvgParameter name="stroke-width">4</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
</ber:scaleOnlyRule>
<ber:scaleOnlyRule hiddenScale="true">
<se:MinScaleDenominator>2000</se:MinScaleDenominator>
</ber:scaleOnlyRule>
</ber:featureTypeStyle>
...
</ber:featureTypeStyleArray>
<ber:themeArray>
<ber:theme>
<se:Name>th_3</se:Name>
<se:Title>Main Pipeline – interval+scale</se:Title>
<se:Abstract>Main Pipeline - interval+scale</se:Abstract>
<ber:ftStyleRefs>
<ber:ftStyle refId="fs_1"/>
<ber:ftStyle refId="fs_2"/>
<ber:ftStyle refId="fs_3"/>
</ber:ftStyleRefs>
</ber:theme>
...
</ber:themeArray>

9.2.5

Graphic tags dynamic symbology
Graphic tags can be dynamically symbolized together with their feature types.
Example: Displayable attributes dynamic symbology definition.
<ber:intervalRule id="rule_456_1" name="Length[m]: 0-5">
<ogc:Filter>
<ogc:PropertyIsBetween>
<ogc:PropertyName>at_5012002</ogc:PropertyName>
<ogc:LowerBoundary>
<ogc:Literal>0</ogc:Literal>
</ogc:LowerBoundary>
<ogc:UpperBoundary>
<ogc:Literal>5</ogc:Literal>

Implementation Guide

150

9 – FEATURE SYMBOLOGY
</ogc:UpperBoundary>
</ogc:PropertyIsBetween>
</ogc:Filter>
<ber:lineSymbolizer>
<se:Stroke>
<se:GraphicStroke>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ls_0"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
</se:GraphicStroke>
<se:SvgParameter name="stroke">#ff0000</se:SvgParameter>
<se:SvgParameter name="stroke-opacity">1.0</se:SvgParameter>
<se:SvgParameter name="stroke-width">1</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
<ber:textSymbolizer>
<se:Geometry>
<ogc:PropertyName>ft_5012100_gtda_5012101/gtda_5012101_1
</ogc:PropertyName>
</se:Geometry>
<se:Fill>
<se:SvgParameter name="fill">#FF0000</se:SvgParameter>
</se:Fill>
<ber:fontHeight>2</ber:fontHeight>
</ber:textSymbolizer>
</ber:intervalRule>

In this example, an interval rule for feature type Main Pipeline Segment is defined. Within this rule,
segments shorter than 5 m are symbolized together with their graphic tags (displayable attributes) –
install dates (ft_5012100_gtda_5012101). In contrast to feature type dynamic symbology definition, it
is necessary to identify the graphic tag type and the component type. For this reason, PropertyName
inside Geometry element is present in graphic tag dynamic symbolizer.

9.2.6

Combined semantic classification
Combined semantic classification enables independent resymbolization of particular symbology
properties (i.e. color, opacity, weight, ...) In other words, various semantic classifications (for various
symbology properties) can be combined into one feature type symbolizer. It is possible to modify each
symbology properties according to different semantic attributes and different classification types.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

151

For any symbology property, one of these definitions can be used:
• no change – property is omitted, original static symbology value is used
• new static symbology - new static value replaces original static symbology value
• direct symbology - the value is taken directly from the given feature attribute
• interval classification
• discrete classification
• general classification




If a discrete classification is used in a combined classification, just one attribute can be used. It is a
limitation comparing to the standard discrete classification.

So far it is not possible to use the combined classification for collections and graphic tags.
In the following example, a feature type style with the combined classification is defined:
• in a scale smaller than 1:1000, the feature type is not displayed at all
• in a scale larger than 1:1000, the combined classification is used
• line style is changed according to attribute at_5010007
• general classification is used
• features with the value beginning with 6 are drawn using line style ls_1, the others (elseClass)
use style ls_2
• line color is changed according to attribute at_ 5012003
• discrete classification is used
• color is defined for values 2, 3, 4, 5, 10; for all other values (elseClass), one color is defined
• line width is changed according to at_ 5012102
• interval classification is used
• three classes are defined
• < 6200 bar
• >= 6200 bar to < 6400 bar
• >= 6400 bar
• other symbolizer attributes are not changed – they are defined by a static feature type symbolizer
Example: Combined semantic classification definition.
<ber:featureTypeStyle id="fs_321"
name="Main Pipeline Segment - combined">
<ber:description>Main Pipeline Segment - hide + combined</ber:description>
<se:FeatureTypeName>ft_5012100</se:FeatureTypeName>
<ber:combinedRule id="rule_80000"
name="Material-&gt;color; Pressure-&gt;line-width"
defaultScale="true">
<se:MaxScaleDenominator>1000</se:MaxScaleDenominator>
<ber:lineSymbolizer>
<se:Stroke>

Implementation Guide

152

9 – FEATURE SYMBOLOGY
<se:GraphicStroke>
<se:Graphic>
<se:ExternalGraphic>
<ber:OnlineResource>
<ber:generalClassification>
<!-- line style changed by combined classification -->
<ber:generalClass>
<ogc:Filter>
<ogc:PropertyIsLike wildCard="%" singleChar="_"
escape="\">
<ogc:PropertyName>at_5010007</ogc:PropertyName>
<ogc:Literal>6%</ogc:Literal>
</ogc:PropertyIsLike>
</ogc:Filter>
<ber:value id="fsv_01">resource.xml#ls_1</ber:value>
</ber:generalClass>
<ber:elseClass>
<ber:value id="fsv_02">resource.xml#ls_2</ber:value>
</ber:elseClass>
</ber:generalClassification>
</ber:OnlineResource>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
</se:GraphicStroke>
<se:SvgParameter name="stroke">
<ber:recode fallbackValue="#888888">
<!-- color changed by discrete classification -->
<se:LookupValue>
<ogc:PropertyName>at_5012003/ca_10201</ogc:PropertyName>
</se:LookupValue>
<ber:mapItem>
<ber:data>2</ber:data>
<ber:value id="fsv_11">#FF0000</ber:value>
</ber:mapItem>
<ber:mapItem>
<ber:data>4</ber:data>
<ber:value id="fsv_12">#FF0000</ber:value>
</ber:mapItem>
<ber:mapItem>
<ber:data>5</ber:data>
<ber:value id="fsv_13">#FF0000</ber:value>
</ber:mapItem>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

153

<ber:mapItem>
<ber:data>3</ber:data>
<ber:value id="fsv_14">#00FF00</ber:value>
</ber:mapItem>
<ber:mapItem>
<ber:data>10</ber:data>
<ber:value id="fsv_15">#0000FF</ber:value>
</ber:mapItem>
<ber:elseClass>
<ber:value id="fsv_16">#888888</ber:value>
</ber:elseClass>
</ber:recode>
</se:SvgParameter>
<se:SvgParameter name="stroke-width">
<se:Categorize fallbackValue="1">
<se:LookupValue>
<ogc:PropertyName>at_5012102</ogc:PropertyName>
</se:LookupValue>
<ber:value id="rule_80020">1</ber:value>
<se:Threshold>6200</se:Threshold>
<ber:value id="rule_80021">2</ber:value>
<se:Threshold>6400</se:Threshold>
<ber:value id="rule_80022">3</ber:value>
</se:Categorize>
</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
</ber:combinedRule>
<ber:scaleOnlyRule id="rule_80100" hiddenScale="true">
<se:MinScaleDenominator>1000</se:MinScaleDenominator>
</ber:scaleOnlyRule>
</ber:featureTypeStyle>

•
•

•
•

The metadata notation is based on OGC standard Symbology Encoding (SE) 1.1.0.
elseClass - Defined for each partial general and discrete classification. It makes no sense to define
elseClass for an interval classification. The whole possible range of attribute values is always
covered by a definition.
tresholdsBelongTo - Defines whether the split points belong to a preceding or succeeding (default)
interval.
fallbackValue - In SE specification defined as “a value of a symbolizer attribute which should be
used when the system is not able to evaluate the defined classification”. LIDS does not use this
value. It is preserved because of the compatibility with SE xsd schemes. It cannot be used for our
elseClass rule definition as it cannot have ID.

Implementation Guide

154
9.2.7

9 – FEATURE SYMBOLOGY
Symbology tokens

Symbology tokens are values of already evaluated classifications for feature type styles. Symbology
tokens for individual features are stored in the database, in the feature table. The values of the symbology
tokens are evaluated automatically by LIDS Application server when creating / updating the features.



The tokens are needed by LIDS Application server when rendering the features using dynamic
symbology. Only such dynamic symbologies which are supported by generated symbology tokens can
be used Application server.
The tokens are generated for:
- styles referred as dynamicSymbology in feature type definition in model.xml
- themes which include attribute utilizedForWMS=”true” in thematization.xml
This means, every feature can have symbology tokens from more styles stored in the feature table.



Symbology tokens can be used to optimize dynamic symbology performance also in LIDS Edit /
Explorer clients. LIDS Edit / Explorer clients can evaluate dynamic symbology rules by themselves.
But in such cases it’s necessary for the client to download not only the geometry but also all semantic
attributes in order to be able to evaluate the dynami symbology classification. This is time consuming.
If the symbology tokens exist for particular dynamic symbology definition, client application can apply
the symbology using the symbology tokens directly and it’s not necessary to download also the
attributes. This improves the performance of downloading the graphics significantly.
Following modes of downloading graphics into LIDS Edit / Explorer can occur:
• static symbology – no need to evaluate classification, just the geometry is downloaded to the clients
• dynamic symbology based on symbology tokens – classification is already evaluated, symbology
tokens are downloaded together with the geometry, no semantics is downloaded to the clients
• dynamic symbology without symbology tokens – classification has to be evaluated by the client
application, semantics has to be downloaded to the clients additionally to the geometry

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

18.

229

Reports
LIDS system supports reporting functionality for feature types including master-detail report types.
Reporting service is based on Jasper Reports tool. It is a Java based open source reporting library with
flexible data sources and wide range of output formats. Output formats include PDF, HTML, XLS, CSV
or RTF. Data used to populate a report may be supplied either as input parameter from a user program,
or as a data source defined within report.

Report Design
JRXML

Document

SQL

PDF, HTML, XLS,
RTF, TXT

EJB

JasperReports

Document
XML
The report definitions are stored as a JasperReports templates.
The application server fills that templates with a concrete data when a request on a report is invoked.
However, some additional metadata is needed to make the report template fully functional. The reporting
service is configured by reportArray element in presentation.xml file. Reporting service reads
configuration from this file including jasper report template file location.

18.1 Reporting Services Architecture
The architecture behind reporting service is a classical 3-tier architecture:
• The user may select a particular report template within client application including output format of
the response.
• A report request is sent to the LIDS Application Server.
• Application server selects an appropriate JasperReports template and sends a query to the storage
engine.
• The data returned from storage is used by LIDS Application Server to populate the report.
• The report is outputted in specified format to the response.
• Client application receives the response and opens it the associated viewer.

Implementation Guide

230

18 – REPORTS
LIDS Explorer/
LIDS Edit
Get
report
rp_1

report.pdf

10

Database

LIDS AS

1
Report

WFS

2
Select Jasper
template 3

Templates

4
Get features
as XML

6a
5

7a
?
8

7b
6b
External GIS

9

18.2 Reports Kinds
Currently LIDS Application Server supports various kinds of reports classified by following properties:
• Static or dynamic
• Simple or masterDetail
• WFS based or SQL based
Report type
Dynamic
MasterDetail
WFS based
SQL based
staticReport
No
No
Yes
No
dynamicReport
Yes
No
Yes
No
masterDetailReport
No
Yes
Yes
No
dynamicMasterDetailReport
Yes
Yes
Yes
No
jasperReport
No
Yes
No
Yes
dynamicJasperReport
Yes
Yes
No
Yes

18.2.1

SQL based report data source
The data source for reporting is specified bywriting SQL statement directly.

18.2.2

WFS based report data source
The data source for reporting is a XML document generated by the Web Feature Service. This brings
advantages compared to the direct database querying approach:
• All security constrains are applied
• Independent of data layer (LIDS native SQL-database, external GIS)
• Virtual attributes are evaluated during request processing
• Designing the reports using metadata entities not the database tables/columns

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

231

However, this scenario brings a significant disadvantage when designing complex multi-join reports.
Every detail section of master-detail reports must be modeled as an association.

18.2.3

Static reports
A static report definition has a static defined report template including query that selects the data. It
means that the layout of the report will always look the same (the same data fields) and contain the same
type of data (particular feature types and their attribute columns). This type of reports may be useful for
features that change over the time. This is the simplest possible report to create.

18.2.4

Dynamic reports
The report template is dynamically modified by the request sent from client as well as query that selects
the data. User usually selects a list of features from client application and sends a report request for these
features. The report template is modified to include feature specific attributes, custom title etc.
This type of reports are very complex and difficult to create. Jasper report templates for these reports
should be designed to be able to visualize all kinds of feature types and unlimited number of attribute
columns. The LIDS Application Server contains universal set of dynamic reports with portrait and
landscape layout, therefore these report templates should be sufficient for most cases and projects.

18.2.5

Master–detail reports
Master–detail reports are special kind of static reports that contains detail section for every master
record. It represents master-detail view on data using feature associations.
Dynamic MasterDetail report is same as MasterDetail report, but features from master role are given by
ogc filter in report service request and feature types of master role of the relation assoc.

18.3 Reporting Service Metadata
Besides report template (JasperReports XML-file) the application server needs to know additional
informations for each report template. Generally, these metadata tells the reporting service the name of
the report, its description, name of the report template file, supported output formats and user defined
parameters. Each type of report has also several other properties.

18.3.1

Dynamic reports
Dynamic reports are identified by dynamicReport element followed by report identifier, its displayable
name and page orientation.
• description element contains simple description of this report.
• outputFormatArray contains outputFormat elements that defines possible formats of report files.
The output format element has one optional attribute named default which is set to false as default.
If the report request does not specify output format then default one is taken.

Implementation Guide

232
•

•
•

18 – REPORTS
inputParameterArray contains a list of inputParameter elements. Users may set these parameters
in report request. Parameters are then used inside jasper report templates. The common usage for
these parameters is report title, page footers, employee id etc. The id attribute serves as a unique
identifier inside each report and needs to be referenced from jasper report template with exactly the
same name. name attribute is a displayable name of this attribute used inside client environment.
nillable attribute defines, if is a parameter is mandatory or not. description and defaultValue
elements are self explaining. dataType defines data type of parameter. Currently supported data
types include decimal, string, date and codeListRefExt for codelist reference.
templateName contains jasper template file name which is located inside resources/report
directory.
attributeTemplateName contains XML Stylesheet file name located inside resources/report
directory. This file transforms jasper template file for each report request and fills feature type name
and attributes information.

Example: Dynamic report configuration (presentation.xml).
<ber:reportArray>
<ber:dynamicReport id="rp_1" name="Default Portrait" orientation="portrait"
default="true">
<ber:description>Default Portrait Report Template</ber:description>
<ber:outputFormatArray>
<ber:outputFormat default="true">pdf</ber:outputFormat>
<ber:outputFormat>html</ber:outputFormat>
<ber:outputFormat>csv</ber:outputFormat>
<ber:outputFormat>xls</ber:outputFormat>
</ber:outputFormatArray>
<ber:inputParameterArray>
<ber:inputParameter id="TITLE" name="Report Title">
<ber:description>The report title</ber:description>
<ber:defaultValue>Feature Report</ber:defaultValue>
</ber:inputParameter>
<ber:inputParameter id="MODEL_NAME" name="Model Name">
<ber:description>The name of the project (footnote)</ber:description>
<ber:defaultValue>LIDSdemo</ber:defaultValue>
</ber:inputParameter>
<ber:inputParameter id="DATE1" name="Some date">
<ber:description>Date for filtering the data</ber:description>
<ber:defaultValue>2010-10-01 23:59:59</ber:defaultValue>
<ber:dataType>
<ber:date/>
</ber:dataType>
</ber:inputParameter>
<ber:inputParameter id="DATE2" name="Some date">
<ber:description>Date for filtering the data</ber:description>
<ber:defaultValue>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

233

<ber:currentDate/>
</ber:defaultValue>
<ber:dataType>
<ber:date/>
</ber:dataType>
</ber:inputParameter>
<ber:inputParameter id="YEAR" name="Report Year" nillable="false">
<ber:description>Used as title text</ber:description>
<ber:defaultValue>2013</ber:defaultValue>
<ber:dataType>
<ber:decimal precision="4" scale="0"/>
</ber:dataType>
</ber:inputParameter>
<ber:inputParameter id="MATERIAL" name="Material type">
<ber:description>Used for material type</ber:description>
<ber:dataType>
<ber:codeListRefExt>
<ber:codeList xlink:href="model.xml#cl_204"/>
<ber:displayColumn xlink:href="model.xml#ca_20402"/>
</ber:codeListRefExt>
</ber:dataType>
</ber:inputParameter>
</ber:inputParameterArray>
<ber:templateName>default.template.jrxml</ber:templateName>
<ber:attributeTemplateName>default.template.xsl</ber:attributeTemplateName>
</ber:dynamicReport>

18.3.2

Relative path to resources
It’s possible to include resources in reports by specifying the path relative to application or resource
root.
Two new string parameters can be used now:
$P{APPLICATION_ROOT} - root of LIDS metadata

or
$P{RESOURCE_ROOT} - root of LIDS resources) in your path

Don't forget to declare parameter in your report:
<parameter name="RESOURCE_ROOT" isForPrompting="false" class="java.lang.String"/>

Implementation Guide

234

18 – REPORTS

Example of usage:
<imageExpression><![CDATA[$P{RESOURCE_ROOT}+"/report/file.jpg"]]></imageExpression>

Packaged project will use relative path as for all other resources.

18.4 Limitations
•
•
•
•

Master–detail reports may contain only one level deep detail section.
Since data are processed sequentially the charting functionality is limited. Charts use so-called
groups of ordered data.
In case of jasperReport and dynamicJasperReport the user access rights are not evaluated.
LIDS Browser supports jasperReport and dynamicJasperReport only.

18.5 Creating Simple Report
The simplest approach is to create a report template using JasperSoft Studio design tool – an open source
WYSIWYG report designer for JasperReports. It is used to design templates even with very complex
layout.
This chapter describes step-by-step process how to create simple static report using JasperSoft Studio
design tool, how to register such a report in LIDS Application Server environment and how to request
that report within LIDS Explorer.

18.5.1

Creating report template using JasperSoft Studio
The iReport is capable of querying multiple data sources including databases using JDBC driver.
Fortunately there is LIDS JDBC driver available that can process simple SQL-queries by translating
them into wfs:GetFeature requests.

JasperSoft Studio supports basic SQL queries with WHERE, ORDER BY, GROUP BY, HAVING, and
currently also single JOIN conditions.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

235

JasperSoft Studio installation and setup
Download JasperSoft Studio from the following page:
http://community.jaspersoft.com/project/jaspersoft-studio/releases
Install the application as usual and launch it.
First thing that needs to be done is to create data source for the report. Select CreateData Adapter.

Inside the Data Adapter Wizard choose Database JDBC Connection and set connection to an existing
database (lidsdemo) with your username and password:

Then we need to install LIDS JDBC driver to be able to connect to the application server and acquire
some data. Go to Driver Classpath, then click Add and set path to jar files. Finally you can test your
connection and click Finish.

Implementation Guide

236

18 – REPORTS

Creating report
After creating the connection you may create an actual report from scratch or use predefined templates:
1. From main menu select File → New → Jasper Report.
2. On next dialog select template (we recommend “Blank A4 Table based”), click Next. In the
following dialog, fill in the name of the template. Default storage path for templates is usually:
C:\Users\user_name\JaspersoftWorkspace\MyReports
3. In the following Data Source dialog select your Data Adapter created before.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

237

4. Now you need to specify the query that will select data from LIDS-system. You can write SQL
query in tab Texts yourself, or you can use tab Outline, where you have predefined query
structure and by right-click on the operator you can choose tables or expressions. The tab
Diagram shows the query as a diagram. If you are unsure of available columns (attributes) select
all of them by * character.
Example: SQL query for static report.
SELECT c_g_city_part, COUNT(*)
FROM PARCEL
GROUP BY c_g_city_part;

5. Proceed to the next step where you may select available columns. Select the columns you like
using arrow icons. You can change order of fields with up and down buttons on the left.

Implementation Guide

238

18 – REPORTS
6. Next step allows you to group fields.

7. Click Finish. Your basic report template is created and you may customize it to suit your needs.
The template will be saved as a JRXML-file.

Viewing report result
You may see the filled report with actual data inside JasperSoft Studio environment. There are three
modes – Design, Source and Preview. Design mode allows you to modify your report, add or remove
Fields, etc. In the Source mode you can see XML structure of the report and you can directly edit report
definition and finally Preview mode generates preview of the report filled with actual data. In Preview
mode , it’s possible to fill values for input parameters which are used in given report as well.

Extension and adjustment of the report layout
If you choose predefined template for your report, you will probably need to make some adjustments. If
you use blank template, you will have to design your report from scratch. In Design mode, you can
remove or add fields to your report, add some basic elements to layout and change formatting.
Ultimate button which enables you to change source data for the report is called “Edit, Query, Filter and
sort options” and can be found in the Properties panel → Report → Dataset (bottom – right) when
selecting main node from the Outline panel (bottom – left).

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

239

In the dialog that appears, you can perform these operations:
• specify a new SQL query
• edit existing SQL query
• update a list of fields for current query definition by means of Read Fields button
• update individual fields properties in tab Fields in the bottom part of the dialog by means of
Edit button, e.g. field description, field class type
• add or edit attributes for sorting in tab Sorting in the bottom part of the dialog
• view all and edit properties for custom parameters in tab Parameters in the bottom part of the
dialog
• run data preview based on current query definition
After clicking on OK button new or updated definition is used for selected report.

Implementation Guide

240

18 – REPORTS

Layout of the report in main window is divided to multiple parts. Generally report may be composed of
these bands (parts):
• Title – opening report title; it's created only once a report
• Page Header – header of pages; the page header appears on all printed pages in the same position
• Column Header – the column header band is printed at the beginning of each detail band
• Detail – represents data content of report; report may contain more "detail" sections if report
has subreports
• Group Header – a report can contain zero or more group bands, which permit the collection of
detail records in real groups. A group header is always accompanied by a group footer (both can
be independently visible or not) different properties are associated with a group.
• Group Footer – the group footer band completes a group; usually it contains fields to view
subtotals or separation graphic elements, such as lines.
• Column Footer – the column footer band appears on at the end of every detail band
• Page Footer – the page footer band appears on every page where there is a page header
• Summary – the summary band allows to insert fields concerning total calculations, means, or
whatever you want to insert at the end of the report.
• Last Page Footer – If you want to make the last page footer different from the other footers, it
is possible to use the special last page footer band.
• Summary – The summary band allows to insert fields concerning total calculations, means, or
whatever you want to insert at the end of the report.
• Background – The background band was introduced after insistent requests from many users
who wanted to be able to create watermarks and similar effects.
On the picture below you can see an illustration of the standardly used bands for 3 pages report.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

241

You can either remove some of bands or add another. By changing their width you define the space
between parts or single elements in the final report. For example you need to change the width of Detail
section to narrow (or remove) the space between table rows.
The best way to control the bands is via Outline panel. There is a list of bands and their components.
After selecting one of the bands or component you can set the size or position by means of Properties
panel (in Appearance tab) or with using of graphical elements in Design panel. You can also remove
band or field from report by right-click on the field in layout or in Outline panel and then use Delete
function.





If Outline panel is not available it's possible to activate it again from menu Window -> Show view ->
Other ... select General -> Outline.

It is recommended to use blank templates because problem with background images may occur when
exporting report from LIDS.

Implementation Guide

242

18 – REPORTS

You can add Basic and Composite Elements to layout from Palette panel (up-right) by drag and drop.
This contains for example Text Field, Static Text, Image, Break, Line, Chart, Map, Frame, Rectangle,
Subreport, Page numberand other. For every field object in the layout JasperSoft Studio creates a text
field element and sets the text field expression for that element to $F{NAME}. This text can be further
formatted in Properties → TextField → Appearance.



If you use blank template you have to add all fields to layout yourself. You can do that just by dragging
them from the list in Fields section in Outline panel to the main window to Detail section. Automatically
there will be also headers created in Column header section.
For each report element is possible to set many properties. The best way how to set or edit properties is
to use Properties panel. The enumeration of properties is very wide and is divided to several tabs in the
panel – as you can see on the picture below. Detail description of individual properties can be found in
JasperSoft Studio help.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

243

Inserting company logo
You can enrich your report with images, for example your company´s logo.
1. Choose Image from Basic Elements in Pallete and drag it to the section of your choice. The
following dialog appears:

2. Select Absolute Path and choose the path to your picture, which should be stored on your local
driver. Click OK.
3. You can now move and resize your picture, either with mouse or in the Properties panel.
Using styles and conditional styles
It can be useful to define styles for repeated use for more report elements. Creating new style is
possible from Outline panel, under the Styles list a fubction Create style is available. Then you can
define or adjust style characteristics via Properties panel.
If you want to define conditional style first create style and then from context menu over created
style choose Create conditional style. Then it’s necessary to define conditon via Expression Editor
dialog (e.g. $F{ATTRIBUTE1}=0 ) and finally you can define or adjust style characteristics via
Properties panel.
Assigning the style to some report element is done using Properties panel as well. After selecting
given report element use Appearance tab and then select required style by means of Style combobox.

Implementation Guide

18 – REPORTS

244

Using more datasets in report – using of Table element
If you want to create report with more queries (with more various datasets) you can utilize Table
element for it. The procedure how to add and configure “table” dataset and layout is below.
1.

Choose Table from Basic Elements in Pallete and drag it to the section of your choice (typically
to some Detail band).

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

245

2. The following dialog appears. You will probably have to choose creating table using a new
dataset. Click on Next button.

3. Enter name for new dataset (you can use the name predefined by system). Click on Next button.

4. Select the Data Adapter and then definition of the query is same as when creating a report (see
chapter 18.5.1.2 step 4). Click on Next button always.

Implementation Guide

246

18 – REPORTS

5. Last dialog allows you to set/modify simple formatting for the table. At the bottom of the dialog
checkboxes for activating/deactivating table sections are available. Set them according to your
needs (typically based on dataset definition, e.g. Group Header and Group Footer has sense only
if dataset uses grouping). Next sections in the dialog allow to set color schema or color definition
for individual table sections, style for cell borders etc. Finish whole procedure by clicking on
Finish button. The table will be added to the selected band.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

247

6. You can get the similar result as on picture below. The table element is placed to selected band
with choosen colour schema and with predefined size and position. In Outline panel new
“dataset” and “table” elements are added automatically as well.

7. Tuning of all table and table cells properties is possible by double click on given table. Design tab
for table appears and individual properties can be modified both in graphic window or by means of
Properties panel for selected row, column or cell.

Implementation Guide

248

18 – REPORTS

8. Example report with 4 tables (datasets), each placed in separate detail band you can see on picture
below.

Creating report with subreports
If you want to create report with subreport – it means with part which displayes data from subquery related to records from
main report query – you can use 2 basic techniques.

a/ Creating subreport with using Table element
Table element can be used for subreport as well. Place and adjust Table element in the similar way as described
in "Using more datasets in report – using of Table element" chapter. If you use Table element for subreport there
are two important things to do:
• Use proper parameter in table dataset query for interconnection between subrecords and record from main
query. Example of dataset query is:
SELECT fk_attribute, attribute1, attribute2, ...
FROM table
WHERE table.fk_attribute = $P{input_parameter_for_interconnection} ….
where $P{input_parameter_for_interconnection} is parameter defined under given Dataset
• Then it is necessary to define “mapping” of parameters. For this operation you can use these steps:
o Find element Table in given Detail band and click on it to display Properties panel
o In Properties panel switch to Dataset tab and use Parameters button
o Click on Add or Edit button, select appropriate parameter and fill in proper Parameter
Expression, typically in this syntax $F{attribute_from_main_query}, e.g. $F{SID} – see on
picture below.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

249

b/ Creating subreport using Subreport element
Select Subreport element from Pallete and use these steps from dialog for creating subreport:
• Create a new report
• Select report template
• Select or fill in report file name
• Select data adapter
• Define query – in query you should define clause which ensure interconnection between subreport and
main report; typically by means of parameter used in WHERE condition, e.g.
WHERE fk_attribute = $P{Norma}, where fk_attribute can be foreign key from subqeury table pointing
on primary key in main query table
• Select report fields and group by fields
• Specify connection
• Add dataset parameters – add parameter(s) used within query for interconnection between subreport and
main report
After clicking on Finish button subreport element is created and added to selected detail band.
Then it is necessary to define “mapping” of parameters. For this operation you can use these steps:
• Find element Subreport in given Detail band and click on it to display Properties panel
• In Properties panel switch to Subreport tab and use Edit Parameters button
• Click on Add or Edit button, select appropriate parameter and fill in proper Parameter Expression,
typically in this syntax $F{attribute_from_main_query}, e.g. $F{SID}.
Implementation Guide

250

18 – REPORTS
Dynamic reports

Several changes must be made to report template in order to create a dynamic report. For dynamic
reports, it is necessary to define and use SID_LIST report parameter. It is a collection of LIDS features
SID values. They will be provided dynamically by user when performing the report. The SID_LIST
definition and usage is illustrated at following pictures.
If this type of report is requesting on the server, in the request are definied WFS queries. In report filling
process, parameter SID_LIST will be filled with collection of SIDs of feature collection responded from
WFS.
SID_LIST parameter is defined as java.util.Collection class. If this class can not be found in combobox
list fill down the value manually.

SID_LIST parameter also needs to be used in Query. Here sid is column name in LIDS DB table
w_pumpstat. $X{IN, sid, SID_LIST} means ‘sid IN SID_LIST’ but must be written this way as this is
JasperReports collection syntax.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

251

Example: SQL query for dynamic report.
SELECT *
FROM W_PUMPSTAT
WHERE $X{IN, sid, SID_LIST};

18.5.2

Registering report inside LIDS Application Server
When you are satisfied with your report template design, you may place that report inside LIDS
Application Server to make the report available in LIDS Explorer. This section describes the steps
needed to accomplish this task.

JasperSoft Studio reports
Report type JasperReport allows to generate report from native jasper report template format which uses
sql query language. Data are queried directly from database.

Implementation Guide

252

18 – REPORTS

Example: Static report (Blank_A4_jasper.jrxml) from JasperSoft Studio.
http://jasperreports.sourceforge.net/xsd/jasperreport.xsd" name="Blank_A4_jasper"
pageWidth="595" pageHeight="842" columnWidth="555" leftMargin="20" rightMargin="20"
topMargin="20" bottomMargin="20" uuid="6360915a-5381-42a6-9553-dec75020a510">
<property name="com.jaspersoft.studio.data.sql.tables" value=""/>
<property name="com.jaspersoft.studio.data.defaultdataadapter"
value="LIDSDEMO"/>
<queryString language="SQL">
<![CDATA[SELECT "W_PUMPSTAT"."X_COORD",
"W_PUMPSTAT"."Y_COORD"
FROM "W_PUMPSTAT"]]>
</queryString>
<field name="X_COORD" class="java.math.BigDecimal"/>
<field name="Y_COORD" class="java.math.BigDecimal"/>
<background>
<band splitType="Stretch"/>
</background>
<title>
...
<textFieldExpression><![CDATA["NADPIS"]]></textFieldExpression>
...
<textFieldExpression><![CDATA[$F{X_COORD}]]></textFieldExpression>
...
<textFieldExpression><![CDATA[$F{Y_COORD}]]></textFieldExpression>
...
</jasperReport>

Example: Dynamic report (Blank_A4_jasper.jrxml) from JasperSoft Studio.
<?xml version="1.0" encoding="UTF-8"?>
<!-- Created with Jaspersoft Studio version 6.3.1.final using JasperReports Library
version 6.3.1 -->
<!-- 2017-03-13T16:50:32 -->
<jasperReport xmlns="http://jasperreports.sourceforge.net/jasperreports"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://jasperreports.sourceforge.net/jasperreports
http://jasperreports.sourceforge.net/xsd/jasperreport.xsd"
name="Blank_A4_jasper_dyn" pageWidth="595" pageHeight="842" columnWidth="555"
leftMargin="20" rightMargin="20" topMargin="20" bottomMargin="20" uuid="6360915a5381-42a6-9553-dec75020a510">
<property name="com.jaspersoft.studio.data.sql.tables" value=""/>
<property name="com.jaspersoft.studio.data.defaultdataadapter" value="One
Empty Record"/>
<parameter name="SID_LIST" class="java.util.Collection">
<defaultValueExpression><![CDATA[]]></defaultValueExpression>
</parameter>
<queryString language="SQL">

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

253

<![CDATA[SELECT *
FROM "W_PUMPSTAT"
WHERE $X{IN,sid,SID_LIST}]]>
</queryString>
<field name="X_COORD" class="java.math.BigDecimal"/>
<field name="Y_COORD" class="java.math.BigDecimal"/>
...
</jasperReport>

Application Server and Presentation.xml
After you are done with report customizations place the JasperReports template (.jrxml file) inside
Resources/Report directory of the LIDS Application Server.
The last thing that needs to be done is to register a newly created report inside project Presentation.xml
file. These reports are labelled as <ber:jasperReport> and <ber:dynamicJasperReport>.
Example: Registration of static report Blank_A4_jasper.jrxml inside presentation.xml.
<ber:jasperReport id="jrp_tibco" name="Test TIBCO Jasper"
orientation="portrait">
<ber:description>report in jasper format</ber:description>
<ber:outputFormatArray>
<ber:outputFormat default="true">pdf</ber:outputFormat>
<ber:outputFormat>html</ber:outputFormat>
<ber:outputFormat>csv</ber:outputFormat>
<ber:outputFormat>xls</ber:outputFormat>
</ber:outputFormatArray>
<ber:templateName>Blank_A4_jasper.jrxml</ber:templateName>
</ber:jasperReport>

Example: Registration of dynamic report Blank_A4_jasper_dyn.jrxml inside presentation.xml.
<ber:dynamicJasperReport id="dyn_pump" name="Pumping station"
orientation="portrait">
<ber:description>SID test of dynamic jasper</ber:description>
<ber:outputFormatArray>
<ber:outputFormat default="true">pdf</ber:outputFormat>
<ber:outputFormat>html</ber:outputFormat>
<ber:outputFormat>csv</ber:outputFormat>
<ber:outputFormat>xls</ber:outputFormat>
</ber:outputFormatArray>
<ber:templateName>Blank_A4_jasper_dyn.jrxml</ber:templateName>

Implementation Guide

254

18 – REPORTS
<ber:featureTypeArray>
<ber:featureType xlink:href="model.xml#ft_5010100"/>
</ber:featureTypeArray>
</ber:dynamicJasperReport>

Report from software iReport
A few modifications to the report template must be done if the report is created in older software e.g.
iReport 5.6.0. You have to replace database names with metadata identifications of these attributes.
Open the report template JRXML-file with you favorite text editor.
If you rename the JasperReports template file be sure that the name attribute inside jasperReport element
contains the same name.
Find field elements section and for each field do the following:
1. Change the name of the field to the metadata identification:
• If it is a feature system attribute, prefix it with */@.
Example: createDate → */@createDate
• If it an ordinary feature attribute that is not of a codelist type, change it to suit the
*/<at_identifier> format.
Example: LENGTH → */at_52013
• If it is a codelist feature attribute, change it to suit the
*/<at_identifier>/<codelist_display_column> format.
Example: C_G_CITY_PART → */at_5010004/ca_00402
2. If the class attribute contains anything else than java.lang.String, change it to the
java.lang.String value.
3. Search for textFieldExpression element that contains the old name of the field and change the
value to the new one.
4. If the class attribute of the textFieldExpression element contains anything else than
java.lang.String, change it to the java.lang.String value.
Application Server and Presentation.xml
After you are done with report customizations place the JasperReports template (.jrxml file) inside
Resources/Report directory of the LIDS Application Server.
The last thing that needs to be done is to register a newly created report inside project Presentation.xml
file.
These
reports
are
labelled
as
<ber:staticReport>,
<ber:dynamicReport>,
<ber:masterDetailReport> or <ber:dynamicMasterDetailReport>.
Example: Static report section may look like the following.
<ber:staticReport id="rp_my" name="Main Pipeline Segment Report"
orientation="portrait">
<ber:description>Main Pipeline Segment Report</ber:description>
<ber:outputFormatArray>
<ber:outputFormat default="true">pdf</ber:outputFormat>
<ber:outputFormat>html</ber:outputFormat>
<ber:outputFormat>csv</ber:outputFormat>
<ber:outputFormat>xls</ber:outputFormat>
</ber:outputFormatArray>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

255

<ber:templateName>my_report.jrxml</ber:templateName>
<ber:reportQueryArray>
<ber:reportQuery>
<ber:featureType xlink:href="model.xml#ft_5012100"/>
<ber:attributeArray>
<ber:attribute xlink:href="model.xml#at_5010004"/>
<ber:attribute xlink:href="model.xml#at_5012002"/>
<ber:attribute xlink:href="model.xml#at_5012102"/>
</ber:attributeArray>
<ogc:Filter>
<ogc:PropertyIsBetween>
<ogc:PropertyName>at_5012102</ogc:PropertyName>
<ogc:UpperBoundary>
<ogc:Literal>9003</ogc:Literal>
</ogc:UpperBoundary>
<ogc:LowerBoundary>
<ogc:Literal>9000</ogc:Literal>
</ogc:LowerBoundary>
</ogc:PropertyIsBetween>
</ogc:Filter>
</ber:reportQuery>
<ber:orderBy>
<ber:orderByItem direction="ascending">
<ber:commonAttribute attributeName="at_5012102">
<ber:featureType featureTypeName="ft_5012100"/>
</ber:commonAttribute>
</ber:orderByItem>
</ber:orderBy>
</ber:reportQueryArray>
</ber:staticReport>

18.5.3

Testing report
The report should be available in client application. However, if you want to test the report if it works
properly, you can use LIDS Ultra Light Client that can be found on
http://<LIDS_AS_URL>/utils/request.html address. Report Service section allows the user to query the
server for reports.

Implementation Guide

