Implementation Guide

Version 9.6

Implementation Guide

L-P02-en4800

© Asseco Central Europe, a.s., all rights reserved.
The document contains some confidential information and is intended entirely to the hands of the authorized staff of
institutions or companies it has been addressed to. No portion of the publication may be reproduced, maintained in the
retrieval system or transferred any way including an electronic, mechanical, photographic or other record made without
a prior agreement and written consent of the company of Asseco Central Europe, a.s.

IMPLEMENTATION GUIDE VERSION 9.6

Chapter 1
LIDS Metadata

IMPLEMENTATION GUIDE VERSION 9.6

1.

LIDS Metadata

1.1

Metadata Overview

3

LIDS is a system controlled by metadata. The LIDS metadata contains a detailed definition of data (socalled project) which a particular system instance works with. The metadata, hence, can be referred to
as “data describing the data”. The metadata is stored, transferred and managed in the system in the form
of XML documents.
The standard metadata is defined by six xml files:
• model.xml – This is the main metadata file that contains most important metadata. The file includes
definition of feature types its attributes, categories, codelists and other.
• presentation.xml – Contains feature presentation metadata. Defines project default symbology,
feature info, feature context, reports and symbol masking.
• thematization.xml – Defines the dynamic symbology of feature types. The definition is based on
OpenGIS Symbology Encoding (SE) standard.
• tool.xml – Contains definition of project specific toolbars used in LIDS Edit and LIDS Explorer
clients.
• resource.xml – Defines project based LIDS resources, i.e. line style definitions, symbol fonts and
icons.
• option.xml – Defines optional system functionality, i.e. copying features, deriving borders,
displayable attributes, external wms backdrops, topological tracing tasks and global plot definitions.
Besides standard metadata xml files, there is a set of extended metadata xml files. These metadata files
are saved in the folder extensions of LIDS Application Server filesystem. They define metadata for
optional LIDS extensions.
• browser.xml – LIDS Browser metadata. Defines the simplification of usually complex LIDS model
for presentation in a simple client – LIDS Browser.
• bulkup-date.xml – Definition of bulk update tasks. They enable bulk insert or update of LIDS data.
• cross-section.xml – Cross-sections metadata. Cross-sections are optional LIDS module used to
document the order of facilities in a route.
• telco.xml – Telco metadata. Telco is optional LIDS module used to document connectivity of fibres
in a cable.
• database-hints.xml – Enables LIDS Application Server optimization by tuning its communication
with Oracle database.
• ext-dimension.xml – LIDS Application Dimensions metadata. Application Dimensions are
optional LIDS module for advanced dimensioning. This functionality is an extension of standard
MicroStation or AutoCAD dimensioning.
• parallel-da.xml – Parallel Displayable Attributes metadata. It is an optional LIDS module that
enables interactive user-friendly placement of displayable attributes to the set of parallel lines.
• siasMetadata.xml – Defines integration of LIDS Application Server with Smallworld GIS or more
precisely with Smallworld Internet Application Server (SIAS).
• wfs-connector.xml – Defines integration of LIDS Aplication Server with external WFS server.
• ext-data-checks.xml – Extended Data Checks.

Implementation Guide

1 – LIDS METADATA

4
•
•
•
•
•
•
•
•
•
•
•
•
•


1.2

db-procedures.xml – Custom Database Procedures.
relation-constraints.xml – Relation constraints definition.
generate-detail.xml – LIDS generated details plugin.
spatial-deriving.xml – Spatial deriving definition.
multi-crs.xml – Coordinate systems definition.
cross-section-schema-com.xml – Cross-Section schema COM generation.
cross-section-schema-ele.xml – Cross-Section schema ELE generation.
pw-connector.xml – ProjectWise Connector parameters.
map-service.xml – Map services.
free-form.xml – LIDS Explorer free forms.
profile.xml – Longitudinal Profile.
custom-browse.xml – Data browsing customization.
mobile.xml – LIDS Mobile client configuration.

LIDS AS Administration Console is not able to effectively work with metadata files above ca. 15 MB.
It is not possible to upload & validate such metadata using console. The system can work with such
metadata, only the console is not able to process it.

Metadata Accessibility
All the metadata files are managed by LIDS application server. It can be accessed by the LIDS
Administration Console. The LIDS Administration Console offers function for viewing current
metadata, validate and upload any of the metadata files.
The metadata can be accessed in the System / Configuration / Files page of LIDS Administration
Console:

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

1.3

5

Metadata Schemas
All LIDS metadata files have fixed XML structure defined by the appropriate XML Schema file. The
XML Schema file is able to define the exact structure of the xml. The xml files can be validated
according their XML schema files. The schema files also contain the documentation of XML elements.
Usually it is not necessary to read the XML schema files directly as there is LIDS Metadata Reference
Manual (P03). It is a set of quite readable html pages that are generated (including XML elements
documentation) from the XML schemas.
These are the XML Schema definition files for the standard metadata files.
• model.xml -> modelBase.xsd
• presentation.xml -> modelPresentation.xsd
• thematization.xml -> modelThematization.xsd
• tool.xml -> modelTool.xsd
• resource.xml -> modelResource.xsd
• option.xml -> modelOption.xsd
Furthermore there is XML Schema file modelCommon.xsd with common xml definitions.

Implementation Guide

6

1 – LIDS METADATA

Implementation Guide

Chapter 2
Global Metadata Properties

IMPLEMENTATION GUIDE VERSION 9.6

2.

Global Metadata Properties

2.1

Global Project Properties

9

Global project properties are placed in the beginning of the model.xml file. They include various global
based definitions.
Example: Global project definitions.
<ber:model xmlns:xlink="http://www.w3.org/1999/xlink"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:se="http://www.opengis.net/se" xmlns:ogc="http://www.opengis.net/ogc"
xmlns:sld="http://www.opengis.net/sld" xmlns:ber="http://www.berit.com/ber">
<ber:project name="LIDSdemo" version="7.5.0">
<ber:description>LIDS Demo Project</ber:description>
<ber:spatialInfo baseUnit="m" srs="EPSG:31467">
<ber:range>
<ber:x min="3449000" max="3464400"/>
<ber:y min="5476300" max="5490500"/>
</ber:range>
<ber:tolerance>0.0005</ber:tolerance>
<ber:coordinatesScale>2</ber:coordinatesScale>
</ber:spatialInfo>
<ber:languages>
<ber:projectLanguage locale="en" name="English"/>
<ber:language locale="cs" name="Czech"/>
<ber:language locale="de" name="German"/>
<ber:language locale="de-CH" name="Schwiizerdütsch"/>
<ber:language locale="it" name="Italiano"/>
</ber:languages>
</ber:project>
...
</ber:model>

•
•
•

2.1.1

name – Defines project name.
version – Keeps the project version in any format.
description – Describes the project.

SpatialInfo and coordinate system
•

spatialInfo – Specifies project spatial information.
• srs – Identifies project spatial reference system.
• baseUnit – Specifies project base units. It is restricted to one of: 'm', 'cm' or 'mm'.
Implementation Guide

2 – GLOBAL METADATA PROPERTIES

10
•
•
•

tolerance – Specifies tolerance for some spatial functions, when two coordinates can be
considered as being identical.
coordinatesScale – Optional definition. Number of fraction digits for rounding the coordinates
range – Defines project spatial area in the specified reference system. This range should cover
all feature geometries from all database containers. The value should be set reasonably
according to project data. If set too large, many spatial operations don’t work correctly.

In case of local coordinate system usage, it’s not possible to use the standard SRS code. It's possible to
use a derived SRS like in the multi-crs.xml extension metadata instead. This means the project data is
stored in such derived system instead of a standard one.
Example: Local derived coordinate system definition.
<ber:spatialInfo baseUnit="m">
<ber:derivedCRS id="Translated_31467" name="GK3 - translated">
<ber:baseCRS refId="EPSG:31467"/>
<ber:transform>
<ber:translate offsetX="30" offsetY="0"/>
<ber:rotation anchorX="3456926" anchorY="5481071">0</ber:rotation>
<ber:scale>0.5</ber:scale>
</ber:transform>
</ber:derivedCRS>
...
</ber:spatialInfo>

2.2

System Properties
•

id – this by project specified number is used as a part of generated system identifiers (FID, SID,
GTID, GID, setting id, association id, attachment id). It’s used to assure unique identifiers across
the indiviual project instances on the same database. Possible values: numbers between 0 and 255

The metadata version from the system point of view is kept in the special part of metadata file. It
specifies the current metadata system version and the minimal versions of particular system components
that are able to handle the metadata. It is managed by the system itself. Do not edit it manually!
• model – system version of metadata.
• minClient – minimal version of LIDS Edit / Explorer.
• minAS – minimal version of LIDS Application server.
Example: Metadata system version info.
<ber:system id="0">
<ber:version>
<ber:model>101</ber:model>
<ber:minClient>3064</ber:minClient>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

11

<ber:minAS>12919</ber:minAS>
</ber:version>

2.3

Graphic Type Classes
Inside the system, there is also a definition of classes for graphic tags and for collections. There are
several possible classes for graphic tags:
• DA – Displayable attributes.
• PlacedCS – Placed cross-section.
• CSReference – Cross-section reference for plot outputs.
• BorderLine – By server generated border lines.
• BorderPolygon – By server generated border polygons.
• DetailReference – Detail reference for plot outputs.
• DetailReferenceMap – This graphic type is used for detail reference plot in map frame.
• GhostSymbol – Graphic tag type consisting of one or more point symbols at the same coordinates
as the main graphics.
• FreeGT – Manually created graphic tag.
• DirectionSymbol – Symbol representing line direction.
• BorderLineReduction – This graphic type is used for reduction consisting of lines.
• BorderPolygonReduction – This graphic type is used for reduction consisting of polygon.
Another classes are used for collections:
•
•
•
•
•
•
•
•

Dimension – Standard MicroStation dimensions, collection graphic type
ExtDimension – Dimensions for LIDS dimensioning tool, collection graphic type
DenseAreaReference – Dense area reference for plot outputs, graphic tag
DenseAreaZoom – Plotting of dense areas, collection graphic type
Cell – This graphic type is created by breaking MicroStation cells into individual components.
Chart – This graphic type is used for storing the generated charts.
FreeCollection – This graphic type is used for manually created collection as master graphics.
SlopeHatch – This graphic type is used for generating slope hatchures as master graphics.

Example: Definition of graphic type classes.
<ber:system id="0">
…
<ber:graphicTypeClassArray>
<!-- classes for graphic tags START -->
<ber:graphicTypeClass id="DA" name="Displayable attribute">
<ber:description>Displayable attributes, graphic tag</ber:description>
</ber:graphicTypeClass>
<ber:graphicTypeClass id="SimpleDimension" name="Simple dimension">
<ber:description>Dimensions for LIDS Browser, graphic tag</ber:description>
</ber:graphicTypeClass>

Implementation Guide

2 – GLOBAL METADATA PROPERTIES

12

…
<!-- classes for graphic tags END -->
<!-- classes for collections START -->
<ber:graphicTypeClass id="Dimension" name="Standard MicroStation dimension">
<ber:description>Standard MicroStation dimensions, collection graphic
type</ber:description>
</ber:graphicTypeClass>
<ber:graphicTypeClass id="ExtDimension" name="Extended dimension">
<ber:description>Dimensions for LIDS dimensioning tool, collection graphic
type</ber:description>
</ber:graphicTypeClass>
…
<!-- classes for collections END -->
</ber:graphicTypeClassArray>
</ber:system>

2.4

Metadata Items
In general, LIDS metadata is a set of collections of various metadata items. All metadata items have the
same identification information - id, name, description.
Example: Metadata item (feature attribute).
<ber:attribute id="at_5010004" name="Note" dbName="NOTE">
<ber:description>Notes for the record</ber:description>
...
</ber:attribute>

The identification attributes have these meanings and restrictions:
• id – Globally unique metadata item identification. It has to start with a letter or underscore '_' and
may contain only letters, digits, underscores '_', hyphens '-' or periods '.' . Its length is restricted to
40 characters (however model.xml is valid with any length of id).
• name – Basic human readable metadata identification. Its length is restricted to 60 characters.
• description – Optional additional information about metadata item. Displayed e.g. in tooltips.
Length is not restricted in model.xml.
• dbname – Used only for metadata items that are somehow represented in database. Following
restrictions have to be considered when defining dbname:
• May contain only letters, digits, underscores '_' and hyphens '-'
• Length is restricted to 30 characters in case of Oracle and 64 characters in case of PostgreSQL.
The allowed length includes also the generated postfixes in some cases, so the postfixes have to
be considered when defining metadata as well. E.g. the generated name for a versioned graphical
table will be expanded by _GR_H characters, causing maximum allowed value of dbname in
metadata to be 25 characters instead of 30
• Cannot start with LIDS, SAMO, SPATIAL, TMP, SEC, LCS, LOCK
• label – Used for example for fields in forms. Its length is restricted to 64 characters.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6


2.5

13

The most of metadata items have their names restricted to 60 characters. Some of them are items of
special type – long name metaitems. They enable names up to 120 characters long.

Language Variants
Metadata items’ names, descriptions and other properties displayed to the end user can exist in different
variants corresponding to different languages.
The list of available languages for project metadata is configured in the project section of model.xml:
<ber:languages>
<ber:projectLanguage locale="en" name="English"/>
<ber:language locale="cs" name="Czech"/>
<ber:language locale="de" name="German"/>
<ber:language locale="de-CH" name="Schwiizerdütsch"/>
<ber:language locale="it" name="Italiano"/>
</ber:languages>

- projectLanguage - mandatory. It defines the language used for standard metadata files
- language - zero or more additional language definitions
The resources used by the individual languages are stored in one or more files in CSV (comma-separated
values) format.
The files are published as LIDS resources and are registered at the beginning of resource.xml:
<ber:translationsArray>
<ber:translation id="tr_water" name="Water category translations">
<ber:formatArray>
<ber:format file="translations_water.csv" name="csv" separator="," quote=’"’
escapeChar="\"/>
</ber:formatArray>
</ber:translation>
<ber:translation id="tr_ele" name="Electro category translations">
<ber:formatArray>
<ber:format file="translations_ele.csv" name="csv" separator=";"/>
</ber:formatArray>
</ber:translation>
</ber:translationsArray>



Multiple translation files may be specified, their contents will be merged together. In case of a conflict
(identical item and property values) the last value defined wins (ordered by the position in
translationsArray and by the row order in each file).

Implementation Guide

14

2 – GLOBAL METADATA PROPERTIES
Example translations.csv:
item;property;cs;en;de;de-CH
ft_5012100;name;Hlavní řad;Main pipeline segment;Hauptpipelinesegment;Hauptpipelin…
at_5012115;name;Materiál;;Material;Material

The first row contains:
1. item text (case insensitive)
2. property text (case insensitive)
3. one or more locales in format language[_territory] (case insensitive)
https://en.wikipedia.org/wiki/Locale_(computer_software)
The following rows contain:
1. meta item identifier – e.g. feature type ID, attribute ID etc.
2. meta item text property, like name, description or label.
3. one or more translations matching the languages listed on the first row
• if particular language translation is empty, the model language is used
• the model language can be included here as well for the reference, but it’s ignored by the
application. In the first version of implementation the model language string cannot be
substituted by the value from the resource
Any additional column that has no title on the first row will be ignored.


2.5.1

The file must be encoded in UTF-8. This may be a problem when editing the file in Excel, so using
another tool is recommended (e.g., Notepad++, Google Spreadsheet).

Translatable metadata items
model.xml
project – name, description
graphicTypeClass – name, description
container, groupContainer – name, description
codelist – name, description
codelist column – name, description
filteredCodeList – name, description
codelistBinding – name, description
interface – name, description
interfaceAttribute – name, description
attachmentType – name, description
graphicType – name
graphicTypeComponent – name
featureType – name, description
featureAttribute – name, description

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

15

graphicTagType – name, description
form – name
form caption – label
formField – label
backdropType – name, description
vicinityMap – name, description
category – name, description
backdropCategory – name, description
role – name, description
relationAssoc, spatialRelationAssoc, featureRefrelationAssoc, detailAssoc – name, description
linearTopologyAssoc, nodeRole, nodeType, edgeRole, edgeType
arealTopologyAssoc, arealLayer
linearTopologyConnection, startRole, endRole
tool.xml
tool – name, description
toolox – name, description

Implementation Guide

Chapter 3
Feature Types

IMPLEMENTATION GUIDE VERSION 9.6

3.

Feature Types

3.1

Feature Types Introduction

3.1.1

Feature types and features

19

The absolutely essential items of LIDS metadata are Feature Types. A Feature Type can be
characterized as a type of objects of the real world (features). The feature type defines the set of objects'
semantic attributes, their geometry, symbology and other properties.
On the other hand a Feature is an instance of a feature type. That means a Feature is a representation of
a real world object. Feature holds individual data information - values and geometry of an object.
Feature type definition contains following parts:
• Name – Name of the feature type.
• Feature type identifier – Unique feature type identifier.
• Set of semantic attribute definitions – Set of semantic attributes – their ids, names and types.
• Geometry type – Type of feature geometry (point, line, text, polygon, collection)
• Symbology – Defines the symbology of all features with the same feature type.
• Database storage (database container) – Defines the database container. The physical storage
where the features are stored.

3.1.2

Hierarchy of feature types
Feature types are defined in a tree structure. A head of the structure must be a special feature type (Root
Feature Type), which has to be abstract and requires id="ft_5000002". Its structure is following:
Attributes
•
•
•

id – Unique feature type identifier. This identifier is used whenever the feature type is referenced.
The id XML attribute is always a unique identifier within all elements of LIDS model.
name – Name of a feature type.
abstract – Specifies whether the feature type is an abstract one – it means that the feature type cannot
have instances (features) or not – the feature type can have instances (features).

Inner Elements
•
•
•
•

description – Contains a detailed description of the feature type.
featureAttributeArray – Contains fundamental system attributes like sid or ftid.
formArray – If defined, this form is used as default for all ftypes without defined form instead of
using the "All attributes" form.
attachmentTypeArray – Reference to attached data.

Implementation Guide

20

3 – FEATURE TYPES
Example: Root feature type.
<ber:rootFeatureType id="ft_5000002" name="Root" abstract="true">
<ber:description>ROOT_NODE</ber:description>
<ber:featureAttributeArray>
<ber:systemAttribute id="id" name="Feature ID"/>
<ber:systemAttribute id="sid" name="Semantic ID"/>
<ber:systemAttribute id="ftid" name="Feature Type"/>
<ber:systemAttribute id="createdBy" name="Created_by"/>
<ber:systemAttribute id="updatedBy" name="Updated_by"/>
<ber:systemAttribute id="createDate" name="Create_date"/>
<ber:systemAttribute id="updateDate" name="Update_date"/>
<ber:systemAttribute id="longTransactionId" name="Long_trans_ID"/>
<ber:systemAttribute id="symbologyTokens" name="Symbology tokens"/>
<ber:systemAttribute id="validFrom" name="Valid From"/>
<ber:systemAttribute id="validTo" name="Valid To"/>
<ber:systemAttribute id="featureInfo" name="Feature Info"/>
</ber:featureAttributeArray>
<!-- if this definition is applied, this form is used as default for all ftypes
without defined form instead of using the "All attributes" form.
So it's better not to use it
<ber:formArray>
<ber:form id="fml_50000" name="System attributes">
<ber:fieldGroup>
<ber:field refId="id" label="Feature ID" readOnly="true" length="40"/>
<ber:field refId="sid" label="Semantic ID" readOnly="true" length="40"/>
<ber:field refId="ftid" label="Feature Type" readOnly="true" length="80"/>
<ber:field refId="createdBy" label="Created by" readOnly="true"
length="80"/>
<ber:field refId="updatedBy" label="Updated by" readOnly="true"
length="40"/>
<ber:field refId="createDate" label="Create date" readOnly="true"
length="80"/>
<ber:field refId="updateDate" label="Update date" readOnly="true"
length="40"/>
<ber:field refId="longTransactionId" label="Long transaction ID"
readOnly="true" length="40"/>
</ber:fieldGroup>
</ber:form>
<ber:assignedForms>
<ber:assignedForm usage="locate" refId="fml_50000"/>
</ber:assignedForms>
</ber:formArray-->
</ber:rootFeatureType>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

21

All other feature types are descendants (children) of root feature type. Thanks to the tree structure we
can define inheritance between feature types. The child feature types inherit some information from its
parent feature type.
The main information that child feature types inherit from their parents are:
• List of semantic attributes – cannot be redefined
• Properties of semantic attributes – they can be redefined in the child feature type
• Type of semantic attributes - they can be redefined in the child feature type
• Default values of semantic attributes – it can be redefined in the child feature type
• Definition of user forms – can be redefined
• Database storage (container) – it can be redefined in the child feature type

3.1.3

Semantic and graphic feature types
A feature type can have a set of semantic properties (semantic attributes). If a feature type contains any
semantic property it is called Semantic Feature Type.
The type of a geometry can be specified for a feature type. If a feature type contains geometry definition
then it is called Graphic Feature Type. The instances of a graphic feature type (features) may have a
geometry.

3.1.4

Abstract feature type
There can be abstract feature types in the project metadata. An abstract feature type does not have any
instances – can have no features. Abstract feature types are usually used for defining a common ancestor
that holds information to be inherited, e.g. set of properties, database container, default values ...
It is possible to have a derived attribute from geometry in abstract feature type, which has no geometry.
Abstract feature type can contain definition of geometry.

3.2

Defining Feature Types
All feature types are defined within a featureTypeArray XML collection in the project metadata file
model.xml.
Example: Definition of abstract feature type called Pipeline inside the meta model.
<ber:model>
<ber:featureTypeArray>
...
<ber:featureType
id="ft_5012000"
name="Pipeline" parentId="ft_5010000"
abstract="true">
<ber:description>Abstract parent of water pipelines</ber:description>
...
</ber:featureType>

Implementation Guide

3 – FEATURE TYPES

22

...
</ber:featureTypeArray>
</ber:model>

3.2.1

Feature type definition
The feature type definition contains a set of XML attributes and a list of inner XML elements. All these
information together defines a feature type. The description of these XML attributes and elements is
undermentioned.
• id – Unique feature type identifier. This identifier is used whenever the feature type is referenced.
The id XML attribute is always a unique identifier within all elements of LIDS model.
• name – Name of a feature type.
• parentId – Defines the parent feature type of the current feature type. The whole feature type
hierarchy is built according to this attribute.
• abstract – Specifies whether the feature type is an abstract one – it means that the feature type cannot
have instances (features) or not – the feature type can have instances (features).
• sharedSemantics – Indicates whether more graphical features of the given types share semantics of
their parent. Possible values are: false, true, single. The value single restricts a feature with shared
semantics to only one instance of the given graphical type.
Inner elements
•
•
•

•
•
•
•
•
•
•
•

3.3

description – Contains a detailed description of the feature type. It can be quite a large text, so it is
defined as a sub-element of a feature type.
container – Reference to a database container. This property is inherited to child feature types, but
can be redefined
forbiddenOperations –The possible forbidden operations for feature types are [query | update |
insert | delete]. The forbidden operations have higher priority than access rights and they are
evaluated before them. This property is not inherited to child feature types
masterGraphics – see chapter 8.1.
graphicTagTypeArray – see chapter Graphic Tags 8.2.
featureAttributeArray – see chapter 4.
redefinedFeatureAttributeArray – see chapter 4.8.
boundedAttributesArray – see chapter 5.7.
formArray – see chapter 7.
interfaceDefArray – see chapter 6.
attachmentTypeArray – see chapter 14.

Shared Semantics
A unique property of the LIDS system is support for work with more graphic presentations of one and
the same feature. That means in practice that one object can be displayed in a system several times,
every time in a different context and using a different graphic presentation. It means that two features
of different or similar feature types may share semantic record in the semantic table. Attribute data on
the object is saved in the system only once. It is possible for example to describe an exact position of a

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

23

cable and its passing through ducts in a map layer, display an electric connection in a schematic layer
or document inputs/outputs to/from the network in a detail of a transformer station.
The definition requires the existence of the semantic feature type without graphics (FTS) which is
superior towards all types that can create its graphic presentation (GT).
The following statements are valid for feature types defined in such a way:
• Graphics is mandatory for every GT.
• Feature types with shared semantics must have a common non-abstract parent feature type without
geometry.
• All children of a FTS share its semantics. Feature types with shared semantics must not have their
own attributes (they have only attributes inherited from the common parent).
• There must be no child feature types of a feature type with shared semantics.
• GT must be mapped to the same container as FTS.
Example: Shared semantics diagram.
Semantics

Semantic
Table

Feature1 - FT1
Feature2 - GT1

Graphics1

Feature3 - GT2

Graphics2

Feature
Table

Geometry
Table

Example: Shared semantics in model.xml.
<ber:featureType id="ft_501230_m" name="Protection pipe" parentId="ft_5012000"
abstract="false">
<ber:description>Protection pipe - semantic parent</ber:description>
<ber:container refId="ct_5010004"/>
<ber:featureAttributeArray>
<ber:derivedAttribute id="at_5012301" name="First vertex X,Y"
dbName="FIRST_XY">
<ber:dataType>
<ber:string maxLength="30"/>
</ber:dataType>
<ber:attributeQuery>
<ber:geometryQuery>
<ber:geometryFunction name="firstVertexX"/>
<ber:geometryFunction name="firstVertexY"/>
<ber:format>{0:F2},{1:F2}</ber:format>
<ber:sharedSemanticsGraphicChild refId="ft_5012300"/>
</ber:geometryQuery>
</ber:attributeQuery>

Implementation Guide

24

3 – FEATURE TYPES
</ber:derivedAttribute>
</ber:featureAttributeArray>
<ber:redefinedFeatureAttributeArray>
<ber:redefinedDerivedAttribute refId="at_5012002">
<ber:attributeQuery>
<ber:geometryQuery>
<ber:geometryFunction name="length"/>
<ber:sharedSemanticsGraphicChild refId="ft_5012300"/>
</ber:geometryQuery>
</ber:attributeQuery>
</ber:redefinedDerivedAttribute>
</ber:redefinedFeatureAttributeArray>
</ber:featureType>

Semantic child:
<ber:featureType id="ft_5012300" name="Protection pipe - axis"
parentId="ft_501230_m" abstract="false" sharedSemantics="true">
<ber:description>Line with borders</ber:description>
<ber:masterGraphics nillable="false">
<ber:curveGraphicType>
<ber:symbology>
<ber:lineSymbolizer>
<se:Stroke>
<se:SvgParameter name="stroke">#008000</se:SvgParameter>
<se:SvgParameter name="stroke-width">2</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
</ber:symbology>
<ber:dynamicSymbology xlink:href="thematization.xml#fts_5012300"/>
</ber:curveGraphicType>
</ber:masterGraphics>
<ber:graphicTagTypeArray>
<ber:graphicTagType id="ft_5012300_gtda_5060002" name="Protection pipe border line" drawPriority="-1">
<ber:description>Generated border lines</ber:description>
<ber:graphics refId="gtda_5060002"/>
</ber:graphicTagType>
</ber:graphicTagTypeArray>
</ber:featureType>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6
3.3.1

25

Use of shared semantics – buffer zones
Shared semantics can be used also for creating buffer zones around line features. For implementation in
model.xml see following example. There is a parent feature type ft_railway with attributes which hold
information about buffer width for some child feature types and also about count of parcels in buffer
zones (count is found out by spatial relations sr_railway5_parcel and sr_railwayz1_parcel). Buffer
zones themselves are defined in child feature types (ft_railway_buffer_z1, ft_railway_buffer_5). Width
of buffer zone can be defined variable by attribute (at_railway_zone1) or can be fixed to certain value
(ft_railway_buffer_5).
Example: Buffer zones.
<ber:featureType id="ft_railway" name="Railway" parentId="ft_geo" abstract="false">
<ber:description>Semantic parent</ber:description>
<ber:container refId="ct_geo_railway"/>
<ber:featureAttributeArray>
<ber:attribute id="at_railway_zone1" name="Zone 1 width [m]"
dbName="ZONE1_WIDTH">
<ber:dataType>
<ber:decimal precision="10" scale="2"/>
</ber:dataType>
<ber:defaultValue>
<ber:value>10</ber:value>
</ber:defaultValue>
</ber:attribute>
<ber:derivedAttribute id="at_railway_countparcz1" name="Parcel count in zone 1"
dbName="COUNT_PARC_Z1">
<ber:dataType>
<ber:decimal precision="5" scale="0"/>
</ber:dataType>
<ber:attributeQuery>
<ber:relationQuery>
<ber:expression>count(*)</ber:expression>
<ber:relationAssoc refId="sr_railwayz1_parcel"/>
</ber:relationQuery>
</ber:attributeQuery>
</ber:derivedAttribute>
</ber:featureType>
<ber:derivedAttribute id="at_railway_countparc5" name="Parcel count in 10m"
dbName="COUNT_PARC_5">
<ber:dataType>
<ber:decimal precision="5" scale="0"/>
</ber:dataType>

Implementation Guide

3 – FEATURE TYPES

26

<ber:attributeQuery>
<ber:relationQuery>
<ber:expression>count(*)</ber:expression>
<ber:relationAssoc refId="sr_railway5_parcel"/>
</ber:relationQuery>
</ber:attributeQuery>
</ber:derivedAttribute>
...
<ber:featureType id="ft_railway_buffer_z1" name="Railway - buffer zone 1"
parentId="ft_railway" abstract="false" sharedSemantics="true">
<ber:description>Generated polygon - width according to attribute Zone
1</ber:description>
<ber:masterGraphics nillable="false">
<ber:surfaceGraphicType>
<ber:symbology>
<ber:polygonSymbolizer>
<ber:fill>
<se:SvgParameter name="fill">#FAE802</se:SvgParameter>
<se:SvgParameter name="fill-opacity">0.5</se:SvgParameter>
<ber:fillStyle>solid</ber:fillStyle>
</ber:fill>
<se:Stroke>
<se:SvgParameter name="stroke">#FAE802</se:SvgParameter>
<se:SvgParameter name="stroke-opacity">0.7</se:SvgParameter>
</se:Stroke>
</ber:polygonSymbolizer>
</ber:symbology>
</ber:surfaceGraphicType>
</ber:masterGraphics>
</ber:featureType>
...
<ber:featureType id="ft_railway_buffer_5" name="Railway - buffer 10m"
parentId="ft_railway" abstract="false" sharedSemantics="true">
<ber:description>Generated polygon - diameter 10m</ber:description>
<ber:masterGraphics nillable="false">
<ber:surfaceGraphicType>
<ber:symbology>
<ber:polygonSymbolizer>
<ber:fill>
<se:SvgParameter name="fill">#FAE802</se:SvgParameter>
<se:SvgParameter name="fill-opacity">0.5</se:SvgParameter>
<ber:fillStyle>solid</ber:fillStyle>
</ber:fill>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

27

<se:Stroke>
<se:SvgParameter name="stroke">#FAE802</se:SvgParameter>
<se:SvgParameter name="stroke-opacity">0.7</se:SvgParameter>
</se:Stroke>
</ber:polygonSymbolizer>
</ber:symbology>
</ber:surfaceGraphicType>
</ber:masterGraphics>
</ber:featureType>
...
<ber:spatialRelationAssoc id="sr_railway5_parcel" name="Railway 10m &lt;-&gt;
Parcel" dbName="SR_RAILWAY5_PARCEL">
<ber:srcRole refId="rt_parcel_s"/>
<ber:destRole refId="rt_railway"/>
<ber:interactionType>
<ber:faceToFace spatialCondition="intersects"/>
<ber:roleFilter refId="rt_parcel_s">
<ber:featureType refId="ft_parcel_face"/>
</ber:roleFilter>
<ber:roleFilter refId="rt_railway">
<ber:featureType refId="ft_railway_buffer_5"/>
</ber:roleFilter>
</ber:interactionType>
</ber:spatialRelationAssoc>
<ber:spatialRelationAssoc id="sr_railwayz1_parcel" name="Railway zone1 &lt;-&gt;
Parcel" dbName="SR_RAILWAYZ1_PARCEL">
<ber:srcRole refId="rt_parcel_s"/>
<ber:destRole refId="rt_railway"/>
<ber:interactionType>
<ber:faceToFace spatialCondition="intersects"/>
<ber:roleFilter refId="rt_parcel_s">
<ber:featureType refId="ft_parcel_face"/>
</ber:roleFilter>
<ber:roleFilter refId="rt_railway">
<ber:featureType refId="ft_railway_buffer_z1"/>
</ber:roleFilter>
</ber:interactionType>
</ber:spatialRelationAssoc>

Implementation Guide

28

3 – FEATURE TYPES

Implementation Guide

Chapter 4
Attributes

IMPLEMENTATION GUIDE VERSION 9.6

4.

31

Attributes
The main part of a semantic feature type is the definition of its semantic attributes. Every feature attribute
metadata definition contains all available pieces of information. All feature attributes must be defined
inside the featureAttributeArray collection.
Example: Defining feature type with attributes. There are four feature attributes defined for the Pipeline
feature type.
<ber:featureTypeArray>
...
<ber:featureType
id="ft_5012000"
name="Pipeline" parentId="ft_5010000" abstract="true">
<ber:description>Water pipelineAbstract parent of water
pipelines</ber:description>

<ber:featureAttributeArray> <!-- Array of Feature Attributes -->

<ber:attribute id="at_5010004" name="Note" dbName="NOTE"
nillable="true">
<ber:description>Notes for the record</ber:description>
<ber:dataType>

<!--Data Type Definition -->

<ber:string maxLength="80"/> <!-- The string value -->
</ber:dataType>
</ber:attribute>

<ber:attribute id="at_5012002" name="Length [m]" dbName="LENGTH">
<ber:description>The length of a pipeline</ber:description>
<ber:dataType>
<ber:decimal precision="10" scale="2"/> <!-- Decimal number -->
</ber:dataType>
</ber:attribute>

<ber:attribute id="at_5012001" name="Diameter" dbName="C_W_DIAMETER"
nillable="false">
<ber:dataType> <!-- Reference to a code list -->
<ber:codeListRef refId="cl_105" displayColumn="ca_10502"/>
</ber:dataType>
</ber:attribute>

<ber:attribute id="at_5012003" name="Material" dbName="C_W_MATERIAL"
nillable="false">

Implementation Guide

4 – ATTRIBUTES

32

<ber:dataType> <!-- Reference to a code list -->
<ber:codeListRef refId="cl_102" displayColumn="ca_10202"/>
</ber:dataType>
</ber:attribute>

</ber:featureAttributeArray>
</ber:featureType>
...
</ber:featureTypeArray>

4.1

Feature Attribute
Example: In the following example we define a text feature attribute called Note.
<ber:attribute id="at_5010004" name="Note" dbName="NOTE"
nillable="true">
<ber:description>Notes for the record</ber:description>
<ber:dataType>

<!-- The Data Type Definition -->

<ber:string maxLength="80"/> <!-- The string value -->
</ber:dataType>
</ber:attribute>

The description of main XML elements and attributes for a feature attribute is undermentioned.
Attributes
•
•
•
•
•

id – Unique feature attribute identifier. It is unique in the whole project among all metadata
elements, not only attributes.
name – Name of a feature attribute.
dbName – Database column name of a feature attribute.
nillable – Specifies whether this attribute must be filled for every feature instance (nillable=false)
or if it can be left empty (nillable=true).
outputFormat - Number format string. It contains the colon with format specifier and optional
precision specifier (e.g. :f2, :N3 or :F0). Possible values of format specifier are F or f, N or n, D or
n. There is no difference if the format specifier is written in lowercase or uppercase. Detailed
description of the formats is available on following page:
https://docs.microsoft.com/dotnet/standard/base-types/standard-numeric-format-strings

Format Used for
D or d
N or n
F or f

Whole numbers
General numbers
General numbers

Implementation Guide

Group
separator
Minimum number of digits Not used
Number of decimal digits
Used
Number of decimal digits
Not used
Precision specifier

Example
input
1234 :D6
1234.56 :N1
1234.56 :F1

Example
output
001234
1,234.6
1234.6

IMPLEMENTATION GUIDE VERSION 9.6

33

Inner Elements
•
•
•
•

4.2

description – Contains a detailed description of the feature attribute.
dataType – Data type of the feature attribute (mandatory).
defaultValue – Parameter value can be accompanied with parameter next; it is also possible to use
currentDate.
forbiddenOperations – The possible forbidden operations for feature attributes are [select | filter |
update]. The forbidden operations have higher priority than access rights and they are evaluated
before them. The virtual and derived attributes have operation update forbidden from their principle.
This property is inherited to child feature types, but can be redefined

Feature Attribute Data Type
Every feature attribute must have its data type definition. The data type determines the type of all values
for the feature attribute. A list of possible data types is listed below.

4.2.1

String data type
This data type defines text attributes.
Attributes
•
•

•
•

minLength – Minimum number of units of length. Accepted values are 0 to 32767
maxLength – Maximum number of units of length. Accepted values are 1 to 32767, default value
is 100. Please note: Length bigger than 4000 is supported since Oracle 12. MAX_STRING_SIZE =
EXTENDED
has
to
be
set
for
the
database
as
described
here:
https://docs.oracle.com/database/121/REFRN/GUID-D424D23B-0933-425F-BC699C0E6724693C.htm#REFRN10321
pattern – Defines constraint on the value of a datatype. The value of pattern must be a regular
expression.
contentType – Defines the content type which specific application can interpret. For other
applications it behaves as standard string attribute

Example: Using string data types.
<ber:attribute id="at_1" name="Note" dbName="NOTE"
nillable="true">
<ber:description>Notes for the record</ber:description>
<ber:dataType>
<ber:string maxLength="80"/>
</ber:dataType>
</ber:attribute>

<ber:attribute id="at_2" name="e-mail" dbName="EMAIL">
<ber:description>e-mail address</ber:description>
<ber:dataType>

Implementation Guide

4 – ATTRIBUTES

34

<ber:string pattern="^[\w-]+(?:\.[\w-]+)*@(?:[\w-]+\.)+[a-zA-Z]{2,7}$"
maxLength="100"/>
</ber:dataType>

</ber:attribute>
<ber:attribute id="at_3" name="JSON content" dbName="JSON">
<ber:description>Application JSON content</ber:description>
<ber:dataType>
<ber:string maxLength="10000" contentType="application/json"/>
</ber:dataType>
</ber:attribute>

4.2.2

Decimal data type
The decimal data type defines numeric attributes. It is possible to define both decimal and integer
numeric values.
Attributes
•
•
•
•
•
•
•
•
•

precision – Specifies the total number of digits, it is mandatory, possible values range from 1 to 28.
scale – Specifies the number of digits to the right of the decimal point. Accepted values are 0 to
127. If not set or set to 0, the value can only be an integer.
minInclusive – Defines lower bound of the decimal value. The decimal value must be numerically
greater than or equal to value of this constraint.
maxInclusive – Defines upper bound of the decimal value. The decimal value must be numerically
less than or equal to value of this constraint.
minExclusive – Defines lower bound of the decimal value. The decimal value must be numerically
greater than value of this constraint.
maxExclusive – Defines upper bound of the decimal value. The decimal value must be numerically
less than value of this constraint.
pattern – Defines constraint on the value of a datatype. The value of pattern must be a regular
expression.
subtype – Possible values number (default) or duration.
durationUnit – Defines units of duration. Possible values: s for seconds (default), m for minutes, h
for hours, ms for milliseconds. Makes sense only in combination with subtype duration.

Example: Using decimal data type.
<ber:attribute id="at_5012002" name="Length [m]" dbName="LENGTH">
<ber:description>The length of a pipeline</ber:description>
<ber:dataType>
<ber:decimal precision="10" scale="2"/>
</ber:dataType>
</ber:attribute>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6



From version 7.1.4, LIDS checks the maximum precision of decimal data type. The maximum value can
be 28. .NET is not able to work with numbers with bigger precision. Model that includes NUMBER(38)
is not valid and cannot be uploaded. What to do:
•
•



35

Remove SEMOBJ_ID, OBJECT_ID feature attributes. These attributes were added with previous
migration. LIDS 7 and newer versions do not require them.
For other feature attributes change data type to decimal precision="28" or string. To change data
type is quite easy in model.xml but it can be complicated in the database.

LIDS AS does not automatically convert changed data types. You must do it in the database.

4.2.3

Date data type
This data type defines full date attributes. The year, month, day, hour, minute, second and millisecond
information is specified and stored for a date value.
Attributes
•
•
•

pattern –The value of pattern must be a regular expression.
minValue – Defines lower bound of the date value. It can be specified in format "yyyy-mm-dd
hh:mm:ss" or "yyyy-mm-dd".
maxValue – Defines upper bound of the date value. It can be specified in format "yyyy-mm-dd
hh:mm:ss" or "yyyy-mm-dd".

Example: Using date data type.
<ber:attribute id="at_5012103" name="Installation date"
dbName="INSTALL_DATE">
<ber:description>The date of installation</ber:description>
<ber:dataType>
<ber:date/>
</ber:dataType>
</ber:attribute>

4.2.4

Short date data type
This data type defines date only (without time) attributes. The year, month and day information is
specified for a short date value.
Attributes
•
•
•

pattern – The value of pattern must be a regular expression.
minValue – Defines lower bound of the date value. It can be specified in format "yyyy-mm-dd".
maxValue – Defines upper bound of the date value. It can be specified in format "yyyy-mm-dd".

Implementation Guide

4 – ATTRIBUTES

36



Short date values are stored in the full form (including time) in Oracle DB.
Example: Using shortDate data type.
<ber:attribute id="at_5012203" name="Installation date"
dbName="INSTALL_DATE">
<ber:description>The date of installation</ber:description>
<ber:dataType>
<ber:shortDate/>
</ber:dataType>
</ber:attribute>

4.2.5

Codelist reference data type
This special data type means that the only possible value for the feature attribute is a record from a
codelist (it refers a codelist value). This data type holds the codelist identifier and a displayable column
identifier. The displayable column is the codelist column that will be displayed as the attribute value.
Internally, the codelist key is stored as the attribute value. (For more information see chapter 5.)
Attributes
•
•
•

pattern – The value of pattern must be a regular expression.
refId – Refers to codeList Id.
displayColumn – Refers to codeList's display column.

Example: Using codeListRef data type.
<ber:attribute id="at_5012001" name="Diameter"
dbName="C_W_DIAMETER" nillable="false">
<ber:dataType> <!-- Reference to a code list -->
<ber:codeListRef refId="cl_105" displayColumn="ca_10502"/>
</ber:dataType>
</ber:attribute>

4.3

Default Values of Attributes
A default attribute value is set as an attribute value when creating a new feature in case that the value
has not been specified. The expression inside the XML value element must have correct data type (string,
number, date). If the attribute has a codeListRef data type the value must refer a key within the codelist.
Example: In the following example we define a default value for a codelist attribute Diameter. This
value is set to Diameter attribute in case when new feature is inserted without specifying its Diameter.
<ber:attribute id="at_5012100_diameter" name="Diameter"
dbName="C_W_DIAMETER" nillable="false">

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

37

<ber:dataType>
<ber:codeListRef refId="cl_105" displayColumn="ca_10502"/>
</ber:dataType>
<ber:defaultValue>
<ber:value>-1</ber:value>
</ber:defaultValue>
</ber:attribute>

Example: In the following example we define a default value for shortDate attribute
<ber:attribute id="at_date" name="" dbName="…">
<ber:dataType>
<ber:shortDate/>
</ber:dataType>
<ber:defaultValue>
<ber:value>2020-01-28</ber:value>
</ber:defaultValue>
</ber:attribute>

Default value can be defined as static value or as dynamic value depending on the values of other
attributes. simpleQuery must be used in the definition. geometryQuery and relationQuery are not
allowed,
Example: In the following example we define a default value which depends on another attribute.
Default value is updated after updating the referred attribute
<ber:attribute id="at_nextCheckDate" name="Next check date" dbName="…">
<ber:dataType>
<ber:date/>
</ber:dataType>
<ber:dynamicDefaultValue>
<ber:simpleQuery>
<ber:attributeArray>
<ber:attribute xpath="at_checkDate"/>
</ber:attributeArray>
<!-- choice of format or expression -->
<ber:expression>{0} + 7</ber:expression>
</ber:simpleQuery>
</ber:dynamicDefaultValue>
</ber:attribute>

Implementation Guide

4 – ATTRIBUTES

38

4.4
4.4.1

Attribute Validation
Constraints on single attributes
There is a possibility to define constraints depending on its data type for each attribute. The attribute
values are validated against these constraints when active operation is performed. Active operations
mean feature insert or update. Obviously, the default attribute value (if defined) must meet the validation
constraints.
Each data type has its own constraints inspired by XML Schema restrictions:
String Data Type Constraints
string

maxLength

maximal string length

minLength

minimal string length

pattern

regular expression that the value must match

Example: Setting the maximal length of a value.
<ber:attribute id="at_5011005" name="Serial number"
dbName="SERIAL_NUM">
<ber:dataType>
<ber:string maxLength="40" />
</ber:dataType>
</ber:attribute>

Decimal Data Type Constraints
decimal

minInclusive

minimal decimal value (decimal value >= value)

maxInclusive

maximal decimal value (decimal value <= value)

minExclusive

minimal decimal value (decimal value > value)

maxExclusive

maximal decimal value (decimal value < value)

pattern

regular expression that the decimal value must match

precision

total number of digits

scale

number of digits after decimal point

Example: Defining minimal and maximal decimal value for altitude attribute.
<ber:attribute id="at_5012104" name="Altitude-beginning"
dbName="ALT_BEG">
<ber:dataType>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

39

<ber:decimal precision="7" scale="2" minInclusive="-11034"
maxInclusive="8848" />
</ber:dataType>
</ber:attribute>

Date and Short Date Data Type Constraints
date

minValue

minimal date value

maxValue

maximal date value (format: yyyy-MM-dd or yyyy-MM-dd hh:mm:ss)

pattern

regular expression that the decimal value must match

Example: Defining minimal and maximal date value for an installation date attribute.
<ber:attribute id="at_5012103" name="Installation date"
dbName="INSTALL_DATE">
<ber:dataType>
<ber:date minValue="1848-01-01" maxValue="2099-01-01" />
</ber:dataType>
</ber:attribute>

All data types have the common constraint pattern, which specifies regular expression. The value must
match that expression. Regular expressions correspond to the type 3 grammars of the Chomsky
hierarchy and may be used to describe a regular language. The accepted syntax is taken from Perl and
it is compatible with Java or .NET form of expression language.
Example: Pattern for e-mail address.
^[\w-]+(?:\.[\w-]+)*@(?:[\w-]+\.)+[a-zA-Z]{2,7}$

4.4.2

Constraints on attributes combination
It’s possible to define set of more complex rules for every feature type. Every rule consists of:
• condition – attribute filter. If this condition is true, constraints are evaluated. It’s possible to define
more conditions. Constraints are evaluated only if all conditions are true
• constraint – constraint defines, that particular attribute:
• has to be equal, not equal, smaller or greater than something, or IN defined values
• can’t be NULL
• is set to particular value (including NULL value) – force attribute
• is read only



If readOnly is combined with force attribute, attribute becomes not editable and particular value is set
automatically by the system

Implementation Guide

40




4 – ATTRIBUTES
If some attributes values combination is required, it might be impossible to edit attribute data in client
applications working in autosave mode. The constraints are evaluated after every change sent to the
server.

If a string codelist identifier is used, the value must be enclosed by apostrophes.

Example: attributeRuleArray in model.xml.
<ber:attributeRuleArray>
<ber:rule id="rule1" name="at1 -1">
<ber:description>If at1 = -1 and at2 > 8, then at2 is set to NULL and becomes
not editable, at3 is set to NULL but remains editable, at4 has to be NULL and
becomes not editable, at5 has to be in 1, 2, 3</ber:description>
<ber:condition>{at1} = -1</ber:condition>
<ber:condition>{at2} > 8</ber:condition>
<ber:constraint readOnly="true" force="true">{at2} = NULL</ber:constraint>
<ber:constraint force="true">{at3} = NULL</ber:constraint>
<ber:constraint readOnly="true">{at4} = NULL</ber:constraint>
<ber:constraint>{at5} IN (1,2,3)</ber:constraint>
</ber:rule>
<ber:rule id="rule2" name="at2 &lt;= 0">
<ber:description>If at2 &lt;= 0, then at3 is set to 0</ber:description>
<ber:condition>{at2} &lt;= 0</ber:condition>
<ber:constraint force="true">{at3} = 0</ber:constraint>
</ber:rule>
<ber:rule id="rule3" name="at3 &gt; 0">
<ber:description>If at3&gt;0, then at4 can't be NULL,
at5&gt;0</ber:description>
<ber:condition>{at3} &gt; 0</ber:condition>
<ber:constraint>{at4} != NULL</ber:constraint>
<ber:constraint>{at5} &gt; 0</ber:constraint>
</ber:rule>
</ber:attributeRuleArray>

4.4.3

Mandatory attributes
As described in the previous chapters, there are two possible ways to define that value of particular
attribute cannot be null and has to be filled:
• nillable="false" parameter at attribute definition
• constraint != NULL at attribute rule definition
These possibilities seem to be equivalent but the system behavior is slightly different, especially when
it comes to manipulating data which breaks the rules. In case of nillable="false" parameter, the system

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

41

really expects the value of such attribute to be filled. This definition should be used just in the situations
when the data is really filled, it might be also complemented by generating not null constraints in the
database in the future.



In case of mandatory codelist attributes, the system generates simple joins between the semantic table
and the codelist table. Simple join is expected to provide better performance than the outer join. This
simple join causes feature records with empty values of such mandatory codelist attributes to be
excluded from the result set. That’s why it’s not possible to combine empty codelist attributes with the
nillable="false" parameter. In such case it’s necessary to fill the empty attribute with some “undefined”
value which exists in the codelist and introduce additional constraint != “undefined” which forces the
users to enter value different than “undefined” during the editing. Or the attribute should be defined as
nillable="true" in combination with constraint != NULL

4.4.4

Unique attributes
Attribute values uniqueness constraint can be defined on combination of more attributes by uniqueRule
in attributeRuleArray. The constraint can contain optional ignoreNullValues attribute to control how
NULL values are handled during validation.
•
•
•
•

Definition is inherited from parent feature type to all child feature types
It’s not possible to include virtual attributes in the constraint
In case of featureRef attrbiutes only the master feature SID is considered
In case of codelist attributes only the codelist primary key is considered

Example: Uniqueness defined for three attributes
<ber:attributeRuleArray>
<ber:uniqueRule id="uc_1" name="Attributes values combination must be unique">
<ber:description>NULL values are ignored</ber:description>
<ber:constraint ignoreNullValues="true">{at_1},{at_2},{at_3}</ber:constraint>
</ber:uniqueRule>
</ber:attributeRuleArray>

4.4.5

Unique attributes – obsolete definition
Unique constraint can be defined in metadata for a feature attribute. The definition can be redefined for
child feature types. Database constraint is generated according to this flag. The database constraint usage
defines following behavior in case of more feature types sharing the same attribute:
• more feature types in one container - the constraint is evaluated for the whole container
• more feature types in more containers - uniqueness is checked for every container separately



This definiton was replaced in LIDS 8.25.6 by the uniqueRule definition

Implementation Guide

4 – ATTRIBUTES

42

Example: Uniqueness defined directly at the attribute definition
<ber:attribute id="at_123" name="Unique ID" dbName="ID" unique="true">
<ber:dataType>
<ber:decimal precision="12" scale="0"/>
</ber:dataType>
</ber:attribute>

Example: Uniqueness defined for redefined attributes
<ber:redefinedFeatureAttributeArray>
<ber:redefinedAttribute refId="at_456" unique="true"/>
<ber:redefinedAttribute refId="at_789" unique="false"/>
</ber:redefinedFeatureAttributeArray>

4.5

Derived Attributes
Feature attribute can be defined as derived. Then its value is not provided directly by user by it is
automatically derived from some other data in system.

4.5.1

Simple derived attributes
In case when attribute is derived from other attributes of the same feature it is called simple derived
attribute. It is defined by simple query.
Example: In the following example we define a simple derived attribute Description.
<ber:derivedAttribute id="at_fibre_description" name="Description"
dbName="DESCRIPTION">
<ber:dataType>
<ber:string maxLength="255"/>
</ber:dataType>
<ber:attributeQuery preventRegeneration =”true”>
<ber:simpleQuery>
<ber:attributeArray>
<ber:attribute xpath="at_fibre_cable_id_2"/>
<ber:attribute xpath="at_fibre_ordernum"/>
<ber:attribute xpath="at_telco_id"/>
</ber:attributeArray>
<ber:format>Cable id: {0}, {1,4} {2}</ber:format>
</ber:simpleQuery>
</ber:attributeQuery>
</ber:derivedAttribute>

•

attributeQuery – Mandatory element of derived attribute. Includes complete definition for attribute
deriving.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6
•

•
•
•

•

43

preventRegeneration – Optional attribute. If set to true, the derived attribute will be updated only
when changing the source attributes. The derived attribute will be exluded from the on demand
regenerating.
simpleQuery – Definition for attributes derived from other attributes of the same feature.
attributeArray – List of attributes used for this attribute deriving. An update of any attribute in this
array triggers refreshing of the derived attribute
format - Format of derived attribute value. Uses .NET syntax. Attributes from attribute array are
referred by index in curly brackets. The first attribute in array has index {0}. It can be used to define
format of decimal number or concatenating attributes with constant strings
expression – expression can be used instead of format. The expression string can also include
attributes references in curly brackets. The expression is processed directly by the database, so the
syntax has to comply to the used database engine

Example: Another example of simple derived attribute Cable length. Here expression is used instead of
simple format to enable calling Oracle DB functions for attribute deriving.
<ber:derivedAttribute id="at_cable_length" name="Cable length [m]"
dbName="CABLE_LENGTH">
<ber:dataType>
<ber:decimal precision="10" scale="2"/>
</ber:dataType>
<ber:attributeQuery>
<ber:simpleQuery>
<ber:attributeArray>
<ber:attribute xpath="at_length_of_routes"/>
<ber:attribute xpath="at_length_of_ducts"/>
</ber:attributeArray>
<ber:expression>NVL({0},0)+ NVL({1},0)</ber:expression>
</ber:simpleQuery>
</ber:attributeQuery>
</ber:derivedAttribute>

Format element
Generally a format element contains a text with one or more placeholders for referred attribute values.
Every placeholder is enclosed in curly brackets. For example, in this simple format definition
<ber:format>Diameter: {0}mm, Length: {1}m</ber:format> are two placeholders just replaced by two
values. But the placeholder can contain another formatting specifiers for more sophisticated result.
The formatting placeholder syntax is:
{index[,[+|-]alignment][:formatSpecifier[precision]]}

Implementation Guide

4 – ATTRIBUTES

44

String formatting
We can define string alignment, for example:
Format

Value

Output

-&gt;{0,10}&lt;- "Hello"

->·····Hello<-

-&gt;{0,-10}&lt;- "Hello"

->Hello·····<-

-&gt;{0,-10}&lt;- "123456" ->123456····<Number formatting specifiers
Specifier Type

Format Output (Passed Double 1.42) Output (Passed Int -12400)

D or d

Decimal (Whole
number)

{0:d}

FormatException

-12400

E or e

Scientific

{0:e}

1.420000e+00

-1.240000e+04

F or f

Fixed point

{0:f}

1.420000

-12400.000000

G or g

General

{0:g}

1.42000

-14200.0

X or x

Hexadecimal

{0:x4}

FormatException

cf90

Number rounding
Format

Value

Output

Comment

{0:F2}

12345.6789 12345.68

rounds up

{0:F0}

12345.6789 12346

rounds up

{0:F6}

12345.6789 12345.678900

-&gt;{0,10:F2}&lt;- 12345.6789 ->··12345.68<- rounds up
-&gt;{0,-10:F0}&lt;- 12345.6789 ->12346·····<- rounds up

4.5.2

Attributes derived from related features
In case when feature attribute is derived from features connected by relation it is defined by relation
query.



If the relation association used in the query allows more features to be related (cardinality is not 1), it’s
necessary to define some grouping function like min, max, count, sum, listagg. This is necessary to
assure, that just one value is returned. Otherwise more values would be returned and it wouldn’t be
possible to save them in single attribute.
If there is no feature related by the relationAssoc used in the relationQuery, the returned value would be
typically NULL. To return some reasonable result, fallbackValue attribute has to be defined. This works
for derived attributes, not for virtual attributes. Format of fallbackValue for date attributes is "2024-0123" for shortDate and "2024-01-23 12:00:00" for date.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

45

Example: In the following example extraction point simply derives identification of its service pipe to
attribute Service pipe – Identification. There is a relation between extraction point and service pipe (with
id sr_5012200_5010200) that is used for this attribute deriving.
<ber:derivedAttribute id="at_5010202" name="Service pipe - Identification"
dbName="SP_IDENTIFICATION">
<ber:dataType>
<ber:string maxLength="40"/>
</ber:dataType>
<ber:attributeQuery>
<ber:relationQuery>
<ber:attributeArray>
<ber:attribute xpath="at_5010007"/>
</ber:attributeArray>
<ber:relationAssoc refId="sr_5012200_5010200"/>
</ber:relationQuery>
</ber:attributeQuery>
</ber:derivedAttribute>

Example: Another example of attribute derived from related features. In this case derived attribute
Parcel count derives number of parcels crossed by a pipeline segment. There is a relation between
pipeline segment and parcels (with id sr_mps_parcel) that is used for this attribute deriving.
<ber:derivedAttribute id="at_5012100_countparc" name="Parcel count"
dbName="COUNT_PARC">
<ber:dataType>
<ber:decimal precision="5" scale="0"/>
</ber:dataType>
<ber:attributeQuery>
<ber:relationQuery fallbackValue="0">
<ber:expression>count(*)</ber:expression>
<ber:relationAssoc refId="sr_mps_parcel"/>
</ber:relationQuery>
</ber:attributeQuery>
</ber:derivedAttribute>

Example: Use of an optional element <filterRelated> within <relationQuery> element. It is possible
to define an OGC filter on semantics of the related features.
<ber:derivedAttribute id="at_5060004_o" name="Service pipes in order count"
dbName="COUNT_SERVICEP_O">
<ber:dataType>
<ber:decimal precision="5" scale="0"/>
</ber:dataType>
<ber:attributeQuery>
<ber:relationQuery>

Implementation Guide

4 – ATTRIBUTES

46

<ber:expression>count(*)</ber:expression>
<ber:relationAssoc refId="sr_5060000_5012200"/>
<ber:filterRelated>
<ogc:Filter>
<ogc:And>
<ogc:PropertyIsEqualTo>
<ogc:PropertyName>at_5010100</ogc:PropertyName>
<ogc:Literal>1</ogc:Literal>
</ogc:PropertyIsEqualTo>
<ogc:PropertyIsLike wildCard="%" singleChar="_" escapeChar="\">
<ogc:PropertyName>@ftid</ogc:PropertyName>
<ogc:Literal>ft_building%</ogc:Literal>
</ogc:PropertyIsLike>
</ogc:And>
</ogc:Filter>
</ber:filterRelated>
</ber:relationQuery>
</ber:attributeQuery>
</ber:derivedAttribute>

•
•
•

4.5.3

PropertyIsEqualTo – Type of filter condition.
PropertyName – Item (attribute) the filter is applied to. If filer is applied to system attribute, “@”
needs to be added.
Literal – Specification of filtering value.

Geometry derived attributes
Derivation of attribute value from geometry characteristics is performed by geometry query.
Example: Derivation by geometric function.
<ber:derivedAttribute id="at_5010106" name="WGS-84 coordinates"
dbName="WGS84_COORD">
<ber:dataType>
<ber:string maxLength="40"/>
</ber:dataType>
<ber:attributeQuery>
<ber:geometryQuery>
<ber:geometryFunction name="firstVertexX"/>
<ber:geometryFunction name="firstVertexY"/>
<ber:convertSrs outputSrs="EPSG:4326" attrIndexX="0" attrIndexY="1"/>
<ber:format>{1}, {0}</ber:format>
</ber:geometryQuery>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

47

</ber:attributeQuery>
</ber:derivedAttribute>

•
•

•
•
•

4.5.4

geometryQuery – Definition for attributes derived from other attributes using geometry functions.
geometryFunction – You can use functions area, centroidX, centroidY, firsVertexX, firstVertexY,
firstVertexZ, lastVertexX, lastVertexY, lastVertexZ, length (can be used also for perimeter of
surface geometry), maxX, maxY, minX, minY, rotation, rotationGrad, rotationRad.
convertSrs – Coversion of spatial refrence system. Parameters outputSrs, attrIndexX, attrIndexY.
format - Format of derived attribute value. Uses .NET syntax. Attributes from attribute array are
referred by index in curly brackets. The first attribute in array has index {0}.
sharedSemanticsGraphicChild – Refers graphic child of feature type with the shared semantics.

Combined derived attributes
Query for deriving value can contain a combination of simple, geometry and relation query. Because of
just one derived value is expected, the format or expression must be given for the concatenation of
individual results.
ComplexQuery must contain:
- exactly one simpleQuery
- one relationQuery and / or one geometryQuery
Example: Derivation by more queries.
<ber:derivedAttribute id="at_complex" name="Complex info" dbName="COMPLEX_INFO">
<ber:dataType>
<ber:string maxLength="120"/>
</ber:dataType>
<ber:attributeQuery>
<ber:complexQuery>
<ber:queryArray>
<ber:simpleQuery>
<ber:attributeArray>
<ber:attribute xpath="at_5012104"/>
<ber:attribute xpath="at_5012105"/>
</ber:attributeArray>
<ber:expression>{1} - {0}</ber:expression>
</ber:simpleQuery>
<ber:geometryQuery>
<ber:geometryFunction name="length"/>
<ber:expression>nvl({0}, 0)</ber:expression>
</ber:geometryQuery>
<ber:relationQuery>
<ber:attributeArray>
<ber:attribute xpath="at_5040007"/>
</ber:attributeArray>

Implementation Guide

48

4 – ATTRIBUTES
<ber:relationAssoc refId="r_5040000_5012100"/>
</ber:relationQuery>
</ber:queryArray>
<!--ber:format>Gradient: {0}, Length: {1}, Main Id: {2}</ber:format-->
<ber:expression>'Gradient: ' || nvl2({0},'{0}','') || ', Length: {1}, Main
Id: {2}'</ber:expression>
</ber:complexQuery>
</ber:attributeQuery>
</ber:derivedAttribute>

4.5.5

Cross sections derived attributes
This type of attribute is intended for cross-section feature types (routes, ducts, cables). The deriving
functions are crossSectionFunction with following possibilities:
• csDescription – derives description of assigned cross section to a route attribute
• csName – derives name of assigned cross section to a route attribute
• maxPositionsCount – derives count of cable positions defined for a duct or for a route
• assignedPositionsCount – derives count of used cable positions for a duct or for a route
• freePositionsCount – derives count of free cable positions for a duct or for a route
• mbrWidth / mbrHeight – derives width or height of MBR encapsulating geometry of assigned crosssection components. The cross-section used for calculateing MBR are defined in
includedGraphicTypeComponent element
Example: Derivation of name of assigned cross section.
<ber:derivedAttribute id="at_cs_name" name="Cross section name" dbName="CS_NAME">
<ber:dataType>
<ber:string maxLength="100"/>
</ber:dataType>
<ber:attributeQuery>
<ber:crossSectionQuery>
<ber:crossSectionFunction name="csName"/>
</ber:crossSectionQuery>
</ber:attributeQuery>
</ber:derivedAttribute>

Example: Derivation of cross-section width.
<ber:derivedAttribute id="at_cs_width" name="Cross section width" dbName="CS_W">
<ber:dataType>
<ber:decimal precision="6" scale="2"/>
</ber:dataType>
<ber:attributeQuery>
<ber:crossSectionQuery>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

49

<ber:crossSectionFunction name="mbrWidth"/>
<ber:includedGraphicTypeComponentArray>
<ber:includedGraphicTypeComponent refId="gtcs_0001_01"/>
<ber:includedGraphicTypeComponent refId="gtcs_0001_02"/>
<ber:includedGraphicTypeComponent refId="gtcs_0001_03"/>
</ber:includedGraphicTypeComponentArray>
</ber:crossSectionQuery>
<ber:attributeQuery>
</ber:derivedAttribute>

4.5.6

Security derived attributes
Security derived attribute is defined for deriving a security codelist value. Definition is similar to
ordinary attribute, only there is a reference to a codelist (<ber:codeListRef refId="cl_018"…) and its
column (…displayColumn="ca_01802"/>).
Example: Security derived attribute.
<ber:securityDerivedAttribute id="at_5120006_s" name="Operation status">
<ber:dataType>
<ber:codeListRef refId="cl_018" displayColumn="ca_01802"/>
</ber:dataType>
<ber:defaultValue>
<ber:value>1</ber:value>
</ber:defaultValue>
<ber:attributeQuery>
<ber:relationQuery>
<ber:attributeArray>
<ber:attribute xpath="at_5120005_s"/>
</ber:attributeArray>
<ber:expression>min({0})</ber:expression>
<ber:relationAssoc refId="r_route_duct"/>
</ber:relationQuery>
</ber:attributeQuery>
</ber:securityDerivedAttribute>

4.5.7

Virtual attributes
The special case of derived attributes are virtual attributes. Opposite to derived attributes they are not
physically stored in database. They exist only virtually and they are derived every time they are required
by client application. However the definition is nearly same as the derived attribute definition – you can
use the same functions, including geometric (see chapter 4.5.3).

Implementation Guide

4 – ATTRIBUTES

50

Example: Definition of virtual attribute, used for visualization of material codelist id.
<ber:virtualAttribute id="at_5012115" name="Material ID">
<ber:dataType>
<ber:string maxLength="5"/>
</ber:dataType>
<ber:attributeQuery>
<ber:simpleQuery>
<ber:attributeArray>
<ber:attribute xpath="at_5012003/ca_10201"/>
</ber:attributeArray>
</ber:simpleQuery>
</ber:attributeQuery>
</ber:virtualAttribute>



When you have feature type that is not abstract and this feature type has no geometry, you cannot define
derived attribute with geometry function. It makes no sense. For feature without geometry you can't
compute length. LIDS AS will check this and does not allow to upload or start with such metadata. This
problem is usually caused by previous version of migration. What to do:
•
•
•
•




4.6

Change feature type to be abstract.
Move derived attribute from parent feature type to all child feature types
Change derived attribute to normal attribute. Redefine this attribute in all children to be derived.
Create child feature type of the problematic feature type. Make this new feature type abstract. Move
the derived attribute to the new feature type. Change parents for all child feature types of the
problematic feature type to the new feature type.

Attribute identifier (id) may be at most 30 characters long.

Virtual attributes can't be used for subsequent deriving of other attributes, symbology tokens, DAs; also
they can't be redefined.

Virtual attributes are not updated automatically when the source geometry / attributes change. Feature
must be manually reloaded.

FeatureRef Attribute
Special type of attributes are featureRef attributes. In fact, the visible values represent values from
master feature type in 1:N or 1:1 relation. Moreover, featureRef attributes are physically stored in
semantic table instead of association table.
Example: Definition of featureRef attribute.
<ber:featureRefAttribute id="at_1" name="Some name" dbName="XY">
<ber:dataType>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

51

<ber:featureRef>
<ber:attribute refId="at_2"/>
<ber:featureRefRelationAssoc refId="r_1"/>
</ber:featureRef>
</ber:dataType>
</ber:featureRefAttribute>




Attribute identifier (id) may be at most 30 characters long.

The referred master feature attributes can be of any data type including featureRef. It’s only not possible
to refer system attributes this way. Referring featureRef attribute currently (LIDS 8.16) causes problems
with the Search extension. It’s not possible to index such attributes.
A featureRef attribute can define more attributes from the master feature directly. In such case, one of
the referred attributes has to be marked by the default attribute.
Example: Definition featureRef attribute referring more attributes of master feature.
<ber:featureRefAttribute id="at_1" name="Some name" dbName="XY">
<ber:dataType>
<ber:featureRef>
<ber:attribute refId="at_2"/>
<ber:attribute refId="at_3" default="true"/>
<ber:attribute refId="at_4"/>
<ber:featureRefRelationAssoc refId="r_1"/>
</ber:featureRef>
</ber:dataType>
</ber:featureRefAttribute>

Relation featureRefRelationAssoc must be defined for each featureRef attribute. It has master role and
child role. Master role does not define cardinality, it must be 1 in every case.



Optionally, it’s possible to specify orderBy element which defines according to which atttribute the list
of possible values is ordered when editing the featureRefAttribute.
Example: Definition of featureRefRelationAssoc:
<ber:featureRefRelationAssoc id="r_1" name="Some name">
<ber:masterRole refId="rt_1">
<ber:orderBy>
<ber:attribute refId="at_XYZ" direction="ascending" position="0"/>
<ber:attribute refId="at_ABC" direction="ascending" position="1"/>
</ber:orderBy>
</ber:masterRole>

Implementation Guide

4 – ATTRIBUTES

52

<ber:childRole refId="rt_2"/>
</ber:featureRefRelationAssoc>



To enable autocomplete when editing featureRef attribute in LIDS clients, following configuration is
necessary:
-

the master feature type has to be indexed in Elastic and included in searchMetaGroup in
explorer.xml
the master feature display attribute has to be indexed with fieldPreset - startswith in search.xml

-

<ber:indexedAttribute>
<ber:includeAttribute>at_master</ber:includeAttribute>
<ber:fieldPreset>startswith</ber:fieldPreset>
</ber:indexedAttribute>

4.7

Generated Attribute
Special type of attribute is a generated attribute. It is a feature attribute referencing the number generator,
which has to be also defined in section numberGeneratorArray.
Example: Definition of generated attribute.
<ber:numberGeneratorArray>
<ber:numberGenerator id="seq_sernum" name="Serial number"
dbName="SEQ_SER_NUMBER" startValue="1" step="1">
<ber:description>Optional description</ber:description>
</ber:numberGenerator>
</ber:numberGeneratorArray>
...
<ber:generatedAttribute id="at_5011005" name="Serial number" dbName="SERIAL_NUM">
<ber:dataType>
<ber:string maxLength="40"/>
</ber:dataType>
<ber:attributeQuery>
<ber:numberGeneratorQuery>
<ber:numberGenerator refId="seq_sernum"/>
<ber:format>SN_{0}</ber:format>
</ber:numberGeneratorQuery>
</ber:attributeQuery>
</ber:generatedAttribute>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

4.8

53

Redefined Attribute
Feature attribute can be set as redefined. You can define feature attribute in a parent feature type and
redefine some properties in children feature types.
What you can redefine:
•
•
•
•

Default values.
Whether the attribute is mandatory (nillable flag in model).
Forbidden operations (READ, QUERY, UPDATE).
Codelist reference (you can change a codelist data type to a different codelist, different codelist must
be a filtered codelist based on previous codelist).
• Derived attribute query (you can define deriving query in children feature types, you can change
deriving query in children feature types).
You can change the type of the attribute from normal (parent) to derived in any child. You can make
multiple redefinition of one attribute.
Example 1:
Original definition of attribute:
<ber:securityAttribute id="at_5120006_s" name="Operation status">
<ber:dataType>
<ber:codeListRef refId="cl_018" displayColumn="ca_01802"/>
</ber:dataType>
<ber:defaultValue>
<ber:value>1</ber:value>
</ber:defaultValue>
</ber:securityAttribute>

Redefinition:
<ber:redefinedFeatureAttributeArray>
<ber:redefinedSecurityDerivedAttribute refId="at_5120006_s">
<ber:attributeQuery>
<ber:relationQuery>
<ber:attributeArray>
<ber:attribute xpath="at_5120006_s"/>
</ber:attributeArray>
<ber:expression>min({0})</ber:expression>
<ber:relationAssoc refId="r_route_duct"/>
</ber:relationQuery>
</ber:attributeQuery>
</ber:redefinedSecurityDerivedAttribute>
</ber:redefinedFeatureAttributeArray>

Implementation Guide

54

4 – ATTRIBUTES
Example 2:
Original definition of attribute:
<ber:attribute id="at_5123405" name="Diameter [cm]" dbName="C_E_DIAMETER">
<ber:dataType>
<ber:codeListRef refId="cl_319" displayColumn="ca_31902"/>
</ber:dataType>
</ber:attribute>

Redefinition 1:
<ber:redefinedFeatureAttributeArray>
<ber:redefinedAttribute refId="at_5123405" nillable="false">
<ber:defaultValue>
<ber:value/>
</ber:defaultValue>
</ber:redefinedAttribute>
</ber:redefinedFeatureAttributeArray>

Redefinition 2:
<ber:redefinedDerivedAttribute refId="at_5123405">
<ber:attributeQuery>
<ber:relationQuery>
<ber:attributeArray>
<ber:attribute xpath="at_5123405"/>
</ber:attributeArray>
<ber:relationAssoc refId="r_duct_sch_duct"/>
</ber:relationQuery>
</ber:attributeQuery>
</ber:redefinedDerivedAttribute>

Example 3: Multiple redefinition of nillable, defaultValue, codelist reference property.
Original definition:
<ber:attribute id="at_5012000_diameter" name="Diameter"
dbName="C_W_DIAMETER" nillable="false">
<ber:dataType>
<ber:codeListRef refId="cl_105" displayColumn="ca_10502"/>
</ber:dataType>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

55

<ber:defaultValue>
<ber:value>-1</ber:value>
</ber:defaultValue>
</ber:attribute>

Redefinition 1:
<ber:redefinedFeatureAttributeArray>
<ber:redefinedAttribute refId="at_5012000_diameter">
<ber:dataType>
<ber:codeListRef refId="cl_505" displayColumn="ca_10502"/>
</ber:dataType>
<ber:defaultValue>
<ber:value>15</ber:value>
</ber:defaultValue>
</ber:redefinedAttribute>
</ber:redefinedFeatureAttributeArray>

Redefinition 2:
<ber:redefinedFeatureAttributeArray>
<ber:redefinedAttribute refId="at_5012000_diameter" nillable="true"/>
<ber:redefinedAttribute refId="at_5012003" nillable="true"/>
<ber:redefinedAttribute refId="at_5010001" nillable="true"/>
</ber:redefinedFeatureAttributeArray>

Example 4: Redefinition with reference to shared semantics, redefinition contains geometry query.
Original definition:
<ber:attribute id="at_5110004" name="Area [m²]" dbName="AREA">
<ber:dataType>
<ber:decimal precision="10" scale="2"/>
</ber:dataType>
</ber:attribute>

Redefinition:
<ber:redefinedFeatureAttributeArray>
<ber:redefinedDerivedAttribute refId="at_5110004" outputFormat=":f2">
<ber:attributeQuery>
<ber:geometryQuery>
<ber:geometryFunction name="area"/>

Implementation Guide

56

4 – ATTRIBUTES
<ber:sharedSemanticsGraphicChild refId="ft_5111200"/>
</ber:geometryQuery>
</ber:attributeQuery>
</ber:redefinedDerivedAttribute>
</ber:redefinedFeatureAttributeArray>
...
<ber:redefinedFeatureAttributeArray>
<ber:redefinedDerivedAttribute refId="at_5110004">
<ber:attributeQuery>
<ber:geometryQuery>
<ber:geometryFunction name="area"/>
<ber:sharedSemanticsGraphicChild refId="ft_5114200"/>
</ber:geometryQuery>
</ber:attributeQuery>
</ber:redefinedDerivedAttribute>
</ber:redefinedFeatureAttributeArray>

4.9

Feature Info
Feature info defines the human readable feature identification. It is feature type based and is defined as
a system attribute in the rootFeatureType. To define the identification, feature type can use any of its
attributes. Reference to the desired attribute is located inside the feature type definition.
If defined, featureInfo identification is displayed for example in LIDS Explorer in Subordinate Features
Tree.
Example: Definition of featureInfo system attribute.
<ber:rootFeatureType id="ft_5000002" name="Root" abstract="true">
<ber:description>ROOT_NODE</ber:description>
<ber:featureAttributeArray>
<ber:systemAttribute id="id" name="Feature ID"/>
<ber:systemAttribute id="sid" name="Semantic ID"/>
...
<ber:systemAttribute id="validTo" name="Valid To"/>
<ber:systemAttribute id="featureInfo" name="Feature Info"/>
</ber:featureAttributeArray>
</ber:rootFeatureType>

Example: Feature info definition.
<ber:featureType id="ft_damage" name="Damage" parentId="ft_inspection"
abstract="false">
...
<ber:featureAttributeArray>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

57

...
</ber:featureAttributeArray>
<ber:featureInfo refId="at_inspection_description"/>
<ber:formArray>
...
</ber:formArray>
</ber:featureType>

•




featureInfo – Defines the human readable feature identification.

FeatureInfo definition is inherited from the parent feature types. Child feature type can define its own
definition.

Existing data needs to be refreshed after adding / modifying the definition by calling deriveFeatureInfos
service.

Implementation Guide

Chapter 5
Codelists

IMPLEMENTATION GUIDE VERSION 9.6

5.

61

Codelists
Codelist is a special feature attribute data type. In fact, codelist is a collection of a codelist items. Each
codelist must have a key column and a displayable column. If a feature attribute refers a codelist, it
means that the value of the feature attribute must be one of the codelist item.
In general, codelists can have more than key and displayable column. It can have as many columns as
needed. A codelist in general can be referenced from many feature attributes within many feature types.
Sometimes there is a requirement to display different column as a description from different feature
attributes that refer the same codelist. That is why the displayable column can be defined in two places.
There can be the default displayable column defined in codelist definition and furthermore each feature
attribute (of the codelist reference type) can redefine the displayable column by choosing another of
codelist columns as displayable.

5.1

Defining Codelist
Example: Diameter codelist metadata definition (codelist contains two columns: Identifier and
Description).
<ber:model>
...
<ber:codeListArray> <!-- A Collection of Codelists -->
<ber:codeList id="cl_105" name="Diameter" dbName="C_W_DIAMETER"
size="small">
<ber:description>Diameter</ber:description>
<ber:columnArray>

<!-- A primary key codelist column -->
<ber:column id="ca_10501" name="Identifier" dbName="C_W_DIAMETER"
nillable="false" primaryKey="true">
<ber:description>Identifier - Primary key</ber:description>
<ber:dataType>
<ber:decimal precision="5" scale="0"/>
</ber:dataType>
</ber:column>

<!-- A displayable column -->
<ber:column id="ca_10502" name="Description" dbName="DESCRIPTION"
nillable="false" display="true">
<ber:dataType>
<ber:string maxLength="80"/>
</ber:dataType>
</ber:column>

Implementation Guide

5 – CODELISTS

62

<ber:column id="ca_10503" name="Protection area radius" dbName="WIDTH">
<ber:dataType>
<ber:decimal precision="20" scale="5"/>
</ber:dataType>
<ber:orderBy direction="ascending" position="0"/>
</ber:column>
</ber:columnArray>
<ber:formArray>
<ber:form id="fmc_105_1" name="Diameter simple">
<ber:fieldGroup>
<ber:field refId="ca_10501"/>
<ber:field refId="ca_10502"/>
</ber:fieldGroup>
</ber:form>
<ber:form id="fmc_105_2" name="Diameter - edit">
<ber:fieldGroup>
<ber:field refId="ca_10501" label="Key" length="40"/>
<ber:field refId="ca_10502" length="80"/>
<ber:field refId="ca_10503" label="Radius"/>
</ber:fieldGroup>
</ber:form>
<ber:assignedForms>
<ber:assignedForm usage="default" refId="fmc_105_1"/>
</ber:assignedForms>
</ber:formArray>
</ber:codeList>
</ber:codeListArray>
...
</ber:model>

Attributes
•
•
•
•
•
•
•

id – Unique identifier of a codelist.
name – Name of a codelist.
dbName – The codelist database storage.
size – Defines whether the codelist is small or large. Small codelist is always displayed as a compact
list but large codelist is always displayed in a special form.
hierarchical – Indicates that this codelist is a hierarchical one.
readOnly – Defines whether the codelist is read-only (true) or editable (false).
unique – If true, unique constraint is generated in database for codelist column.

Inner Elements
•
•

description – Contains a detailed description of the codelist.
checkboxed – See chapter 5.9.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6
•
•


5.2

63

columnArray – Definition of columns of a codelist.
formArray – Optional description of form; form definition is necessary for some functions, e.g. for
images display in LIDS clients.

The actual codelist data (the collection of codelist items) are stored in a database. It is not defined in any
metadata file.

Defining Codelist Column
The codelist column definition is quite similar to the feature attribute definition. Each column contains
following information:
Attributes
•
•
•
•
•
•
•
•

id – Unique identifier of a codelist column. It is unique among all project meta items.
name – Name of a codelist column.
dbName – Database column name of a codelist column.
nillable – Specifies if this element must be filled (false) or if it can be left empty (true).
primaryKey – Defines whether this column is the primary key or not. Possible values are true or
false.
display – Defines whether this column is the default displayable column or not. Possible values are
true or false.
outputFormat - This type defines a number format string. It contains the colon with format specifier
and precision (:f2 or :F0).
localized - Defines whether vaues of this column can be translated into other languages. Possible
values are true or false. If true, database is automatically expanded by additional columns containing
the translated values for all languages defined according to chapter 2.5 Language Variants. The
additional columns don’t have any other definition in metadata and don’t have their own column id

Inner Elements
•
•

description - Contains a detailed description of the codelist column.
dataType – Data type of a codelist column. Same data types can be used as for feature attribute data
types. Additionally, dataType binary can be used to store file, typically an image. contentType has
to be defined in case of binary dataType

Example: Codelist using outputFormat parameter.
<ber:codeList id="cl_aaa" name="Aaa" dbName="AAA" size="small">
<ber:description>Abc abc</ber:description>
<ber:columnArray>
...
<ber:column id="ca_aaa_1" name="Some number" dbName="A1 outputFormat=":F4">
<ber:dataType>
<ber:decimal precision="20" scale="5"/>
</ber:dataType>
</ber:column>

Implementation Guide

5 – CODELISTS

64

<ber:column id="ca_aaa_2" name="Image" dbName="IMAGE">
<ber:dataType>
<ber:binary contentType="image/png"/>
</ber:dataType>
</ber:column>
</ber:columnArray>
</ber:codeList>



The data type of a codelist column can’t be a codeListRef.

5.3

Referring Codelist
There is a dedicated data type called codeListRef that is used for referring codelist. To be able to refer
codelist, the following information is supplied:
• Identifier of a referred codelist.
• Identifier of a displayable column; optional in case that the default displayable column is defined in
codelist definition.



The displayable column is used to display readable value rather than the value of a foreign key.

Example: In the following example there is a Diameter attribute that is defined by a codelist. The
ca_10502 codelist column is used as a displayable column.
<ber:attribute id="at_5012001" name="Diameter"
dbName="C_W_DIAMETER" nillable="false">
<ber:dataType> <!-- Reference to codelist -->
<ber:codeListRef refId="cl_105" displayColumn="ca_10502"/>
</ber:dataType>
</ber:attribute>

5.4

Sorting Codelist Values
There is a possibility to define ordering of codelist items. The ordering of codelist items is defined for
the whole codelist. The order is always used whenever codelist items are displayed. There is no
possibility to define different orders for a single codelist.
Example: In the following example there is a codelist records ordering defined. The ordering depends
on two codelist columns; the description and the code.
<ber:model>
...
<ber:codeListArray> <!-- A Collection of Codelists -->
<ber:codeList id="cl_105" name="Diameter" dbName="C_W_DIAMETER"

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

65

size="small">
<ber:description>Diameter</ber:description>
<ber:columnArray>

<!-- A primary key codelist column -->
<ber:column id="ca_10501" name="Identifier"
dbName="C_W_DIAMETER"
nillable="false" primaryKey="true">
<ber:description>Identifier - Primary key</ber:description>
<ber:dataType>
<ber:decimal precision="5" scale="0"/>
</ber:dataType>
</ber:column>
<!-- A description column -->
<ber:column id="ca_10502" name="Description"
dbName="DESCRIPTION"
nillable="false">
<ber:dataType>
<ber:string maxLength="80"/>
</ber:dataType>
<!-- Sort descending according the description -->
<ber:orderBy direction="descending" position="1" />
</ber:column>

<!-- A code column -->
<ber:column id="ca_10503" name="Code" dbName="CODE"
nillable="true">
<ber:dataType>
<ber:string maxLength="30"/>
</ber:dataType>
<!-- Sort ascending according the code -->
<ber:orderBy direction="ascending" position="0" />
</ber:column>
</ber:columnArray>
</ber:codeList>
</ber:codeListArray>
...
</ber:model>

The codelist items of the Diameter codelist are sorted according the Code ascending and then according
Description descending.
• orderBy – Has two mandatory attributes direction (ascending/descending) and position (determines
the priority of ordering).
Implementation Guide

66

5.5

5 – CODELISTS

Hierarchical Codelists
A hierarchical codelist is a special type of a codelist. A typical example of a hierarchical codelist is a
codelist defining organizational structure or territorial division. Each unit or area has another unit or
area assigned as its superior.
The hierarchical XML attribute of a codelist indicates that this codelist is a hierarchical one. In the
hierarchical codelist there must be a special column that holds the information about the master record.
This column must contain an XML attribute superKey set to true.
Example: Definition of hierarchical codelist type.
<ber:codeList id="cl_008"
name="Service organization unit - hierarchical"
dbName="C_G_SERVICE_OU" size="small"
hierarchical="true">
<ber:description>Service organization unit hierarchical</ber:description>
<ber:columnArray>
<ber:column id="ca_00801" name="Identifier"
dbName="C_G_SERVICE_OU"
nillable="false" primaryKey="true">
<ber:description>Identifier - Primary key</ber:description>
<ber:dataType>
<ber:decimal precision="5" scale="0"/>
</ber:dataType>
</ber:column>

<ber:column id="ca_00802" name="Unit ID" dbName="UNIT_ID"
nillable="false">
<ber:dataType>
<ber:string maxLength="40"/>
</ber:dataType>
</ber:column>

<ber:column id="ca_00803" name="Description" dbName="UNIT_NAME">
<ber:dataType>
<ber:string maxLength="80"/>
</ber:dataType>
</ber:column>

<ber:column id="ca_00804" name="Superkey"
dbName="SUP_C_G_SERVICE_OU"
superKey="true">
<ber:description>Identifier - Super key</ber:description>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

67

<ber:dataType>
<ber:decimal precision="5" scale="0"/>
</ber:dataType>
</ber:column>
</ber:columnArray>
</ber:codeList>

5.6

Security Codelists
In fact, security codelists are quite similar to a standard codelists but have a special meaning in the
project. The security codelist defines row level access rights to features.
The security codelist is defined in metadata by a securityCodelist XML element within the standard
codeListArray collection. A security codelist must have new XML attributes secRefDbName and
secRefNullValue defined. They describe the database references to the codelist.



For performance reasons the feature attributes referring security codelists are stored completely
differently than the feature attributes referring normal codelists. As the references to normal codelists
are always stored in the semantic container of a feature, the references to security codelists are stored in
the feature container. Furthermore every feature container must contain a database column for each
security codelist defined in the project, even if none of the container's feature types has the security
codelist attribute. The name of this database column is defined by the secRefDbName. As the NULL
value cannot be used as a security codelist reference value in the database, the special value
secRefNullValue is defined instead of the NULL. The value must have the type of the security codelist
primary key and must not be used as the one of the correct security codelist primary key values.

Example: Large hierarchical security codelist defined.
<ber:securityCodeList id="cl_008"
name="Service organization unit - hierarchical"
dbName="C_G_SERVICE_OU" size="large" hierarchical="true"
secRefDbName="SERVICE_ID" secRefNullValue="-1">
<ber:description>Service organization unit – hierarchical,
security</ber:description>

<ber:columnArray>
<ber:column id="ca_00801" name="Identifier"
dbName="C_G_SERVICE_OU"
nillable="false" primaryKey="true">
<ber:description>Identifier - Primary key</ber:description>
<ber:dataType>
<ber:decimal precision="5" scale="0"/>
</ber:dataType>
</ber:column>

Implementation Guide

68

5 – CODELISTS
<ber:column id="ca_00802" name="Unit ID" dbName="UNIT_ID"
nillable="false">
<ber:dataType>
<ber:string maxLength="40"/>
</ber:dataType>
</ber:column>

<ber:column id="ca_00803" name="Description" dbName="UNIT_NAME">
<ber:dataType>
<ber:string maxLength="80"/>
</ber:dataType>
</ber:column>

<ber:column id="ca_00804" name="Superkey" dbName="SUP_C_G_SERVICE_OU"
superKey="true">
<ber:description>Identifier - Super key</ber:description>
<ber:dataType>
<ber:decimal precision="5" scale="0"/>
</ber:dataType>
</ber:column>
</ber:columnArray>
</ber:securityCodeList>

How to refer a security codelist
A feature type can refer the security codelist in two possible ways. The first way is a standard way: the
security codelist can be referenced as a normal codelist. The second way how feature type can refer a
security codelist is to define a reference by security attribute.
Example: Security attribute and a reference to a codelist.
<ber:securityAttribute id="at_5005312" name="Service ID">
<ber:dataType>
<ber:codeListRef refId="cl_008" displayColumn="ca_00803" />
</ber:dataType>
</ber:securityAttribute>



The security attribute does not have the dbName. The dbName attribute is defined by a secRefDbName
attribute in a security codelist definition.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

5.7

69

Codelist Binding
Records from two or more codelists can be bounded. That means that only some combinations of records
from the codelists are allowed; they are defined in the codelist binding. A feature type can define that
its codelist attribute values are bounded by a codelist binding.
The metadata definition consists of codelist binding definition and attributes binding defition.

5.7.1

Codelist binding definition
Codelist binding is a container storing the allowed combinations of bounded codelists. One codelist
binding can define possible combination for two or more codelists.




It's not possible to define multiple references to the same codelist from one codeListBinding

Ordered codelist binding is a special kind of binding which defines order of individual refererred
codelists. This flag influences the client behaviour during editing the bounded attributes. The resulting
state – the allowed combinations are the same in case of order and not ordered definition.

Example: Definition of a codelist binding between two codelists: Material and Diameter.
<ber:codeListArray>
<!-- Diameter Codelist -->
<ber:codeList id="cl_105" name="Diameter" dbName="C_W_DIAMETER" size="small">
<ber:description>Diameter</ber:description>
<ber:columnArray>
<ber:column id="ca_10501" name="Identifier" dbName="C_W_DIAMETER"
nillable="false" primaryKey="true">
<ber:description>Identifier - Primary key</ber:description>
<ber:dataType>
<ber:decimal precision="5" scale="0"/>
</ber:dataType>
</ber:column>
<ber:column id="ca_10502" name="Description" dbName="DESCRIPTION">
<ber:dataType>
<ber:string maxLength="80"/>
</ber:dataType>
</ber:column>
</ber:columnArray>
</ber:codeList>
<!-- Material Codelist -->
<ber:codeList id="cl_102" name="Material" dbName="C_W_MATERIAL" size="small">
<ber:description>Material</ber:description>

Implementation Guide

70

5 – CODELISTS
<ber:columnArray>
<ber:column id="ca_10201" name="Identifier" dbName="C_W_MATERIAL"
nillable="false" primaryKey="true">
<ber:description>Identifier - Primary key</ber:description>
<ber:dataType>
<ber:decimal precision="5" scale="0"/>
</ber:dataType>
</ber:column>
<ber:column id="ca_10202" name="Description" dbName="DESCRIPTION">
<ber:dataType>
<ber:string maxLength="80"/>
</ber:dataType>
</ber:column>
</ber:columnArray>
</ber:codeList>
</ber:codeListArray>

<ber:codeListBindingArray>
<!-- Collection of codelist bindings -->
<ber:codeListBinding id="bc_1" dbName="STD_MATERIAL_DIAMETER"
name="Material- Diameter Binding" ordered="false">
<ber:description>Material – Diameter Codelist Binding</ber:description>
<ber:boundedItemArray>
<!-- Material codelist Reference -->
<ber:boundedItem dbName="MATERIAL_ID">
<ber:codeList refId="cl_102" />
</ber:boundedItem>
<!-- Diameter codelist Reference -->
<ber:boundedItem dbName="DIAMETER_ID">
<ber:codeList refId="cl_105" />
</ber:boundedItem>
</ber:boundedItemArray>
</ber:codeListBinding>
</ber:codeListBindingArray>

The codelist binding has two physical database columns MATERIAL_ID, DIAMETER_ID. These
columns refer the Material and Diameter codelists. The records in this table define the possible
combination of values from Material and Diameter codelists.
If there is a Material reference specified and the DIAMETER_ID column is NULL, then all records from
Diameter codelist are allowed.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6
5.7.2

71

Attribute Binding
If we want to use a codelist binding for a feature type, the feature type must refer all codelists in the
codelist biding and must have the attribute binding definition specified.
Different attributes of different feature types can be related to the same codelists. Some feature types
can define the attributes as bounded, some feature types can define the attributes linked to the same
codelists as not bounded.
Example: An attribute binding between the Material and Diameter attribute for the Pipeline feature
type.
<ber:featureTypeArray>
...
<ber:featureType
id="ft_5012000"
name="Pipeline" parentId="ft_5010000"
abstract="true">
<ber:description>Water pipeline</ber:description>

<ber:featureAttributeArray> <!-- Array of Feature Attributes -->
<ber:attribute id="at_5010004" name="Note" dbName="NOTE">
<ber:description>Notes for the record</ber:description>
<ber:dataType>

<!-- The Data Type Definition -->

<ber:string maxLength="80"/> <!-- The string value -->
</ber:dataType>
</ber:attribute>

<ber:attribute id="at_5012002" name="Length [m]"
dbName="LENGTH">
<ber:description>The length of a pipeline</ber:description>
<ber:dataType>
<ber:decimal precision="10" scale="2"/>
<!-- Decimal number -->
</ber:dataType>
</ber:attribute>

<ber:attribute id="at_5012001" name="Diameter"
dbName="C_W_DIAMETER"
nillable="false">
<ber:dataType> <!-- Reference to a code list -->
<ber:codeListRef refId="cl_105" displayColumn="ca_10502"/>
</ber:dataType>
</ber:attribute>

Implementation Guide

5 – CODELISTS

72

<ber:attribute id="at_5012003" name="Material"
dbName="C_W_MATERIAL"
nillable="false">
<ber:dataType> <!-- Reference to a code list -->
<ber:codeListRef refId="cl_102" displayColumn="ca_10202"/>
</ber:dataType>
</ber:attribute>

</ber:featureAttributeArray>

<!-- Array of the attribute binding array -->
<ber:boundedAttributesArray>
<ber:boundedAttributes>
<!-- The Diameter – Material binding -->
<ber:codeListBinding refId="bc_1"/>

<!-- The Diameter attribute -->
<ber:attribute refId="at_5012001" />

<!-- The Material attribute -->
<ber:attribute refId="at_5012003" />
</ber:boundedAttributes>
</ber:boundedAttributesArray>

</ber:featureType>
...
</ber:featureTypeArray>

5.8

Filtered Codelists
Is not defined directly, but through the reference to another object (mandatory) and through the filter
over this object (optional). The filtered codelist contains id and name. It also specifies the Ogc filter and
refers codelist to be filtered. The filtered codelist must not refer the security or another filtered codelist.
Example: Filtered codelist.
<ber:filteredCodeListArray>
<ber:filteredCodeList id="cl_505" name="Diameter - Service pipe">
<ber:description>Diameter less than 250 mm</ber:description>
<ber:codeListFilter>
<ber:codeList refId="cl_105"/>
<ogc:Filter>
<ogc:PropertyIsLessThanOrEqualTo>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

73

<ogc:PropertyName>ca_10501</ogc:PropertyName>
<ogc:Literal>200</ogc:Literal>
</ogc:PropertyIsLessThanOrEqualTo>
</ogc:Filter>
</ber:codeListFilter>
</ber:filteredCodeList>
...
</ber:filteredCodeListArray>

5.9

Checkboxed Codelists
Attributes of this codelist type are represented as checkboxes. The codelist must contain exactly two
values – refered by pkOn and pkOff parameters.
• Security codelists can be defined as checkboxed as well.
• Checkboxed codelists can be used as data types of codelists columns as well.
Example: Checkboxed codelist.
<ber:codeList id="cl_006" name="Status" dbName="C_G_STATUS" size="small">
<ber:description>Status</ber:description>
<ber:checkboxed pkOn="1" pkOff="2"/>
<ber:columnArray>
...
</ber:columnArray>
</ber:codeList>

Implementation Guide

Chapter 6
Interfaces

IMPLEMENTATION GUIDE VERSION 9.6

6.

77

Interfaces
Defines new ”view” at the data – it can bring together heterogeneous data and make them look
homogenous. Interface definition includes attributes and forms definitions.
Example: Structure of an interface array.
<ber:interfaceArray>
<ber:interface id="if_1" name="Interface 1">
<ber:description>Heterogeneous list 1</ber:description>
<ber:interfaceAttributeArray>
<ber:interfaceAttribute id="ia_1_01" name="Name" dbName="NAME">
<ber:description>String attribute</ber:description>
<ber:dataType>
<ber:string maxLength="80"/>
</ber:dataType>
</ber:interfaceAttribute>
<ber:interfaceAttribute id="ia_1_02" name="Length" dbName="LENGTH">
<ber:description>Decimal attribute</ber:description>
<ber:dataType>
<ber:decimal precision="7" scale="2"/>
</ber:dataType>
</ber:interfaceAttribute>
<ber:interfaceAttribute id="ia_1_03" name="Type" dbName="TYPE">
<ber:description>Codelist attribute</ber:description>
<ber:dataType>
<ber:codeListRef refId="cl_1" displayColumn="ca_1_01"/>
</ber:dataType>
</ber:interfaceAttribute>
<ber:interfaceAttribute id="ia_1_04" name="Master ID" dbName="MASTER_ID">
<ber:description>FeatureRef attribute</ber:description>
<ber:dataType>
<ber:featureRef>
<ber:attribute refId="at_r_002"/>
<ber:featureRefRelationAssoc refId="r_a_b"/>
</ber:featureRef>
</ber:dataType>
</ber:interfaceAttribute>
</ber:interfaceAttributeArray>
<ber:formArray>
<ber:form id="frm_if_101" name="Interface 1">
<ber:description> Heterogeneous list 1</ber:description>
<ber:fieldGroup>

Implementation Guide

6 – INTERFACES

78

<ber:field refId="ia_1_01"/>
<ber:field refId="ia_1_02"/>
<ber:field refId="ia_1_03"/>
<ber:field refId="ia_1_04"/>
</ber:fieldGroup>
</ber:form>
</ber:formArray>
</ber:interface>
</ber:interfaceArray>

Attributes
•
•

id – Unique identifier of an interface.
name – Name of an interface.

Inner elements
•
•
•

6.1

description – Detailed description of an interface; optional definition.
interfaceAttributeArray – Definition of an interface attributes.
formArray – Definition of forms used to present interface content.

Defining Interface Attributes
•
•
•
•

id – Unique identifier of an interface attribute.
name – Name of interface attribute.
dbName – Database column name of an interface attribute.
outputFormat – This type defines a number format string. It contains the colon with format specifier
and precision (:f2 or :F0).

Inner elements
•
•

6.2

description – Detailed description of an interface attribute.
dataType – Data type of an interface attribute or reference
(<ber:featureRefRelationAssoc) and its attribute (<ber:attribute).

to

an

association

Implementing Interface
The interface and it’s attributes are used = implemented by individual feature types and their attributes.
One feature type can implement more interfaces and one interface can be implemented by more feature
types.
Interface implementation by particular feature type is defined in interfaceDefArray in feature type
definition.
interfaceDef definition includes:
• refId – Interface definition reference.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6
•

79

interfaceAttributeDef
• refId – Interface attribute reference
• attribute refId – feature type attribute when thefeature type implements the interface attribute
by standard attribute or
• defaultValue – when the feature type implements the interface attribute by constant value.
Empty value as a special type of defaultValue is also valid definition

Example: Structure of an interfaceDefArray.
<ber:interfaceDefArray>
<ber:interfaceDef refId="if_1">
<ber:interfaceAttributeDef refId="ia_1_01">
<ber:attribute refId="at_001"/>
</ber:interfaceAttributeDef>
<ber:interfaceAttributeDef refId="ia_1_02">
<ber:defaultValue>100.05</ber:defaultValue>
</ber:interfaceAttributeDef>
<ber:interfaceAttributeDef refId="ia_1_03">
<ber:attribute refId="at_002"/>
</ber:interfaceAttributeDef>
<ber:interfaceAttributeDef refId="ia_1_04">
<ber:defaultValue/>
</ber:interfaceAttributeDef>
</ber:interfaceDef>
</ber:interfaceDefArray>



A feature type implementing an interface has to define the mapping for all interface attributes.

6.3

Interface limitations
•
•
•
•
•

Interface must define at least one form to be accessible in LIDS Edit / Explorer browse
It’s not possible to use system attributes in interfaces
It’s not possible to combine different data types in one interface attribute
The same feature attribute can't be mapped to more interface attributes of the same interface
LIDS Browser doesn’t support Interfaces.

Implementation Guide

80

6 – INTERFACES

Implementation Guide

Chapter 7
Forms

IMPLEMENTATION GUIDE VERSION 9.6

7.

83

Forms
Every feature type can have multiple display forms defined. Different forms can be used for different
actions with feature: displaying, inserting, capturing graphics, capturing semantics,...
All forms for a feature type are defined within the featureType metadata definition. Forms are defined
inside the formArray collection.
Example: Definition of a form inside the feature type.
<ber:featureTypeArray>
...
<ber:featureType id="ft_pipe" name="Pipeline" parentId="ft_parent">
...
<ber:featureAttributeArray> <!-- Array of Feature Attributes -->
<ber:attribute id="at_pipe_1" name="Diameter" dbName="C_W_DIAMETER"
nillable="false">
<ber:dataType> <!-- Reference to a code list -->
<ber:codeListRef refId="cl_105" displayColumn="ca_10502"/>
</ber:dataType>
</ber:attribute>
<ber:attribute id="at_pipe_2" name="Length [m]" dbName="LENGTH">
<ber:description>The length of a pipeline</ber:description>
<ber:dataType> <!-- Decimal number -->
<ber:decimal precision="10" scale="2"/>
</ber:dataType>
</ber:attribute>
<ber:attribute id="at_pipe_3" name="Material" dbName="C_W_MATERIAL"
nillable="false">
<ber:dataType> <!-- Reference to a code list -->
<ber:codeListRef refId="cl_102" displayColumn="ca_10202"/>
</ber:dataType>
</ber:attribute>
<ber:attribute id="at_pipe_4" name="Note" dbName="NOTE" nillable="true">
<ber:description>Notes for the record</ber:description>
<ber:dataType>

<!-- String value -->

<ber:string maxLength="80"/>
</ber:dataType>
</ber:attribute>
<ber:featureRefAttribute id="at_pipe_5" name="Master feature" dbName="FREF">
<ber:dataType>
<ber:featureRef>
<ber:attribute refId="at_master_1"/>
<ber:attribute refId="at_master_2" default="true"/>

Implementation Guide

7 – FORMS

84

<ber:attribute refId="at_master_3"/>
<ber:featureRefRelationAssoc refId="r_1"/>
</ber:featureRef>
</ber:dataType>
</ber:featureRefAttribute>
</ber:featureAttributeArray>
...
<ber:formArray> <!-- Array of Forms -->
<ber:form id="fm_pipe_1" name="Pipeline – complex">
<ber:fieldGroup>
<ber:field id="f_1" refId="at_pipe_4" readOnly="false"
label="Description" length="80"/>
<ber:field refId="at_pipe_2" readOnly="false" length="80"/>
</ber:fieldGroup>
<ber:fieldGroup>
<ber:separator/>
<ber:field refId="at_pipe_1" readOnly="false"
label="Pipe diameter" length="80"/>
<ber:field refId="at_pipe_3" readOnly="true" length="80"/>
</ber:fieldGroup>
<ber:fieldGroup>
<ber:caption id="c_1" label="FeatureRef attributes"
collapsible="expanded"/>
<ber:field refId="at_pipe_5"/>
<ber:field attributePath="at_pipe_5/at_master_1" label="Master name"
length="90"/>
<ber:field attributePath="at_pipe_5/at_master_3" label="Master type"/>
<ber:field attributePath="at_pipe_5/at_master_3/ca_5"
label="Master type 2"/>
</ber:fieldGroup>
<ber:fieldGroup>
<ber:caption id="c_1" label="System attributes"
collapsible="collapsed"/>
<ber:field id="f_11" refId="createdBy" label="Created by" length="90"/>
<ber:field refId="createDate" label="Create date" length="90"/>
<ber:field refId="updatedBy" label="Updated by" length="90"/>
<ber:field refId="updateDate" label="Update date" length="90"/>
<ber:field id="f_8" refId="id" length="40"/>
<ber:field refId="sid" length="40"/>
<ber:field refId="ftid" length="80"/>
<ber:field refId="longTransactionId" length="40"/>
</ber:fieldGroup>
</ber:form>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

85

<ber:form id="fm_pipe_2" name="Pipeline – reduced, read-only">
<ber:fieldGroup>
<ber:field refId="at_pipe_1" readOnly="true" length="45"/>
<ber:field refId="at_pipe_3" readOnly="true" length="120"/>
</ber:fieldGroup>
</ber:form>
<ber:assignedForms>
<ber:assignedForm usage="default" refId="fm_pipe_1"/>
<ber:assignedForm usage="insertSemantics" refId="fm_pipe_1"/>
<ber:assignedForm usage="insertGraphics" refId="fm_pipe_1"/>
<ber:assignedForm usage="updateSemantics" refId="fm_pipe_1"/>
<ber:assignedForm usage="wms" refId="fm_pipe_2"/>
<ber:assignedForm usage="locate" refId="fm_pipe_2"/>
</ber:assignedForms>
</ber:formArray>
</ber:featureType>
...
</ber:featureTypeArray>




Form element is optional. It is allowed to use just <assignedForms> element without needing to define
<form> element.

In case of shared semantics, forms should be defined on the level of semantic parent feature type only.
Forms should not be defined for shared semantics graphic feature types.
Form consists of fields with these properties:
• id – Optional field identifier. Currently used just for translating in case of multi-language project
• refId or attributePath – Mandatory reference to the feature attribute displayed in this form field
• refId can be used just to simple referring feature type attribute
• attributePath can be used for featureRef attribute to refer particular master feature attribute,
optionally including a codelist column
• label – Form field label. Optional for refId, mandatory for attributePath. In case the label is not
specified, it is taken from feature attribute name.
• length – Form field length.
• readOnly – Defines whether the form field is read-only (true) or editable (false).
Form fields are organized into fieldGroups. A fieldGroup can start either with <separator> or
<caption> element.
• separator - represents just simple horizontal line without additionl attributes
• caption – is more complex element with optional attributes:
o id – currently used just for translating in case of multi-language project
o label – text value displayed in the field group header
o collapsible – allowed values are: expanded|collapsed|false. Default is false.

Implementation Guide

86

7 – FORMS

Feature type can define any number of forms. Forms can be assigned to the specific actions using
assignedForms section (list can be extended according to the application needs):
• default – This form is used by default, i.e. in case when form for specific action is not defined.
• insertSemantics – This form is used when inserting semantics for a feature.
• insertGraphics – This form is used when inserting graphics for a feature.
• updateSemantics – This form is used when inserting semantics for a feature.
• updateGraphics – This form is used when updating graphics for a feature.
• locate – This form is used when locating feature in graphic view.
• plotReport – This form is used when outputting a feature to plot report.
• wms – This form is used whenever accessing data through WMS, e.g. in LIDS Browser.
• mobileSimple – This form is used for displaying list of features in LIDS Mobile.
• mobileFull – This form is used for displaying of the single feature in LIDS Mobile.

Implementation Guide

Chapter 8
Feature Graphics

IMPLEMENTATION GUIDE VERSION 9.6

8.

89

Feature Graphics
LIDS feature graphics consists of master graphics and optional graphic tags. While master graphics is
the main graphical representation of a feature, the graphic tags represent auxiliary graphical information,
e.g. displayable attributes or cross-sections.
The definition of any graphics consists of geometry definition and symbology definition.

8.1

Master Graphics
As master graphics is the main graphical representation of a feature, each graphic feature type must
specify its master graphics. It can be either primitive or collection graphics.
The master graphics can be set as mandatory (nillable=false) or optional (nillable=true). It means
mandatory or optional at feature instance level. If master graphics is set as mandatory (nillable=false),
every feature of this feature type must have its master graphics created.
Primitive Master Graphics
The most of features have primitive master graphics, i.e. graphics with primitive geometry type. There
are four primitive geometry types in LIDS, point, curve, surface, text.
Example: Defining primitive master graphics for Main Pipeline segment.
<ber:model>
<ber:featureTypeArray>
...
<ber:featureType id="ft_5012100" name="Main pipeline segment"
parentId="ft_5012000">
<ber:description>Segments of the main water network</ber:description>

<ber:masterGraphics nillable="true">
<ber:curveGraphicType>
<ber:symbology>
...
</ber:symbology>
</ber:curveGraphicType>
</ber:masterGraphics>

<ber:featureAttributeArray>
...
</ber:featureAttributeArray>
</ber:featureType>
</ber:featureTypeArray>
</ber:model>

Implementation Guide

8 – FEATURE GRAPHICS

90

Collection Master Graphics
Some special features have collection master graphics, i.e. their master graphics is a collection of
primitive graphic components. Dimensions, dense area zooms and dense area references are the special
features with collection master graphics.
Graphic collections represent general framework for extending LIDS system graphic functionality.
Standard LIDS system core provides basic collections handling – defining in metadata, storing to DB,
providing to clients, rendering and dynamic resymbolizing. But the system core is not able to do any
active manipulations with graphic collections. It is a job for system extensions. Every collection graphic
type belongs to one graphic type class. The graphic type class identifies the system extension that is
responsible for active handling with features of this graphic type.
Example: Defining collection master graphics – Dimension.
<ber:model>
...
<ber:system id="0">
...
<ber:graphicTypeClassArray>
<ber:graphicTypeClass id="Dimension" name="Standard dimensions">
<ber:description>Features with graphics of this type are used for
standard dimensioning</ber:description>
</ber:graphicTypeClass>
</ber:graphicTypeClassArray>
</ber:system>
...
<ber:featureTypeArray>
...
<ber:featureType id="ft_5031000" name="Dimension"
parentId="ft_5030000">
<ber:description>MicroStation dimension</ber:description>
<ber:masterGraphics nillable="false">
<ber:class refId="Dimension"/>
<ber:collectionGraphicType>
<ber:graphicTypeComponentArray>
<ber:graphicTypeComponent id="gtc_01" name="Dimension Line"
roleId="dimLine">
<ber:curveGraphicType>
<ber:symbology>
...
</ber:symbology>
</ber:curveGraphicType>
</ber:graphicTypeComponent>
<ber:graphicTypeComponent id="gtc_02" name="Extension Line"
roleId="extLine">

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

91

<ber:curveGraphicType>
<ber:symbology>
...
</ber:symbology>
</ber:curveGraphicType>
</ber:graphicTypeComponent>
<ber:graphicTypeComponent id="gtc_03" name="Dimension Text"
roleId="text">
<ber:textGraphicType>
<ber:symbology>
...
</ber:symbology>
</ber:textGraphicType>
</ber:graphicTypeComponent>
<ber:graphicTypeComponent id="gtc_04" name="Symbol – arrow"
roleId="symbArrow">
<ber:pointGraphicType>
<ber:symbology>
...
</ber:symbology>
</ber:pointGraphicType>
</ber:graphicTypeComponent>
</ber:graphicTypeComponentArray>
</ber:collectionGraphicType>
</ber:masterGraphics>
</ber:featureType>
</ber:featureTypeArray>
</ber:model>

•
•

8.2

graphicTypeClassArray – Defines graphic type classes recognized by currently installed system
extensions.
collectionGraphicType – Defines collection graphic type. It says that the collection graphics can
consist of the defined components types.

Graphic Tags
Graphic tags are auxiliary graphic objects with following characteristics:
• They are attached to graphic features.
• They do not represent real world object.
• Multiple graphic tags of the same type can be attached to one feature.
Displayable attributes are examples of graphic tags. Graphic tag types are collection graphic types. They
are defined in special part of metadata and referred from feature type definitions.

Implementation Guide

8 – FEATURE GRAPHICS

92

Example: Defining graphic tags – Displayable Attribute.
<ber:model>
...
<ber:system id="0">
...
<ber:graphicTypeClassArray>
<ber:graphicTypeClass id="DA" name="Displayable attributes">
<ber:description>This graphic type is used for displayable
attributes</ber:description>
</ber:graphicTypeClass>
</ber:graphicTypeClassArray>
</ber:system>
...
<ber:graphicTypeArray>
<ber:graphicType id="gtda_5012102" name="W_DA_5012102">
<ber:class refId="DA"/>
<ber:collectionGraphicType>
<ber:symbology>
...
</ber:symbology>
<ber:graphicTypeComponentArray>
<ber:graphicTypeComponent id="gtda_5012102_2" name="Label Line"
roleId="labelLine">
<ber:curveGraphicType>
...
</ber:curveGraphicType>
</ber:graphicTypeComponent>
<ber:graphicTypeComponent id="gtda_5012102_1" name="DA Text"
roleId="text">
<ber:textGraphicType>
<ber:symbology>
...
</ber:symbology>
</ber:textGraphicType>
</ber:graphicTypeComponent>
</ber:graphicTypeComponentArray>
</ber:collectionGraphicType>
</ber:graphicType>
</ber:graphicTypeArray>
...
<ber:featureTypeArray>
...

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

93

<ber:featureType id="ft_5012100" name="Main pipeline segment"
parentId="ft_5012000" abstract="false">
<ber:description>Segments of the main water network</ber:description>
<ber:masterGraphics nillable="true">
<ber:curveGraphicType>
<ber:symbology>
...
</ber:symbology>
</ber:curveGraphicType>
</ber:masterGraphics>
<ber:graphicTagTypeArray>
<ber:graphicTagType id="ft_5012100_gtda_5012102"
name="DA - Description">
<ber:graphics refId="gtda_5012102"/>
</ber:graphicTagType>
</ber:graphicTagTypeArray>
</ber:featureType>
</ber:featureTypeArray>
</ber:model>

•

•

8.2.1

graphicTypeArray – Defines graphic tag types. In this case one graphic tag type is defined. It is a
collection graphic type (must be) of DA class. It can have components of two types – DA text and
label line.
graphicTagTypeArray – Refers to formerly defined graphic tag types. Defines set of graphic tag
types which can be attached to feature type.

Border line
A line feature can be displayed using its axis and two borders (closed or open). The line axis is
constructed by the user; borders are automatically generated according to rules defined in metadata. The
borders copy the shape of the axis, the distance of borders from the axis can be controlled by value of
selected attribute, typically by specified diameter of the line. The change of the value of some control
attribute, or of axis geometry automatically implies a corresponding change of borders. If more lines
intersect, the system provides modification of their borders at the intersection so that the borders are
connected.
Possible variants of the definition:
• Only axis – no borders, no closing lines.
• Axis with borders (one or two lines placed in a defined distance parallelly to the axis).
• Axis with closing lines (two lines with a length equal to the defined borders distance, placed at the
end of the axis perpendiculary to it).
• Axis with both borders and closing lines.

Implementation Guide

8 – FEATURE GRAPHICS

94

Either a graphic type containing borders and / or closing lines components must be defined for the line
feature type as its graphic tag or separate feature type with relation association to the axis can be defined
(in model.xml). Further, the following must be specified in the option.xml file:
• What feature type will be used in the role of the axis
• How the generated borders are stored in the system
• Graphic tag type and its components used in the role of the borders and / or closing lines
• Feature type and relationAssoc type. Optionally, default values can be specified
• Rule for counting the borders distance
Optionally, following conditions can be defined:
• excludeFeatures – Condition for excluding features from the processing can be defined. If valid,
the borders are not generated for such a feature. If borders already existed for such a feature, they
are left untouched. Also modification of the source geometry doesn’t cause any update on the
generated borders
• deleteBorderForFeatures – Condition for deleting the existing border. If valid, the border is not
generated for such a feature and the existing border is deleted
There are following possibilities how to define the borders distance:
• Directly a value of a feature attribute – this attribute must be of a number type. The user fills in
directly the distance in meters
• Codelist’s column – the user fills in the value by selecting a codelist entry. The distance is taken
from a codelist column, which doesn’t need to be visible for the user.
• A constant – the user can’t influence the distance
Possible definition of the border’s shape:
• joinStyle – Style of the outer boundary at the internal vertices of the source geometry. Possible
values:
• mitre - Sharp line, represented by one vertex at each source vertex
• round – Rounded line, represented by more vertexes at each source vertex
• quadrantSegmentsCount – Smoothness of the outer boundary. Makes sense only in the
combination with joinStyle=”rounded”. The resulting border never contains arcs, so this parameter
defines, how many points in each quadrant are generated.
• side – defines, if just one line is generated either on the right or left side of the axis.

Example: Defining graphic tags – Border line.
<ber:model>
...
<ber:system id="0">
...
<ber:graphicTypeClassArray>
<ber:graphicTypeClass id="BorderLine" name="Border line">
<ber:description>By server generated border lines, graphic
tag</ber:description>
</ber:graphicTypeClass>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

95

</ber:graphicTypeClassArray>
</ber:system>
...
<ber:graphicType id="gtda_5060002" name="Border line">
<ber:class refId="BorderLine"/>
<ber:collectionGraphicType>
<ber:graphicTypeComponentArray>
<ber:graphicTypeComponent id="gtda_5060002_1" name="Border line"
roleId="borderLine">
<ber:curveGraphicType>
<ber:symbology>
<ber:lineSymbolizer>
<se:Stroke>
<se:GraphicStroke>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ls_5"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
</se:GraphicStroke>
<se:SvgParameter name="stroke-width">2</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
</ber:symbology>
</ber:curveGraphicType>
</ber:graphicTypeComponent>
<ber:graphicTypeComponent id="gtda_5060002_2" name="Closing line"
roleId="closingLine">
<ber:curveGraphicType>
<ber:symbology>
<ber:lineSymbolizer>
<se:Stroke>
<se:SvgParameter name="stroke-width">1</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
</ber:symbology>
</ber:curveGraphicType>
</ber:graphicTypeComponent>
</ber:graphicTypeComponentArray>
</ber:collectionGraphicType>
</ber:graphicType>

Implementation Guide

96

8 – FEATURE GRAPHICS
option.xml:
<ber:lineBorder id="bod_3" name="Route">
<ber:inputAxis>
<ber:featureType xlink:href="model.xml#ft_e_route"/>
<ber:excludeFeatures>
<ogc:Filter> <!-- Material = 'Gold' -->
<ogc:PropertyIsEqualTo>
<ogc:PropertyName>ft_5012300/at_5012003</ogc:PropertyName>
<ogc:Literal>10</ogc:Literal>
</ogc:PropertyIsEqualTo>
</ogc:Filter>
</ber:excludeFeatures>
</ber:inputAxis>
<ber:outputLineBorder>
<ber:diameter>
<ogc:PropertyName>at_e5121006/ca_31903</ogc:PropertyName>
</ber:diameter>
<ber:graphicTagType xlink:href="model.xml#ft_e_route_gtda_5060002"/>
<ber:borderLine quadrantSegmentsCount="8">
<ber:graphicTypeComponent xlink:href="model.xml#gtda_5060002_1"/>
</ber:borderLine>
<ber:closingLine>
<ber:graphicTypeComponent xlink:href="model.xml#gtda_5060002_2"/>
</ber:closingLine>
</ber:outputLineBorder>
</ber:lineBorder>
<ber:lineBorder id="line_border_2" name="Just on right side">
<ber:inputAxis>
<ber:featureType xlink:href="model.xml#ft_axis"/>
<ber:deleteBorderForFeatures>
<ogc:Filter>
<ogc:Or>
<ogc:PropertyIsEqualTo>
<ogc:PropertyName>at_count</ogc:PropertyName>
<ogc:Literal>0</ogc:Literal>
</ogc:PropertyIsEqualTo>
<ogc:PropertyIsNull>
<ogc:PropertyName>at_count</ogc:PropertyName>
</ogc:PropertyIsNull>
</ogc:Or>
</ogc:Filter>
</ber:deleteBorderForFeatures>
</ber:inputAxis>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

97

<ber:outputLineBorder>
<ber:diameter side="right">
<ogc:PropertyName>at_123/ca_456</ogc:PropertyName>
</ber:diameter>
<ber:featureType xlink:href="model.xml#ft_border"/>
<ber:relationAssoc xlink:href="model.xml#as_axis_border"/>
<ber:defaultAttValueArray>
<ber:defaultAttValue>
<ber:attribute xlink:href="model.xml#at_border_kind"/>
<ber:value>1</ber:value>
</ber:defaultAttValue>
</ber:defaultAttValueArray>
<ber:borderLine quadrantSegmentsCount="3"/>
</ber:outputLineBorder>
</ber:lineBorder>

8.2.2

Border polygon
There is a possibility to generate the buffer zone for a source feature. The source feature geometry can
be line, polygon or point. It is constructed by the user; the buffer zone is generated by the system on the
basis of a rule defined in metadata. The width of the area can be controlled by values of selected attribute.
The change of the value of some control attribute, or of the source geometry implies a corresponding
change of the buffer zone – automatically or on request.
Possible definitions of the resulting buffer zone:
• graphicTagType – the resulting buffer zone is graphic tag of the source feature.
• feature type sharing semantics with the source feature
• feature type related by relationAssoc with the source feature
Optionally, following conditions can be defined:
• excludeFeatures – Condition for excluding features from the processing can be defined. If valid,
the buffer zone is not generated for such a feature. If buffer zone already existed for such a feature,
it’s left untouched. Also modification of the source geometry doesn’t cause any update on the
generated border
• deleteBorderForFeatures – Condition for deleting the existing border. If valid, the buffer zone is
not generated for such a feature and the existing border is deleted
There are following possibilities how to define the buffer zone’s width:
• Directly a value of a feature attribute – this attribute must be of a number type. The user fills in
directly the width in meters
• Codelist’s column – the user fills in the value by selecting a codelist entry. The width is taken from
a codelist column, which doesn’t need to be visible for the user.
• A constant – the user can’t influence the width

Implementation Guide

8 – FEATURE GRAPHICS

98

Possible definition of the buffer zone’s shape:
• joinStyle – Style of the outer boundary at the internal vertices of the source geometry. Possible
values:
• mitre - Sharp line, represented by one vertex at each source vertex
• round – Rounded line, represented by more vertexes at each source vertex
• quadrantSegmentsCount – Smoothness of the outer boundary. Makes sense only in the
combination with joinStyle=”rounded”. The resulting border never contains arcs, so this parameter
defines, how many points in each quadrant are generated.
• endCapStyle – Style at the end of the master geometry. Makes sense only if the master geometry is
a line. Possible values:
• flat – Simple perpendicular line created at the end of the source line
• square – Simple perpendicular line created in the distance of buffer zone’s width from the
source line
• round – Line with more internal vertexes created in the distance of buffer zone’s width from
the source line
• side – Defines, if the buffer zone is generated on both sides of the source line. Possible values:
• both – The buffer zone is generated on both sides of the source line. Default behavior.
• left – The buffer zone is generated just on the left side of the source line. In this case the direction
of the source line is considered.
• right – The buffer zone is generated just on the right side of the source line. In this case the
direction of the source line is considered.
Example: Defining graphic tags – Border Polygon.
<ber:model>
...
<ber:system id="0">
...
<ber:graphicTypeClassArray>
<ber:graphicTagType id="ft_5012100_gtbp_0001" name="Generated border polygon"
drawPriority="10">
<ber:graphics refId="gtbp_0001"/>
</ber:graphicTagType>
</ber:graphicTypeClassArray>
</ber:system>

option.xml:
<ber:areaBorderArray>
<ber:areaBorder id="bod_4" name="Main pipeline segment - generated border
polygon">
<!-- input data -->
<ber:inputAxis>
<ber:featureType xlink:href="model.xml#ft_5012100"/>
<ber:excludeFeatures>
<ogc:Filter> <!-- Material in 'Unknown', 'Wood' -->

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

99

<ber:PropertyIsIn>
<ogc:PropertyName>ft_5012300/at_5012003</ogc:PropertyName>
<ogc:Literal>-1</ogc:Literal>
<ogc:Literal>3</ogc:Literal>
</ber:PropertyIsIn>
</ogc:Filter>
</ber:excludeFeatures>
<ber:deleteBorderForFeatures>
<ogc:Filter> <!-- Supplying zone = 'Low pressure' -->
<ogc:PropertyIsEqualTo>
<ogc:PropertyName>ft_5012100/at_5010001</ogc:PropertyName>
<ogc:Literal>1</ogc:Literal>
</ogc:PropertyIsEqualTo>
</ogc:Filter>
</ber:deleteBorderForFeatures>
</ber:inputAxis>
<!-- output data -->
<ber:outputAreaBorder overlayEnabled="true">
<ber:graphicTagType xlink:href="model.xml#ft_5012100_gtbp_0001"/>
<ber:bufferZone quadrantSegmentsCount="5" joinStyle="round"
endCapStyle="round" side="right">
<ber:width>
<ogc:PropertyName>at_5012000_diameter/ca_10503</ogc:PropertyName>
</ber:width>
</ber:bufferZone>
</ber:outputAreaBorder>
</ber:areaBorder>
</ber:areaBorderArray>

model.xml:
<ber:graphicTypeArray>
<ber:graphicType id="gtbp_0001" name="Border polygon">
<ber:class refId="BorderPolygon"/>
<ber:collectionGraphicType>
<ber:graphicTypeComponentArray>
<ber:graphicTypeComponent id="gtbp_0001_1" name="Border polygon"
roleId="borderPolygon">
<ber:surfaceGraphicType>
<ber:symbology>
<ber:polygonSymbolizer>
<ber:fill>
<se:SvgParameter name="fill">#97F740</se:SvgParameter>
<se:SvgParameter name="fill-opacity">0.3</se:SvgParameter>

Implementation Guide

8 – FEATURE GRAPHICS

100

<ber:fillStyle>solid</ber:fillStyle>
</ber:fill>
<se:Stroke>
<se:SvgParameter name="stroke">#7F0000</se:SvgParameter>
<se:SvgParameter name="stroke-width">2</se:SvgParameter>
</se:Stroke>
</ber:polygonSymbolizer>
</ber:symbology>
</ber:surfaceGraphicType>
</ber:graphicTypeComponent>
</ber:graphicTypeComponentArray>
</ber:collectionGraphicType>
</ber:graphicType>
</ber:graphicTypeArray>
...
<ber:featureTypeArray>
...
<ber:featureType id="ft_5012100" name="Main pipeline segment"
parentId="ft_5012000" abstract="false">
<ber:description>Segments of the main water network</ber:description>
<ber:masterGraphics nillable="true">
<ber:curveGraphicType>
<ber:symbology>
...
</ber:symbology>
</ber:curveGraphicType>
</ber:masterGraphics>
<ber:graphicTagTypeArray>
<ber:graphicTagType id="ft_5012100_gtbp_0001" name="Generated border
polygon" drawPriority="10">
<ber:graphics refId="gtbp_0001"/>
</ber:graphicTagType>
</ber:graphicTagTypeArray>
</ber:featureType>
</ber:featureTypeArray>
</ber:model>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6
8.2.3

101

Other classes
Example: Defining graphic tags – Simple Dimension. In this case, the dimension line is the master
geometry which is created by standard functions. Symbols at both ends and the text are graphic tags.
<ber:model>
...
<ber:system id="0">
...
<ber:graphicTypeClassArray>
<ber:graphicTypeClass id="SimpleDimension" name="Simple dimension">
<ber:description>Dimensions for LIDS Browser, graphic tag</ber:description>
</ber:graphicTypeClass>
</ber:graphicTypeClassArray>
</ber:system>
...
<ber:graphicType id="simpdim_01" name="Simple dimension 1">
<ber:class refId="SimpleDimension"/>
<ber:collectionGraphicType>
<ber:symbology>
<ber:derivedSymbolizer/>
</ber:symbology>
<ber:graphicTypeComponentArray>
<ber:graphicTypeComponent id="simpdim_01_symstart" name="Symbol at start"
roleId="symbStart">
<ber:pointGraphicType>
<ber:symbology>
<ber:pointSymbolizer>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource
xlink:href="resource.xml#ber_LIDSdemo/76/left-center"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
<ber:rgbColor>#FF0000</ber:rgbColor>
<ber:symbolHeight>1</ber:symbolHeight>
</ber:pointSymbolizer>
</ber:symbology>
</ber:pointGraphicType>
</ber:graphicTypeComponent>
<ber:graphicTypeComponent id="simpdim_01_symend" name="Symbol at end"
roleId="symbEnd">
<ber:pointGraphicType>
<ber:symbology>

Implementation Guide

8 – FEATURE GRAPHICS

102

<ber:pointSymbolizer>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource
xlink:href="resource.xml#ber_LIDSdemo/76/left-center"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
<ber:rgbColor>#FF0000</ber:rgbColor>
<ber:symbolHeight>1</ber:symbolHeight>
</ber:pointSymbolizer>
</ber:symbology>
</ber:pointGraphicType>
</ber:graphicTypeComponent>
<ber:graphicTypeComponent id="simpdim_01_text" name="Dimension text"
roleId="dimText">
<ber:textGraphicType>
<ber:symbology>
<ber:textSymbolizer>
<se:Font>
<se:SvgParameter name="font-family">Courier</se:SvgParameter>
<se:SvgParameter name="font-style">italic</se:SvgParameter>
</se:Font>
<se:Fill>
<se:SvgParameter name="fill">#FF0000</se:SvgParameter>
</se:Fill>
</ber:textSymbolizer>
</ber:symbology>
<ber:defaultTextProperties>
<ber:anchorPoint>center-bottom</ber:anchorPoint>
</ber:defaultTextProperties>
</ber:textGraphicType>
</ber:graphicTypeComponent>
</ber:graphicTypeComponentArray>
</ber:collectionGraphicType>
</ber:graphicType>

Example: Defining graphic tags – Placed cross-section.
<ber:model>
...
<ber:system id="0">
...

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

103

<ber:graphicTypeClassArray>
<ber:graphicTypeClass id="PlacedCS" name="Placed cross-section">
<ber:description>Placed cross-section, graphic tag</ber:description>
</ber:graphicTypeClass>
</ber:graphicTypeClassArray>
</ber:system>
...
<ber:graphicType id="gtcs_0001" name="Cross-section 3">
<ber:class refId="PlacedCS"/>
<ber:collectionGraphicType>
<ber:symbology>
<ber:commonSymbolizer>
<ber:rgbColor>#FF0000</ber:rgbColor>
</ber:commonSymbolizer>
</ber:symbology>
<ber:graphicTypeComponentArray>
<ber:delegateGraphicTypeComponent id="gtcs_0001_01" name="Duct"
roleId="duct">
<ber:pointGraphicType>
<ber:symbology>
<ber:pointSymbolizer>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource
xlink:href="resource.xml#ber_LIDSdemo/64"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
</ber:pointSymbolizer>
</ber:symbology>
</ber:pointGraphicType>
<ber:featureTypeDelegate refId="ft_e_protpipe"/>
</ber:delegateGraphicTypeComponent>
<ber:graphicTypeComponent id="gtcs_0001_02" name="CS Text"
roleId="auxiliaryGraphics">
<ber:textGraphicType>
<ber:symbology>
<ber:textSymbolizer>
<ber:fontHeight>1</ber:fontHeight>
</ber:textSymbolizer>
</ber:symbology>
</ber:textGraphicType>
</ber:graphicTypeComponent>
<ber:graphicTypeComponent id="gtcs_0001_03" name="CS Border"
roleId="auxiliaryGraphics">

Implementation Guide

104

8 – FEATURE GRAPHICS
<ber:curveGraphicType/>
</ber:graphicTypeComponent>

<ber:graphicTypeComponent id="gtcs_0001_04" name="Direction symbol left"
roleId="leftDirection">
<ber:pointGraphicType>
<ber:symbology>
<ber:pointSymbolizer>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource
xlink:href="resource.xml#ber_LIDSdemo/53/right-center"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
</ber:pointSymbolizer>
</ber:symbology>
</ber:pointGraphicType>
</ber:graphicTypeComponent>
<ber:graphicTypeComponent id="gtcs_0001_05" name="Direction symbol right"
roleId="rightDirection">
<ber:pointGraphicType>
<ber:symbology>
<ber:pointSymbolizer>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource
xlink:href="resource.xml#ber_LIDSdemo/52/left-center"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
</ber:pointSymbolizer>
</ber:symbology>
</ber:pointGraphicType>
</ber:graphicTypeComponent>
<ber:graphicTypeComponent id="gtcs_0001_06" name="Label line"
roleId="labelLine">
<ber:curveGraphicType>
<ber:symbology>
<ber:lineSymbolizer>
<se:Stroke>
<se:SvgParameter name="stroke-width">1</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
</ber:symbology>
</ber:curveGraphicType>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

105

</ber:graphicTypeComponent>
</ber:graphicTypeComponentArray>
</ber:collectionGraphicType>
</ber:graphicType>

Example: Defining graphic tags – Cross-section reference.
<ber:model>
...
<ber:system id="0">
...
<ber:graphicTypeClassArray>
<ber:graphicTypeClass id="CSReference" name="Cross-section reference">
<ber:description>Cross-section reference for plot outputs, graphic
tag</ber:description>
</ber:graphicTypeClass>
</ber:graphicTypeClassArray>
</ber:system>
...
<ber:graphicType id="gtcsr_01" name="Cross-section reference">
<ber:class refId="CSReference"/>
<ber:collectionGraphicType>
<ber:symbology>
<ber:commonSymbolizer>
<ber:rgbColor>#B9BC12</ber:rgbColor>
</ber:commonSymbolizer>
</ber:symbology>
<ber:graphicTypeComponentArray>
<ber:graphicTypeComponent id="gtcsr_01_1" name="Label line"
roleId="labelLine">
<ber:curveGraphicType>
<ber:symbology>
<ber:lineSymbolizer>
<se:Stroke>
<se:SvgParameter name="stroke-width">1</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
</ber:symbology>
</ber:curveGraphicType>
</ber:graphicTypeComponent>
<ber:graphicTypeComponent id="gtcsr_01_2" name="Label symbol"
roleId="labelSymbol">
<ber:pointGraphicType>
<ber:symbology>

Implementation Guide

106

8 – FEATURE GRAPHICS
<ber:pointSymbolizer>
<se:Graphic>
<se:ExternalGraphic>

<se:OnlineResource
xlink:href="resource.xml#ber_LIDSdemo/51"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
<ber:symbolHeight>1</ber:symbolHeight>
</ber:pointSymbolizer>
</ber:symbology>
</ber:pointGraphicType>
</ber:graphicTypeComponent>
<ber:graphicTypeComponent id="gtcsr_01_3" name="Cross-section number"
roleId="text">
<ber:textGraphicType>
<ber:symbology>
<ber:textSymbolizer>
<ber:fontHeight>1</ber:fontHeight>
</ber:textSymbolizer>
</ber:symbology>
<ber:defaultTextProperties>
<ber:anchorPoint>center-center</ber:anchorPoint>
</ber:defaultTextProperties>
</ber:textGraphicType>
</ber:graphicTypeComponent>
<ber:graphicTypeComponent id="gtcsr_01_4" name="Direction symbol left"
roleId="leftDirection">
<ber:pointGraphicType>
<ber:symbology>
<ber:pointSymbolizer>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource
xlink:href="resource.xml#ber_LIDSdemo/53/right-center"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
<ber:rgbColor>#FF9000</ber:rgbColor>
</ber:pointSymbolizer>
</ber:symbology>
</ber:pointGraphicType>
</ber:graphicTypeComponent>
<ber:graphicTypeComponent id="gtcsr_01_5" name="Direction symbol right"
roleId="rightDirection">

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

107

<ber:pointGraphicType>
<ber:symbology>
<ber:pointSymbolizer>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource
xlink:href="resource.xml#ber_LIDSdemo/52/left-center"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
<ber:rgbColor>#FF9000</ber:rgbColor>
</ber:pointSymbolizer>
</ber:symbology>
</ber:pointGraphicType>
</ber:graphicTypeComponent>
</ber:graphicTypeComponentArray>
</ber:collectionGraphicType>
</ber:graphicType>

Example: Defining graphic tags – Detail reference.
<ber:model>
...
<ber:system id="0">
...
<ber:graphicTypeClassArray>
<ber:graphicTypeClass id="DetailReference" name="Detail reference">
<ber:description>Detail reference for plot outputs, graphic
tag</ber:description>
</ber:graphicTypeClass>
</ber:graphicTypeClassArray>
</ber:system>
...
<ber:graphicType id="gtdr_5070001" name="Red detail reference">
<ber:class refId="DetailReference"/>
<ber:collectionGraphicType>
<ber:symbology>
<ber:commonSymbolizer>
<ber:rgbColor>#AA0000</ber:rgbColor>
</ber:commonSymbolizer>
</ber:symbology>
<ber:graphicTypeComponentArray>
<ber:graphicTypeComponent id="gtdr_5070001_1" name="Label Line"
roleId="labelLine">

Implementation Guide

108

8 – FEATURE GRAPHICS
<ber:curveGraphicType>
<ber:symbology>
<ber:lineSymbolizer>
<se:Stroke>
<se:SvgParameter name="stroke-width">1</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
</ber:symbology>
</ber:curveGraphicType>
</ber:graphicTypeComponent>

<ber:graphicTypeComponent id="gtdr_5070001_2" name="Label Symbol"
roleId="labelSymbol">
<ber:pointGraphicType>
<ber:symbology>
<ber:pointSymbolizer>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource
xlink:href="resource.xml#ber_LIDSdemo/51"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
<ber:symbolHeight>1</ber:symbolHeight>
</ber:pointSymbolizer>
</ber:symbology>
</ber:pointGraphicType>
</ber:graphicTypeComponent>
<ber:graphicTypeComponent id="gtdr_5070001_3" name="Detail Number"
roleId="text">
<ber:textGraphicType>
<ber:symbology>
<ber:textSymbolizer>
<ber:fontHeight>1</ber:fontHeight>
</ber:textSymbolizer>
</ber:symbology>
<ber:defaultTextProperties>
<ber:anchorPoint>center-center</ber:anchorPoint>
</ber:defaultTextProperties>
</ber:textGraphicType>
</ber:graphicTypeComponent>
</ber:graphicTypeComponentArray>
</ber:collectionGraphicType>
</ber:graphicType>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

109

Example: Defining graphic tags – Detail reference in map frame.
<ber:model>
...
<ber:system id="0">
...
<ber:graphicTypeClassArray>
<ber:graphicTypeClass id="DetailReferenceMap" name="Detail reference in map
frame">
<ber:description>This graphic type is used for detail reference plot in map
frame.</ber:description>
</ber:graphicTypeClass>
</ber:graphicTypeClassArray>
</ber:system>
...
<ber:graphicType id="gt_detRefMap1" name="Detail reference in map frame">
<ber:class refId="DetailReferenceMap"/>
<ber:collectionGraphicType>
<ber:symbology>
<ber:derivedSymbolizer/>
</ber:symbology>
<ber:graphicTypeComponentArray>
<ber:graphicTypeComponent id="gt_detRefMap1_1" name="Label Line"
roleId="labelLine">
<ber:curveGraphicType>
<ber:symbology>
<ber:lineSymbolizer>
<se:Stroke>
<se:SvgParameter name="stroke-width">1</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
</ber:symbology>
</ber:curveGraphicType>
</ber:graphicTypeComponent>
<ber:graphicTypeComponent id="gt_detRefMap1_2" name="Detail frame"
roleId="detailFrame">
<ber:surfaceGraphicType>
<ber:symbology>
<ber:polygonSymbolizer>
<ber:fill>
<se:SvgParameter name="fill">#FFFFFE</se:SvgParameter>
<ber:fillStyle>solid</ber:fillStyle>
</ber:fill>
</ber:polygonSymbolizer>
</ber:symbology>

Implementation Guide

8 – FEATURE GRAPHICS

110

</ber:surfaceGraphicType>
</ber:graphicTypeComponent>
</ber:graphicTypeComponentArray>
</ber:collectionGraphicType>
</ber:graphicType>

Example: Defining graphic tags – Ghost symbol.
<ber:model>
...
<ber:system id="0">
...
<ber:graphicTypeClassArray>
<ber:graphicTypeClass id="GhostSymbol" name="Ghost symbol">
<ber:description>Graphic tag type consisting of one or more point symbols
at the same coordinates as the main graphics</ber:description>
</ber:graphicTypeClass>
</ber:graphicTypeClassArray>
</ber:system>
...
<ber:graphicType id="ghostsymb_01" name="Ghost symbol 1">
<ber:description>Two additional point symbols</ber:description>
<ber:class refId="GhostSymbol"/>
<ber:collectionGraphicType>
<ber:graphicTypeComponentArray>
<ber:graphicTypeComponent id="ghostsymb_01_01" name="circle">
<ber:pointGraphicType>
<ber:symbology>
<ber:pointSymbolizer>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource
xlink:href="resource.xml#ber_LIDSdemo/64/center-center"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
<ber:rgbColor>#0099CC</ber:rgbColor>
<ber:symbolHeight>2</ber:symbolHeight>
</ber:pointSymbolizer>
</ber:symbology>
</ber:pointGraphicType>
</ber:graphicTypeComponent>
<ber:graphicTypeComponent id="ghostsymb_01_02" name="Rectangle">
<ber:pointGraphicType>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

111

<ber:symbology>
<ber:pointSymbolizer>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource
xlink:href="resource.xml#ber_LIDSdemoMask/74/center-center"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
<ber:rgbColor>#FF9933</ber:rgbColor>
<ber:symbolHeight>0.9</ber:symbolHeight>
</ber:pointSymbolizer>
</ber:symbology>
</ber:pointGraphicType>
</ber:graphicTypeComponent>
</ber:graphicTypeComponentArray>
</ber:collectionGraphicType>
</ber:graphicType>

Example: Defining graphic tags – Free graphic tag.
<ber:model>
...
<ber:system id="0">
...
<ber:graphicTypeClassArray>
<ber:graphicTypeClass id="FreeGT" name="Free graphic tag">
<ber:description>Manually created graphic tag</ber:description>
</ber:graphicTypeClass>
</ber:graphicTypeClassArray>
</ber:system>
...
<ber:graphicType id="freegt_02" name="Scheme">
<ber:description>Scheme of devices inside</ber:description>
<ber:class refId="FreeGT"/>
<ber:collectionGraphicType>
<ber:graphicTypeComponentArray>
<ber:graphicTypeComponent id="freegt_02_01" name="Arrow">
<ber:pointGraphicType>
<ber:symbology>
<ber:pointSymbolizer>
<se:Graphic>
<se:ExternalGraphic>

Implementation Guide

112

8 – FEATURE GRAPHICS

<se:OnlineResource
xlink:href="resource.xml#ber_LIDSdemo/45"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
<ber:rgbColor>#CC0000</ber:rgbColor>
</ber:pointSymbolizer>
</ber:symbology>
</ber:pointGraphicType>
</ber:graphicTypeComponent>
<ber:graphicTypeComponent id="freegt_02_02" name="Arrow bold">
<ber:pointGraphicType>
<ber:symbology>
<ber:pointSymbolizer>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource
xlink:href="resource.xml#ber_LIDSdemo/47"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
<ber:rgbColor>#CC0000</ber:rgbColor>
<ber:symbolHeight>4</ber:symbolHeight>
</ber:pointSymbolizer>
</ber:symbology>
</ber:pointGraphicType>
</ber:graphicTypeComponent>
<ber:graphicTypeComponent id="freegt_02_03" name="Point full">
<ber:pointGraphicType>
<ber:symbology>
<ber:pointSymbolizer>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource
xlink:href="resource.xml#ber_LIDSdemo/35"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
<ber:rgbColor>#CC0000</ber:rgbColor>
</ber:pointSymbolizer>
</ber:symbology>
</ber:pointGraphicType>
</ber:graphicTypeComponent>
<ber:graphicTypeComponent id="freegt_02_04" name="Point empty">

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

113

<ber:pointGraphicType>
<ber:symbology>
<ber:pointSymbolizer>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource
xlink:href="resource.xml#ber_LIDSdemo/51"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
<ber:rgbColor>#CC0000</ber:rgbColor>
</ber:pointSymbolizer>
</ber:symbology>
</ber:pointGraphicType>
</ber:graphicTypeComponent>
<ber:graphicTypeComponent id="freegt_02_05" name="Polygon">
<ber:surfaceGraphicType>
<ber:symbology>
<ber:polygonSymbolizer>
<ber:fill>
<se:SvgParameter name="fill">#808080</se:SvgParameter>
<ber:fillStyle>solid</ber:fillStyle>
</ber:fill>
<se:Stroke>
<se:SvgParameter name="stroke">#CC0000</se:SvgParameter>
<se:SvgParameter name="stroke-opacity">0.5</se:SvgParameter>
<se:SvgParameter name="stroke-width">2</se:SvgParameter>
</se:Stroke>
</ber:polygonSymbolizer>
</ber:symbology>
</ber:surfaceGraphicType>
</ber:graphicTypeComponent>
<ber:graphicTypeComponent id="freegt_02_06" name="Line">
<ber:curveGraphicType>
<ber:symbology>
<ber:lineSymbolizer>
<se:Stroke>
<se:SvgParameter name="stroke">#CC0000</se:SvgParameter>
<se:SvgParameter name="stroke-width">2</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
</ber:symbology>
</ber:curveGraphicType>
</ber:graphicTypeComponent>

Implementation Guide

8 – FEATURE GRAPHICS

114

<ber:graphicTypeComponent id="freegt_02_07" name="Text">
<ber:textGraphicType>
<ber:symbology>
<ber:textSymbolizer>
<se:Fill>
<se:SvgParameter name="fill">#CC0000</se:SvgParameter>
</se:Fill>
<ber:fontHeight>2</ber:fontHeight>
</ber:textSymbolizer>
</ber:symbology>
</ber:textGraphicType>
</ber:graphicTypeComponent>
</ber:graphicTypeComponentArray>
</ber:collectionGraphicType>
</ber:graphicType>

Example: Defining graphic tags – Direction symbol.
<ber:model>
...
<ber:system id="0">
...
<ber:graphicTypeClassArray>
<ber:graphicTypeClass id="DirectionSymbol" name="Direction symbol">
<ber:description>Symbol representing line direction, graphic
tag</ber:description>
</ber:graphicTypeClass>
</ber:graphicTypeClassArray>
</ber:system>
...
<ber:graphicType id="dirsymb_02" name="Direction symbol 2">
<ber:description>Arrow without label line</ber:description>
<ber:class refId="DirectionSymbol"/>
<ber:collectionGraphicType>
<ber:symbology>
<ber:derivedSymbolizer/>
</ber:symbology>
<ber:graphicTypeComponentArray>
<ber:graphicTypeComponent id="dirsymb_02_01" name="Arrow"
roleId="directionSymbol">
<ber:pointGraphicType>
<ber:symbology>
<ber:pointSymbolizer>
<se:Graphic>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

115

<se:ExternalGraphic>
<se:OnlineResource
xlink:href="resource.xml#ber_LIDSdemo/47/left-center"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
<ber:symbolHeight>1</ber:symbolHeight>
</ber:pointSymbolizer>
</ber:symbology>
</ber:pointGraphicType>
</ber:graphicTypeComponent>
</ber:graphicTypeComponentArray>
</ber:collectionGraphicType>
</ber:graphicType>

Example: Defining graphic tags – Reduction - lines.
<ber:model>
...
<ber:system id="0">
...
<ber:graphicTypeClassArray>
<ber:graphicTypeClass id="BorderLineReduction" name="Reduction - lines">
<ber:description>This graphic type is used for reduction consisting of
lines.</ber:description>
</ber:graphicTypeClass>
</ber:graphicTypeClassArray>
</ber:system>
...
<ber:graphicType id="reductionL_01" name="Reduction - lines 1">
<ber:description>Border lines and closing lines</ber:description>
<ber:class refId="BorderLineReduction"/>
<ber:collectionGraphicType>
<ber:symbology>
<ber:derivedSymbolizer/>
</ber:symbology>
<ber:graphicTypeComponentArray>
<ber:graphicTypeComponent id="reductionL_01_1" name="Border line"
roleId="borderLine">
<ber:curveGraphicType/>
</ber:graphicTypeComponent>
<ber:graphicTypeComponent id="reductionL_01_2" name="Closing line"
roleId="closingLine">
<ber:curveGraphicType/>
</ber:graphicTypeComponent>

Implementation Guide

8 – FEATURE GRAPHICS

116

</ber:graphicTypeComponentArray>
</ber:collectionGraphicType>
</ber:graphicType>

Example: Defining graphic tags – Reduction - polygon.
<ber:model>
...
<ber:system id="0">
...
<ber:graphicTypeClassArray>
<ber:graphicTypeClass id="BorderPolygonReduction" name="Reduction - polygon">
<ber:description>This graphic type is used for reduction consisting of
polygon.</ber:description>
</ber:graphicTypeClass>
</ber:graphicTypeClassArray>
</ber:system>
...
<ber:graphicType id="reductionP_01" name="Reduction - polygon 1">
<ber:description>Reduction as polygon</ber:description>
<ber:class refId="BorderPolygonReduction"/>
<ber:collectionGraphicType>
<ber:symbology>
<ber:derivedSymbolizer/>
</ber:symbology>
<ber:graphicTypeComponentArray>
<ber:graphicTypeComponent id="reductionP_01_1" name="Border polygon">
<ber:surfaceGraphicType>
<ber:symbology>
<ber:polygonSymbolizer>
<ber:fill>
<se:SvgParameter name="fill-opacity">0.3</se:SvgParameter>
<ber:fillStyle>solid</ber:fillStyle>
</ber:fill>
</ber:polygonSymbolizer>
</ber:symbology>
</ber:surfaceGraphicType>
</ber:graphicTypeComponent>
</ber:graphicTypeComponentArray>
</ber:collectionGraphicType>
</ber:graphicType>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6
8.2.4

117

Mapping graphic tag types for change feature type function
Function change feature type enables preserving of defined graphic tags of the source feature after
converting to target feature type. GraphicTagType definition is unique for every feature type and
different feature types can’t share the same graphicTagType definition. That’s why some additional
mapping is necessary. The mapping is defined in graphicTagTypeMappingArray in option.xml.
The rules for processing are different for individual graphicClasses:
• BorderLineReduction, BorderPolygonReduction, DirectionSymbol – the mapping is defined for
source and target graphicTagType only
• if the mapping doesn’t exist, the graphicTag is deleted
• if the mapping exists, individual components are mapped automatically using their roles
• DA – the mapping is defined for source and target graphicTagType only
• if the mapping doesn’t exist, the system searches, if the source graphicTagType shares common
definition with some graphicTagType of target feature type in displayableAttributeArray in
option.xml
• FreeGT – the mapping can include both source and target graphicTagType and also individual
components
• if the mapping doesn’t exist at all, the graphicTag is deleted
• if the mapping exists for source and target graphicTagType, but is missing for particular
component
• and source and target graphicTagType refer the same graphicType -> component is preserved
• and source and target graphicTagType refer different graphicType -> component is deleted
• GhostSymbol, BorderLine, BorderPolygon, PlacedCS, CSReference, DetailReference,
DetailReferenceMap
• graphic tags of these classes are not preserved after changing feature type

Example: Defining graphic tags mapping in option.xml.
<ber:graphicTagTypeMappingArray>
<ber:graphicTagTypeMapping id="m_1" name="DA 1">
<ber:graphicTagType xlink:href="model.xml#ft_A_da_1"/>
<ber:graphicTagType xlink:href="model.xml#ft_B_da_1"/>
</ber:graphicTagTypeMapping>
<ber:graphicTagTypeMapping id="m_2" name="DA 2">
<ber:graphicTagType xlink:href="model.xml#ft_A_da_2"/>
<ber:graphicTagType xlink:href="model.xml#ft_B_da_2"/>
<ber:graphicTagType xlink:href="model.xml#ft_C_da_2"/>
</ber:graphicTagTypeMapping>
<ber:graphicTagTypeMapping id="m_3" name="Direction symbols">
<ber:graphicTagType xlink:href="model.xml#ft_A_dirsymb_01"/>
<ber:graphicTagType xlink:href="model.xml#ft_A_dirsymb_02"/>
<ber:graphicTagType xlink:href="model.xml#ft_A_dirsymb_03"/>
<ber:graphicTagType xlink:href="model.xml#ft_B_dirsymb_01"/>

Implementation Guide

118

8 – FEATURE GRAPHICS
<ber:graphicTagType xlink:href="model.xml#ft_C_dirsymb_01"/>
</ber:graphicTagTypeMapping>
<ber:graphicTagTypeMapping id="m_4" name="Free graphic tags">
<ber:graphicTagType xlink:href="model.xml#ft_A_freegt_01"/>
<ber:graphicTagType xlink:href="model.xml#ft_A_freegt_02"/>
<ber:graphicTagType xlink:href="model.xml#ft_B_freegt_01"/>
<ber:graphicTagType xlink:href="model.xml#ft_C_freegt_01"/>
<ber:equivalentComponents>
<ber:graphicTypeComponent xlink:href="model.xml#freegt_01_01"/>
<ber:graphicTypeComponent xlink:href="model.xml#freegt_01_02"/>
<ber:graphicTypeComponent xlink:href="model.xml#freegt_01_03"/>
<ber:graphicTypeComponent xlink:href="model.xml#freegt_02_06"/>
</ber:equivalentComponents>
<ber:equivalentComponents>
<ber:graphicTypeComponent xlink:href="model.xml#freegt_01_04"/>
<ber:graphicTypeComponent xlink:href="model.xml#freegt_01_05"/>
<ber:graphicTypeComponent xlink:href="model.xml#freegt_01_06"/>
<ber:graphicTypeComponent xlink:href="model.xml#freegt_02_07"/>
</ber:equivalentComponents>
<ber:equivalentComponents>
<ber:graphicTypeComponent xlink:href="model.xml#freegt_01_07"/>
<ber:graphicTypeComponent xlink:href="model.xml#freegt_01_08"/>
<ber:graphicTypeComponent xlink:href="model.xml#freegt_01_09"/>
<ber:graphicTypeComponent xlink:href="model.xml#freegt_02_01"/>
<ber:graphicTypeComponent xlink:href="model.xml#freegt_02_02"/>
<ber:graphicTypeComponent xlink:href="model.xml#freegt_02_03"/>
<ber:graphicTypeComponent xlink:href="model.xml#freegt_02_04"/>
</ber:equivalentComponents>
<ber:equivalentComponents>
<ber:graphicTypeComponent xlink:href="model.xml#freegt_01_10"/>
<ber:graphicTypeComponent xlink:href="model.xml#freegt_01_11"/>
<ber:graphicTypeComponent xlink:href="model.xml#freegt_01_12"/>
<ber:graphicTypeComponent xlink:href="model.xml#freegt_02_05"/>
</ber:equivalentComponents>
</ber:graphicTagTypeMapping>
</ber:graphicTagTypeMappingArray>

8.3

Display order
Display order of various geometry data can be preconfigured in metadata or in saved settings. These
definitions can usually be reconfigured by the user interactively depending on the particular client
application functionality.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6
8.3.1

119

Feature types
Feature type order definition is different for various layer kinds:
• layer defined by template setting – order of feature types is defined in a template definition.
• layer defined by category (WMS / WMTS layer) – order of feature types is defined by the order of
items in category definition in model.xml.
• layer defined as a selection of individual features – order of feature types is set alphabetically by the
the feature type name

8.3.2

Graphic tag types
Individual graphic tag types are ordered inside a feature type by the optional drawPriority attribute in
model.xml:
• smaller value moves the graphic tag type up in the order
• bigger value moves the graphic tag type down
• value 0 means the order of master graphics

8.3.3

Graphic tag and collection components
Order of individual components inside a graphic tag or master graphics collection is defined by the order
of specifying graphicTypeComponent in graphicTypeComponentArray in model.xml.

Implementation Guide

120

8 – FEATURE GRAPHICS

Implementation Guide

Chapter 9
Feature Symbology

IMPLEMENTATION GUIDE VERSION 9.6

9.

123

Feature Symbology
The definition of feature symbology is strictly separated from its geometry. It results in the very flexible
system where features are symbolized just before their presentation. The symbology definition is feature
type based. It can be either static (the same for all instances of the feature type in any scale) or dynamic
(varies according to the current scale and/or feature attribute values). Every feature type can define one
default static and one default dynamic symbology. While the static symbology is the part of the feature
type definition, the dynamic symbology refers special LIDS metadata section (in thematization.xml).



9.1

It is not necessary to define symbology in its full form. It is possible to define any subset of symbology
properties (partial symbolizers) and the system itself fills the missing properties from some super
symbology definition in any part of metadata. The super symbology varies for various symbology
definitions.

Static Symbology
The LIDS symbology definition is based on OGC Symbology Encoding (SE) specification. It means the
LIDS symbology definition is very easily shareable among other systems and tools supporting the SE
standard. Each LIDS geometry type has its own type of symbology definition. There are four basic
symbology types in LIDS: point, curve, surface, text.

9.1.1

Curve symbology
Example: Curve symbology definition.
<ber:featureType id="ft_5012100" name="Main pipeline segment"
parentId="ft_5012000" abstract="false">
<ber:description>Main pipeline segment</ber:description>
<ber:masterGraphics nillable="true">
<ber:curveGraphicType>
<ber:symbology>
<ber:lineSymbolizer>
<se:Stroke>
<se:GraphicStroke>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ls_0"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
</se:GraphicStroke>
<se:SvgParameter name="stroke">#1C32FF</se:SvgParameter>
<se:SvgParameter name="stroke-opacity">1</se:SvgParameter>
<se:SvgParameter name="stroke-width">2</se:SvgParameter>

Implementation Guide

9 – FEATURE SYMBOLOGY

124

</se:Stroke>
</ber:lineSymbolizer>
</ber:symbology>
</ber:curveGraphicType>
</ber:masterGraphics>
...
</ber:featureType>

•
•
•
•

symbology – Encapsulates complete static symbology definition.
lineSymbolizer – SE based symbology definition for curve geometries. Only the above set of
subelements is supported in LIDS.
GraphicStroke – The only one of the SE linestroke types that is supported by LIDS. It references
the linestyle for stroke rendering defined as LIDS resource.
The Stroke definition contains the following set of SVG Parameters:
stroke – Specifies the solid color that will be used for a stroke. The color value is RGB-encoded
using two hexadecimal digits per primary-color component, in the order Red, Green, Blue,
prefixed with a hash (#) sign.
stroke-opacity – Specifies the level of translucency to use when rendering the stroke. The value is
encoded as a float between 0.0 and 1.0 with 0.0 representing completely transparent and 1.0
representing completely opaque.
stroke-width – Specifies the absolute width (thickness) of a stroke in pixels encoded as a float.
Maximum value 31.

Line width
Line width is defined in LIDS as unitless index values between 0 and 31. However, in some situations
it’s necessary to convert these width indexes to different units.



The line width used for displaying can be different than the one used for printing. It’s possible to map a
display width to the printing width (specified in device independent points DIP - 1/96 inch). The
mapping is common for whole project and is defined in lineWeights element in presentation.xml.
Example: Line weights for printing mapping.
<ber:plotting>
<!-- Default symbolizer for north arrow in map output -->
<ber:defaultNortharrow>
<ber:pointSymbolizer>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#fontname/66"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
<ber:rgbColor>#C80000</ber:rgbColor>
<ber:symbolHeight>36</ber:symbolHeight>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

125

</ber:pointSymbolizer>
</ber:defaultNortharrow>
<!-- Line weights mapping -->
<ber:lineWeights>
<ber:lineWeight display="0" print="0.025"/>
<ber:lineWeight display="1" print="0.125"/>
<ber:lineWeight display="2" print="0.25"/>
<ber:lineWeight display="3" print="0.35"/>
<ber:lineWeight display="4" print="0.5"/>
<ber:lineWeight display="5" print="0.75"/>
<ber:lineWeight display="6" print="1"/>
</ber:lineWeights>
</ber:plotting>



DWG file format defines line weights in mm. It’s possible to map line weight indexes used in LIDS to
the DWG line weights in mm. This mapping is considered when exporting / importing DWG and when
displaying DWG. The mapping is common for whole project and is defined in dwgLineWeights element
in presentation.xml.
Example: Line weights for DWG mapping.
<ber:dwgLineWeights>
<ber:dwgLineWeight display="0" dwg="0"/>
<ber:dwgLineWeight display="1" dwg="0.13"/>
<ber:dwgLineWeight display="2" dwg="0.30"/>
<ber:dwgLineWeight display="3" dwg="0.40"/>
<ber:dwgLineWeight display="4" dwg="0.53"/>
<ber:dwgLineWeight display="5" dwg="0.70"/>
<ber:dwgLineWeight display="6" dwg="0.80"/>
</ber:dwgLineWeights>

User line style
To display line features, it is possible to use user line styles. These are specified by a data model. Each
style must be stated in resource.xml together with list of available formats and name of files containing
the style definition. Style definition files are stored as project resource files on application server and
are cached by LIDS client when logging in to the project
The list of supported formats differs for different client applications:
• LIDS Edit with MicroStation or Bentley PowerMap: RSC format
• LIDS Edit with AutoCAD Map: LIN format
• LIDS Explorer: own definitions of user line styles in XML files

Implementation Guide

9 – FEATURE SYMBOLOGY

126



Definition in XML format must be prepared for purposes of map outputs for any type of client
application.
Description of XML format follows.
Line symbology can refer to predefined user line styles listed in resource.xml. It’s necessary to specify
basic information about line style in resource.xml. Detailed definition of each style listed in resource.xml
is prepared as a special xml-file (of our own format).
Example: Line style basic information in resource.xml.
...
<ber:lineStyle id="ls_MIGRACNI_BARIERA" name="ls_MIGRACNI_BARIERA">
<ber:formatArray>
<ber:format name="xml" file="ls_uap.xml"/>
</ber:formatArray>
</ber:lineStyle>
...
</ber:lineStyleArray>



Since version 7.1.6 there is one exception: solid style is supported as a system line style so it doesn't
need any xml-definition (style ls_0 in past).
User line style logically consists of one or more line components optionally shifted from a curve's axis
and of an optional start and end symbol. Line components are defined separately in definition file with
possibility to share them by more style definitions within one xml-file.
User line style consists of following parts:
•

•
•

At least one line component (its definition reference) for which these properties can be singly set:
• perpendicular distance of shifting from a curve's axis - component will be drawn in this distance
• gap at the beginning of curve - component parts drawing will start after this gap
• gap at the end of curve - component parts drawing ends before this gap
optionally symbol to be drawn at the beginning of curve
optionally symbol to be drawn at the end of curve

Start / end symbol properties:
•
•
•
•
•

definition of used symbol
used units (e.g. meters or pixels)
symbol size
symbol indent (distance in x and y direction from the beginning / end of curve towards the center of
used symbol)
symbol rotation - it can be of two types:
• relative – rotation by specified angle towards the given curve's segment
• absolute – rotation towards global coordinate system

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

127

Line component definition consists of:
•
•

•

•

•

Used units (e.g. meters or pixels)
Optionally line component parts, so called dash-stroke, that defines size and relay of single parts.
The parts can be of following types:
• solid line
• gap
• symbol
• text
Drawing mode
• continuous – the parts are drawn continuously along the whole curve; in inner vertexes a dashstroke is eventually “wrapped”
• by segments – the parts are drawn continuously along the single curve segments; in inner vertex
a dash-stroke begins from its first part
• center in segment – for a single curve segment a dash-stroke is drawn just once and centered;
segment length must be greater than a sum of lengths of dash-stroke parts
Optional parameter of minimal length – in combination with drawing mode it can influence whether
single parts of line components will be drawn
• continuous mode – a dash-stroke is drawn if a total length of curve is grater or equal to specified
minimal length
• by segments mode – a dash-stroke is drawn for the segment if segment length is grater or equal
to specified minimal length
• center in segment mode – a dash-stroke is drawn only if at once segment length is grater or
equal to a sum of lengths of dash-stroke parts and is grater or equal to specified minimal length
Way how to solve situation when there is not enough space for a dash-stroke part or when some of
size conditions (mentioned above) is not fulfilled. Possible ways:
• render solid line
• render nothing (default behavior)

Dash-stroke part definition – symbol:
•
•
•
•

definition of used symbol
symbol size - units are taken over from the parent line component
symbol indent (distance in x and y direction from the dash-stroke part center towards the center of
used symbol)
symbol rotation - it can be of two types:
• relative – rotation by specified angle towards the given curve's segment
• absolute – rotation towards global coordinate system

Dash-stroke part definition – text:
•
•
•
•
•

displayed text
used font
text height – it is taken over from the parent line component
text indent (distance in x and y direction from the dash-stroke part center towards the center of used
text)
text rotation - it can be of two types:

Implementation Guide

9 – FEATURE SYMBOLOGY

128
•
•

relative – rotation by specified angle towards the given curve's segment
absolute – rotation towards global coordinate system



Symbols and texts are not clipped within a dash-stroke part (i.e. they can exceed dash-stroke part size).



Line weight specified by a feature symbology is not applied to symbol / text parts of a dash-stroke.
Example: Line style with text component.

<ber:lineStyleArray>
...
<ber:lineStyle id="ls_PAM_REZERVACE_VPR">
<ber:components>
<ber:component refId="comp_pr_vpr">
<ber:perpendicularOffset>0.0</ber:perpendicularOffset>
</ber:component>
</ber:components>
</ber:lineStyle>
...
</ber:lineStyleArray>
...
<ber:componentArray>
...
<ber:component id="comp_pr_vpr"
uom="http://www.opengeospatial.org/se/units/pixel">
<ber:stroke-dasharray>14 -5 14 -5 20[text_1] -5 14 -5 14 -5</ber:strokedasharray>
<ber:segmentMode>continue</ber:segmentMode>
<ber:requiredLength>50</ber:requiredLength>
<ber:outOfStrokeGlue>solid</ber:outOfStrokeGlue>
<ber:strokeArray>
<ber:textStroke id="text_1">
<ber:textSymbolizer>
<se:Label>VPR</se:Label>
<se:Font>
<se:SvgParameter name="font-family">Arial</se:SvgParameter>
<se:SvgParameter name="font-size">7</se:SvgParameter>
</se:Font>
<se:LabelPlacement>
<se:PointPlacement>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

129

<se:Displacement>
<se:DisplacementX>0</se:DisplacementX>
<se:DisplacementY>0</se:DisplacementY>
</se:Displacement>
</se:PointPlacement>
</se:LabelPlacement>
<ber:rotation type="relative">0</ber:rotation>
</ber:textSymbolizer>
</ber:textStroke>
</ber:strokeArray>
</ber:component>
...
</ber:componentArray>

Example: Line style with symbol component

<ber:lineStyleArray>
...
<ber:lineStyle id="ls_VLEK">
<ber:components>
<ber:component refId="comp_vlek">
<ber:perpendicularOffset>0</ber:perpendicularOffset>
</ber:component>
</ber:components>
</ber:lineStyle>
...
</ber:lineStyleArray>
...
<ber:componentArray>
...
<ber:component id="comp_vlek"
uom="http://www.opengeospatial.org/se/units/pixel">
<ber:stroke-dasharray>10 6[symbol_1] 50</ber:stroke-dasharray>
<ber:segmentMode>continue</ber:segmentMode>
<ber:requiredLength>20</ber:requiredLength>
<ber:outOfStrokeGlue>solid</ber:outOfStrokeGlue>
<ber:strokeArray>
<ber:pointStroke id="symbol_1">
<ber:pointSymbolizer>

Implementation Guide

9 – FEATURE SYMBOLOGY

130

<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ber_LIDSuap2/104"/>
<se:Format/>
</se:ExternalGraphic>
<se:Size>6</se:Size>
<se:Displacement>
<se:DisplacementX>0</se:DisplacementX>
<se:DisplacementY>0</se:DisplacementY>
</se:Displacement>
</se:Graphic>
<ber:rotation type="relative">0</ber:rotation>
</ber:pointSymbolizer>
</ber:pointStroke>
</ber:strokeArray>
</ber:component>
...
</ber:componentArray>

Example: Complex line style

<ber:lineStyleArray>
...
<ber:lineStyle id="ls_ZELEZ_DRAHA">
<ber:components>
<ber:component refId="comp_zeldraha_top">
<ber:perpendicularOffset>2</ber:perpendicularOffset>
</ber:component>
<ber:component refId="comp_zeldraha">
<ber:perpendicularOffset>0</ber:perpendicularOffset>
</ber:component>
<ber:component refId="comp_zeldraha_bottom">
<ber:perpendicularOffset>-2</ber:perpendicularOffset>
</ber:component>
</ber:components>
<ber:startSymbol>
<ber:pointSymbolizer uom="http://www.opengeospatial.org/se/units/pixel">
<se:Graphic>
<se:ExternalGraphic>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

131

<se:OnlineResource xlink:href="resource.xml#ber_LIDSuap1/102"/>
<se:Format/>
</se:ExternalGraphic>
<se:Size>10</se:Size>
<se:Displacement>
<se:DisplacementX>0</se:DisplacementX>
<se:DisplacementY>0</se:DisplacementY>
</se:Displacement>
</se:Graphic>
<ber:rotation type="relative">0</ber:rotation>
</ber:pointSymbolizer>
</ber:startSymbol>
<ber:endSymbol>
<ber:pointSymbolizer uom="http://www.opengeospatial.org/se/units/pixel">
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ber_LIDSuap1/102"/>
<se:Format/>
</se:ExternalGraphic>
<se:Size>10</se:Size>
<se:Displacement>
<se:DisplacementX>0</se:DisplacementX>
<se:DisplacementY>0</se:DisplacementY>
</se:Displacement>
</se:Graphic>
<ber:rotation type="relative">0</ber:rotation>
</ber:pointSymbolizer>
</ber:endSymbol>
</ber:lineStyle>
...
</ber:lineStyleArray>
...
<ber:componentArray>
...
<ber:component id="comp_zeldraha"
uom="http://www.opengeospatial.org/se/units/pixel">
<ber:stroke-dasharray>-1 10[symbol_1] -14</ber:stroke-dasharray>
<ber:segmentMode>continue</ber:segmentMode>
<ber:outOfStrokeGlue>segment</ber:outOfStrokeGlue>
<ber:strokeArray>
<ber:pointStroke id="symbol_1">
<ber:pointSymbolizer>
<se:Graphic>
<se:ExternalGraphic>

Implementation Guide

9 – FEATURE SYMBOLOGY

132

<se:OnlineResource xlink:href="resource.xml#ber_LIDSuap1/98"/>
<se:Format/>
</se:ExternalGraphic>
<se:Size>20</se:Size>
<se:Displacement>
<se:DisplacementX>0</se:DisplacementX>
<se:DisplacementY>0</se:DisplacementY>
</se:Displacement>
</se:Graphic>
<ber:rotation type="relative">0</ber:rotation>
</ber:pointSymbolizer>
</ber:pointStroke>
</ber:strokeArray>
</ber:component>
<ber:component id="comp_zeldraha_top"
uom="http://www.opengeospatial.org/se/units/pixel">
<ber:stroke-dasharray>3000</ber:stroke-dasharray>
<ber:segmentMode>continue</ber:segmentMode>
<ber:outOfStrokeGlue>solid</ber:outOfStrokeGlue>
</ber:component>
<ber:component id="comp_zeldraha_bottom"
uom="http://www.opengeospatial.org/se/units/pixel">
<ber:stroke-dasharray>3000</ber:stroke-dasharray>
<ber:segmentMode>continue</ber:segmentMode>
<ber:outOfStrokeGlue>solid</ber:outOfStrokeGlue>
</ber:component>
...
</ber:componentArray>

9.1.2

Surface symbology
Example: Surface symbology definition.
<ber:featureType id="ft_5060000" name="Service organization unit"
parentId="ft_5000002" abstract="false">
<ber:description>Service organization unit</ber:description>
...
<ber:masterGraphics nillable="true">
<ber:surfaceGraphicType>
<ber:symbology>
<ber:polygonSymbolizer>
<ber:fill>
<se:SvgParameter name="fill">#808080</se:SvgParameter>
<se:SvgParameter name="fill-opacity">0.5</se:SvgParameter>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

133

<ber:fillStyle>solid</ber:fillStyle>
</ber:fill>
<se:Stroke>
<se:GraphicStroke>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ls_0"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
</se:GraphicStroke>
<se:SvgParameter name="stroke">#D5B862</se:SvgParameter>
<se:SvgParameter name="stroke-opacity">1</se:SvgParameter>
<se:SvgParameter name="stroke-width">2</se:SvgParameter>
</se:Stroke>
</ber:polygonSymbolizer>
</ber:symbology>
</ber:surfaceGraphicType>
</ber:masterGraphics>
...
</ber:featureType>

Example: Pattern fill.
<ber:polygonSymbolizer>
...
<ber:patternFill>
<se:GraphicFill>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#fs_symbol_1"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
</se:GraphicFill>
<se:SvgParameter name="fill">#FF8040</se:SvgParameter>
</ber:patternFill>

•
•

polygonSymbolizer – SE based symbology definition for surface geometries. Only the above set of
subelements is supported in LIDS.
fill – Specifies how the area of the surface will be filled. The meanings of its SvgParameters are
similar to the Stroke parameters discussed in conjunction with curve symbology above. Here, the
SvgParameter names are fill instead of stroke and fill-opacity instead of stroke-opacity.
The fillStyle parameter has two possible values, solid and none, which define filled/unfilled areas.

Implementation Guide

9 – FEATURE SYMBOLOGY

134
•



patternFill – Combination of pattern defined by a reference to an external style and fill defined by
SvgParameter.

Fill style set to none can be combined with fill color and opacity definition. It looks like senseless
definition but it can be useful in project default symbolizer definition (presentation.xml).
•

Stroke – Specifies how the surface border will be stroked. The set and meaning of its SvgParameters
is discussed in curve symbology definition above.

User line style
To display surface border, it is possible to use user line styles.
For more details see chapter 9.1.1.2

Hatching and pattern style
Hatching or pattern style can be also a part of surface symbology. It’s necessary to specify basic
information about hatching / pattern style in resource.xml.
Example: Fill style basic information in resource.xml.
<ber:fillStyleArray>
...
<ber:fillStyle id=" fs_symbol_1" name="patern with symbol_no. 101">
<ber:formatArray>
<ber:format name="xml" file="fillstyle.xml"/>
</ber:formatArray>
</ber:fillStyle>
...
</ber:fillStyleArray>

Detailed definition of each style listed in resource.xml is prepared (analogously to user line style
definition) as a special xml-file (of our own format). The same definition file is used by all LIDS clients.



Definition file uses project units hence a fill is zoom-dependent.
Single hatching / pattern style is defined as a one of following types:
• Hatch - simple line
• Hatch - double line
• Pattern - symbol
Hatch – simple line
A style consists of a simple line which is rotated and displayed repeatedly in defined spacing. A line can
be drawn including its weight (in pixels) and simple user line style based on one dash-stroke component
only.
Parameters:
• rotation

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6
•
•
•

135

spacing (distance to the next line)
line style
line weight

Hatch – double line (cross-hatch)
A style consists of two lines that are rotated and displayed repeatedly in defined spacing. A line can be
drawn including its weight (in pixels) and simple user line style based on one dash-stroke component
only. Both lines share a weight and a line style.
Parameters:
• 1. line - rotation
• 1. line - spacing (distance to the next line)
• 2. line - rotation
• 2. line - spacing (distance to the next line)
• line style
• line weight
Pattern
A style is based on iterative drawing of a tile which contains defined symbol in its center. A symbol is
aligned according to a tile center and it has its size and rotation. A size and rotation is defined for a tile
as well.
Optionally it is possible to specify an indent of even rows compared to odd rows.
Parameters:
• symbol definition (font, character, justification)
• symbol size
• symbol rotation
• tile rotation
• x-step for a tile
• y-step for a tile
• indent (for even rows only)





One definition file can contain more style definitions.

Too detailed style definition can influence drawing performance especially in LIDS Edit over
MicroStation environment.

Pattern styles are implemented as cells in LIDS Edit. A cell library is on fly generated for each definition
xml-file and it is stored in Data project directory. These libraries are newly generated only when time
stamp of definition file has been changed.

Implementation Guide

136

9 – FEATURE SYMBOLOGY

Example: Fill style – hatch pattern.

<ber:crosshatchPattern id="fs_crosshatch_30_150_5">
<ber:lines>
<ber:distance>5</ber:distance>
<ber:rotation>30</ber:rotation>
</ber:lines>
<ber:crosslines>
<ber:distance>5</ber:distance>
<ber:rotation>150</ber:rotation>
</ber:crosslines>
<ber:lineSymbolizer>
<se:Stroke>
<se:GraphicStroke>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="system.linestyle#solid"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
</se:GraphicStroke>
<se:SvgParameter name="stroke-width">1</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
</ber:crosshatchPattern>

Example: Fill style – symbol pattern.

<ber:symbolPattern id="fs_pattern_tuz_4000">
<ber:grid>
<ber:distanceX>28</ber:distanceX>
<ber:distanceY>28</ber:distanceY>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

137

<ber:rotation>0</ber:rotation>
<ber:evenOffset>14</ber:evenOffset>
</ber:grid>
<ber:pointSymbolizer uom="http://www.opengeospatial.org/se/units/pixel">
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ber_arimr/87/center-center"/>
<se:Format/>
</se:ExternalGraphic>
<se:Size>7</se:Size>
<se:Rotation>0</se:Rotation>
</se:Graphic>
</ber:pointSymbolizer>
</ber:symbolPattern>

Example: Fill style – text Pattern.

<ber:symbolPattern id="fs_pattern_dr_4000">
<ber:grid>
<ber:distanceX>28</ber:distanceX>
<ber:distanceY>28</ber:distanceY>
<ber:rotation>0</ber:rotation>
<ber:evenOffset>14</ber:evenOffset>
</ber:grid>
<ber:pointSymbolizer uom="http://www.opengeospatial.org/se/units/pixel">
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ber_arimr/110/centercenter"/>
<se:Format/>
</se:ExternalGraphic>
<se:Size>7</se:Size>
<se:Rotation>0</se:Rotation>
</se:Graphic>
</ber:pointSymbolizer>
</ber:symbolPattern>

Implementation Guide

9 – FEATURE SYMBOLOGY

138



It is not possible to use Text symbolizer to create a pattern. Text must be defined as Point Symbolizer.

9.1.3

Point symbology
Example: Point symbology definition.
<ber:featureType id="ft_5010100" name="Pumping station"
parentId="ft_5010000" abstract="false">
<ber:description>Pumping station</ber:description>
...
<ber:masterGraphics nillable="true">
<ber:pointGraphicType>
<ber:symbology>
<ber:pointSymbolizer>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource
xlink:href="resource.xml#ber_LIDSdemo/36/center-center/masked"/>
<se:Format/>
</se:ExternalGraphic>
<se:Opacity>1.0</se:Opacity>
</se:Graphic>
<ber:rgbColor>#1C32FF</ber:rgbColor>
<ber:symbolHeight>10</ber:symbolHeight>
</ber:pointSymbolizer>
</ber:symbology>
</ber:pointGraphicType>
</ber:masterGraphics>
...
</ber:featureType>

•

•
•
•
•
•

pointSymbolizer – SE based symbology definition for point geometries. It is used to draw a symbol
at a point. As LIDS symbol is in fact a character in a symbol font, the standard SE definition is
modified as described below.
Graphic - SE definition of the rendered symbol.
ExternalGraphic – SE based reference to the LIDS symbol. The format of the reference is
resource.xml#symbol_font_id/symbol_position/symbol_anchor_point/masked.
Opacity – Specifies the opacity to use for rending the symbol. It has the same semantics as the
stroke-opacity and fill-opacity SvgParameters discussed above.
rgbColor – LIDS extension of the standard SE point symbology. Defines the symbol color similarly
to stroke and fill SvgParameters discussed above.
symbolHeight - LIDS extension of the standard SE point symbology. Specifies the absolute size of
the symbol in the project base units.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

139

It’s necessary to specify basic information about symbol font in resource.xml.
Example: Symbol font basic information in resource.xml.
<ber:symbolFontArray>
<ber:symbolFont id="ttf_outline" name=" ttf outline">
<ber:formatArray>
<ber:format file="ttf outline.ttf" name="ttf"/>
</ber:formatArray>
</ber:symbolFont>
...
</ber:symbolFontArray>


9.1.4

Symbol fonts can be either installed in operating system or can be stored as a resource on AS and
downloaded only when necessary. For more details see chapter 28.5.

Text symbology
Example: Text symbology definition.
<ber:featureType id="ft_5084000" name="Sketch text"
parentId="ft_5080000" abstract="false">
<ber:description>Sketch text</ber:description>
<ber:masterGraphics nillable="false">
<ber:textGraphicType>
<ber:symbology>
<ber:textSymbolizer>
<se:Font>
<se:SvgParameter name="font-family">Arial</se:SvgParameter>
<se:SvgParameter name="font-style">normal</se:SvgParameter>
<se:SvgParameter name="font-weight">normal</se:SvgParameter>
</se:Font>
<se:Fill>
<se:SvgParameter name="fill">#00FF00</se:SvgParameter>
<se:SvgParameter name="fill-opacity">1</se:SvgParameter>
</se:Fill>
<ber:fontHeight>1.5</ber:fontHeight>
<ber:lineSpacing>0.25</ber:lineSpacing>
<ber:mask>
<ber:style>outline</ber:style>
</ber:mask>

Implementation Guide

140

9 – FEATURE SYMBOLOGY
</ber:textSymbolizer>
</ber:symbology>
</ber:textGraphicType>
</ber:masterGraphics>

</ber:featureType>

•
•

•
•
•
•

textSymbolizer – SE based symbology definition for styling text labels. Only the above set of
subelements is supported in LIDS.
Font - Identifies a font of a certain family, style, and size. The font-family SvgParameter gives the
family name of a font to use. The font can be either any font installed in clients and server (WMS)
operating systems or font registered in project resources. The font-style SvgParameter gives the
style to use for a font. The allowed values are normal and italic. The font-weight SvgParameter
gives the boldness to use for a font. Allowed values are normal and bold.
Fill – Defines color and opacity of the text. The SvgParameters are discussed above (see surface
symbology definition).
fontHeight – LIDS extension of the standard SE font definition. Defines the font height in the
project base units.
lineSpacing – LIDS extension of the standard SE font definition. Height of the space between any
two neighbor text lines in the project base units. Applies to multiline texts only.
mask – LIDS extension of the standard SE font definition. Defines the text masking. Parameters are
<ber:style> (with possible values fill, none, outline, outline-fill), <ber:shape> (circle, ellipse,
multiRectangle, rectangle) and <se:Stroke>.

Example: Text symbology with reference to external style.
<ber:textSymbolizer>
<se:Fill>
<se:SvgParameter name="fill">#00FFFF</se:SvgParameter>
</se:Fill>
<ber:fontHeight>0.5</ber:fontHeight>
<ber:lineSpacing>0.25</ber:lineSpacing>
<ber:mask>
<ber:style>outline-fill</ber:style>
<ber:shape>multiRectangle</ber:shape>
<se:Stroke>
<se:GraphicStroke>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="system.linestyle#solid"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
</se:GraphicStroke>
<se:SvgParameter name="stroke-width">1</se:SvgParameter>
</se:Stroke>
</ber:mask>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

141

</ber:textSymbolizer>

9.1.5

Collection symbology
In case of collection graphics, symbology for every component can be defined. Besides the component
symbologies, a common symbology can be defined. The common symbology has two properties
common to all symbologies – color and opacity. The common symbology is super symbology of the
component symbologies. It means that components can take color and opacity over from the common
symbology.
Example: Displayable attribute symbology definition.
<ber:graphicTypeArray>
<ber:graphicType id="gtda_5012102" name="W_DA_5012102">
<ber:class refId="DA"/>
<ber:collectionGraphicType>
<ber:symbology>
<ber:commonSymbolizer>
<ber:rgbColor>#1C32FF</ber:rgbColor>
<se:Opacity>1</se:Opacity>
</ber:commonSymbolizer>
</ber:symbology>
<ber:graphicTypeComponentArray>
<ber:graphicTypeComponent id="gtda_5012102_2" name="Label Line"
roleId="labelLine">
<ber:curveGraphicType>
<ber:symbology>
<ber:lineSymbolizer>
<se:Stroke>
<se:GraphicStroke>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ls_0"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
</se:GraphicStroke>
<se:SvgParameter name="stroke-width">1</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
</ber:symbology>
</ber:curveGraphicType>
</ber:graphicTypeComponent>
<ber:graphicTypeComponent id="gtda_5012102_1" name="DA Text"

Implementation Guide

142

9 – FEATURE SYMBOLOGY
roleId="text">
<ber:textGraphicType>
<ber:symbology>
<ber:textSymbolizer>
<ber:fontHeight>1</ber:fontHeight>
</ber:textSymbolizer>
</ber:symbology>
</ber:textGraphicType>
</ber:graphicTypeComponent>
</ber:graphicTypeComponentArray>
</ber:collectionGraphicType>
</ber:graphicType>
</ber:graphicTypeArray>

•
•

commonSymbolizer – Defines the symbology common for all the collection components.
lineSymbolizer, textSymbolizer – Defines symbologies for collection components. Color and
opacity are taken over from common symbology.

In case of collection graphics in graphic tags, derived symbolizer (derivedSymbolizer) can be used
instead of common symbolizer. It says that the collection color and opacity are taken over from their
feature symbology.



All symbolizers can be defined as hidden (optional Boolean attribute).

Example: Reference to a Collection class Extended dimension.
<ber:featureType id="ft_5031002" name="Extended dimension - simple"
parentId="ft_5030000" abstract="false">
<ber:description>Dimension created by dimensioning tool</ber:description>
<ber:container refId="ct_5030000"/>
<ber:masterGraphics nillable="false">
<ber:class refId="ExtDimension"/>
<ber:collectionGraphicType>
<ber:symbology>
<ber:commonSymbolizer>
<ber:rgbColor>#3F7FFF</ber:rgbColor>
</ber:commonSymbolizer>
</ber:symbology>
<ber:graphicTypeComponentArray>
<ber:graphicTypeComponent id="gt_20" name="Dimension Text">
<ber:textGraphicType>
<ber:symbology>
<ber:textSymbolizer>
<se:Font>
<se:SvgParameter name="font-style">italic</se:SvgParameter>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

143

</se:Font>
<se:Fill>
<se:SvgParameter name="fill">#3F7FFF</se:SvgParameter>
</se:Fill>
<ber:fontHeight>1.5</ber:fontHeight>
</ber:textSymbolizer>
</ber:symbology>
<ber:defaultTextProperties>
<ber:anchorPoint>center-bottom</ber:anchorPoint>
</ber:defaultTextProperties>
</ber:textGraphicType>
</ber:graphicTypeComponent>
<ber:graphicTypeComponent id="gt_30" name="Symbol-arrow">
<ber:pointGraphicType>
<ber:symbology>
<ber:pointSymbolizer>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource
xlink:href="resource.xml#ber_LIDSdemo/50/right-center"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
<ber:rgbColor>#3F7FFF</ber:rgbColor>
<ber:symbolHeight>3</ber:symbolHeight>
</ber:pointSymbolizer>
</ber:symbology>
</ber:pointGraphicType>
</ber:graphicTypeComponent>
<ber:graphicTypeComponent id="gt_10" name="Dimension Line">
<ber:curveGraphicType/>
</ber:graphicTypeComponent>
</ber:graphicTypeComponentArray>
</ber:collectionGraphicType>
</ber:masterGraphics>
...
</ber:featureType>

Implementation Guide

144

9.2

9 – FEATURE SYMBOLOGY

Dynamic Symbology
Dynamic symbology, or in other words thematic mapping, enables dynamic changes of static symbology
according to actual view scale or values of semantic feature attributes. The dynamic symbology is
defined in special metadata file thematization.xml.

9.2.1

Feature type styles
In dynamic symbology every feature type can have any number of feature type styles defined. Feature
type style defines how instances of one feature type are symbolized. The logical model of feature type
style looks like this:

Feature Type Style

Scale Range 1

Semantic Class 1

Attribute Condition 1
FT Symbology 1
DA Symbology 1

Semantic Class N

Attribute Condition N
FT Symbology N
DA Symbology N

Scale Range M

Else Semantic Class
FT Symbology X
DA Symbology X

On the first level, all the possible scales are divided into joined but not overlapping ranges. In every
scale range, features are classified according to their semantic attributes into a set of classes. Every class
is defined by its semantic condition and holds a symbology for the symbolized feature type and
symbologies (optionally) for its graphic tags. In every scale range, a completely different symbology
including completely different classification into semantic classes can be defined. But only one type of
semantic classification is allowed in one scale range.
Features are dynamically symbolized in these steps:
1. First of all, the scale range is chosen according to actual view scale.
2. Only the semantic classes belonging to the chosen scale range are taken into account. The
system tries to classify every feature instance to one of the semantic classes. If it succeeds, the
feature is symbolized with the specified symbology.
3. In case that the feature does not pass through any of the semantic classes conditions, it is
symbolized with so called else class symbology.



If else class symbology is not explicitly defined, the features belonging to the else class are symbolized
with their static symbology.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6
9.2.2

145

Semantic classification
Depending on the types of attribute conditions there are three types of semantic classification allowed.
General classification
General classification allows its classes to define any semantic attributes conditions. The conditions
must be written down in the form of logical addition (OR operation) of logical multiplications (AND
operation) of single attribute conditions. For example:
(material = 'copper' AND length > 3) OR (material = 'aluminum')
The conditions are written in the form of OGC filters in xml metadata.
Discrete classification
Discrete classification classifies features according to any number of its attributes that must have codelist
reference type. Only one equal (= operation) is allowed for every feature attribute in one semantic class.
The logical multiplication (AND operation) of single attribute conditions then defines the resulting class
condition. In other words it is possible to assign different symbology to any combination of discrete
values of codelist reference type attributes.
Interval classification
Interval classification classifies features according one of their attributes that must have decimal data
type. Any class then represents an interval of the attribute possible values.
Combined classification
Combined classification allows to classify features using all of classification methods mentioned above.
For each property can be selected different classification method; the final symbology of the feature
type is a combination of those individual methods.

9.2.3

Themes
Themes are collections of previously discussed feature type styles. Usually, themes group feature type
styles for feature types which are used at the same time. Themes are typically applied to layers
(templates, selection sets) so that it’s not necessary to apply individual feature type styles.


9.2.4

One theme can not incude two feature type styles for the same feature type.

Rules
Here, it is necessary to switch from previously defined logical model to physical structure of xml file.
To adhere to SE standard as much as possible, the above discussed logical model of feature type style
is physically written down in the set of SE rules. Generally, the rule contains both scale and attribute
condition and symbolizers of appropriate types. Still the logical model must be reconstructible from the
rules.

Implementation Guide

146

9 – FEATURE SYMBOLOGY

There are six types of rules:
• Static Rule (staticRule) – Does not contain neither scale nor attribute condition. Just changes feature
type static symbology with another static symbology in a feature type style. Cannot be combined
with any other rule within a feature type style.
• Scale Only Rule (scaleOnlyRule) – Does not contain any attribute condition. Changes symbology
according to view scale only. Cannot be combined with any other rule within a scale range.
• General Rule (rule)– Contains an attribute condition and optionally a scale condition. Used for
general semantic classification. Can be combined only with other general rules within a scale range.
• Discrete Rule (discreteRule)- Contains an attribute condition and optionally a scale condition. Used
for discrete semantic classification. Can be combined only with other discrete rules within a scale
range.
• Interval Rule (intervalRule)- Contains an attribute condition and optionally a scale condition. Used
for interval semantic classification. Can be combined only with other interval rules within a scale
range.
• Combined Rule (combinedRule) – Used for combined semantic classification. Cannot be combined
with any other rule within a scale range. Combined semantic classification is discussed in special
chapter 9.2.6.



The rules must be defined in such way that at most one rule for any feature and view scale is defined.
In the following example, dynamic symbology for feature type Main Pipeline Segment is defined. Three
scale ranges with following classifications are defined:
• Further than 1:2000
Main pipeline segments are not displayed in this scale range at all so scaleOnlyRule with
hiddenScale set to true is used and no symbology is defined.
• From 1:2000 to 1:1000
No semantic classification of main pipeline segments is required in this scale range so
scaleOnlyRule with required symbology is used.
• Closer than 1:1000
Main pipeline segment are symbolized according their lengths (at_5012002) in three classes:
shorter than 5 m, from 5 m to 10 m and longer than 10 m. So interval classification with three
intervalRule elements is defined.
Example: Dynamic symbology definition (thematization.xml).
<ber:featureTypeStyleArray>
<ber:featureTypeStyle>
<se:Name>fs_1</se:Name>
<se:Title>Main Pipeline Segment</se:Title>
<se:Abstract>Main Pipeline Segment</se:Abstract>
<se:FeatureTypeName>ft_5012100</se:FeatureTypeName>
<ber:intervalRule defaultScale="true">
<se:Title>Length[m]: 0-5</se:Title>
<ogc:Filter>
<ogc:PropertyIsLessThanOrEqualTo>
<ogc:PropertyName>at_5012002</ogc:PropertyName>
<ogc:Literal>5</ogc:Literal>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

147

</ogc:PropertyIsLessThanOrEqualTo>
</ogc:Filter>
<se:MaxScaleDenominator>1000</se:MaxScaleDenominator>
<ber:lineSymbolizer>
<se:Stroke>
<se:GraphicStroke>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ls_0"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
</se:GraphicStroke>
<se:SvgParameter name="stroke">#ff0000</se:SvgParameter>
<se:SvgParameter name="stroke-opacity">1.0</se:SvgParameter>
<se:SvgParameter name="stroke-width">1</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
</ber:intervalRule>
<ber:intervalRule defaultScale="true">
<se:Title>Length[m]: 5-10</se:Title>
<ogc:Filter>
<ogc:PropertyIsBetween>
<ogc:PropertyName>at_5012002</ogc:PropertyName>
<ogc:LowerBoundary>
<ogc:Literal>5</ogc:Literal>
</ogc:LowerBoundary>
<ogc:UpperBoundary>
<ogc:Literal>10</ogc:Literal>
</ogc:UpperBoundary>
</ogc:PropertyIsBetween>
</ogc:Filter>
<se:MaxScaleDenominator>1000</se:MaxScaleDenominator>
<ber:lineSymbolizer>
<se:Stroke>
<se:GraphicStroke>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ls_2"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
</se:GraphicStroke>

Implementation Guide

148

9 – FEATURE SYMBOLOGY
<se:SvgParameter name="stroke">#00FF00</se:SvgParameter>
<se:SvgParameter name="stroke-opacity">1.0</se:SvgParameter>
<se:SvgParameter name="stroke-width">2</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
</ber:intervalRule>
<ber:intervalRule defaultScale="true">
<se:Title>Length[m]: 10-&gt;</se:Title>
<ogc:Filter>
<ogc:PropertyIsGreaterThan>
<ogc:PropertyName>at_5012002</ogc:PropertyName>
<ogc:Literal>10</ogc:Literal>
</ogc:PropertyIsGreaterThan>
</ogc:Filter>
<se:MaxScaleDenominator>1000</se:MaxScaleDenominator>
<ber:lineSymbolizer>
<se:Stroke>
<se:GraphicStroke>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ls_3"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
</se:GraphicStroke>
<se:SvgParameter name="stroke">#0000ff</se:SvgParameter>
<se:SvgParameter name="stroke-opacity">1.0</se:SvgParameter>
<se:SvgParameter name="stroke-width">3</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
</ber:intervalRule>
<ber:scaleOnlyRule>
<se:MinScaleDenominator>1000</se:MinScaleDenominator>
<se:MaxScaleDenominator>2000</se:MaxScaleDenominator>
<ber:lineSymbolizer>
<se:Stroke>
<se:GraphicStroke>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ls_0"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

149

</se:GraphicStroke>
<se:SvgParameter name="stroke">#0000ff</se:SvgParameter>
<se:SvgParameter name="stroke-opacity">1.0</se:SvgParameter>
<se:SvgParameter name="stroke-width">4</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
</ber:scaleOnlyRule>
<ber:scaleOnlyRule hiddenScale="true">
<se:MinScaleDenominator>2000</se:MinScaleDenominator>
</ber:scaleOnlyRule>
</ber:featureTypeStyle>
...
</ber:featureTypeStyleArray>
<ber:themeArray>
<ber:theme>
<se:Name>th_3</se:Name>
<se:Title>Main Pipeline – interval+scale</se:Title>
<se:Abstract>Main Pipeline - interval+scale</se:Abstract>
<ber:ftStyleRefs>
<ber:ftStyle refId="fs_1"/>
<ber:ftStyle refId="fs_2"/>
<ber:ftStyle refId="fs_3"/>
</ber:ftStyleRefs>
</ber:theme>
...
</ber:themeArray>

9.2.5

Graphic tags dynamic symbology
Graphic tags can be dynamically symbolized together with their feature types.
Example: Displayable attributes dynamic symbology definition.
<ber:intervalRule id="rule_456_1" name="Length[m]: 0-5">
<ogc:Filter>
<ogc:PropertyIsBetween>
<ogc:PropertyName>at_5012002</ogc:PropertyName>
<ogc:LowerBoundary>
<ogc:Literal>0</ogc:Literal>
</ogc:LowerBoundary>
<ogc:UpperBoundary>
<ogc:Literal>5</ogc:Literal>

Implementation Guide

150

9 – FEATURE SYMBOLOGY
</ogc:UpperBoundary>
</ogc:PropertyIsBetween>
</ogc:Filter>
<ber:lineSymbolizer>
<se:Stroke>
<se:GraphicStroke>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ls_0"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
</se:GraphicStroke>
<se:SvgParameter name="stroke">#ff0000</se:SvgParameter>
<se:SvgParameter name="stroke-opacity">1.0</se:SvgParameter>
<se:SvgParameter name="stroke-width">1</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
<ber:textSymbolizer>
<se:Geometry>
<ogc:PropertyName>ft_5012100_gtda_5012101/gtda_5012101_1
</ogc:PropertyName>
</se:Geometry>
<se:Fill>
<se:SvgParameter name="fill">#FF0000</se:SvgParameter>
</se:Fill>
<ber:fontHeight>2</ber:fontHeight>
</ber:textSymbolizer>
</ber:intervalRule>

In this example, an interval rule for feature type Main Pipeline Segment is defined. Within this rule,
segments shorter than 5 m are symbolized together with their graphic tags (displayable attributes) –
install dates (ft_5012100_gtda_5012101). In contrast to feature type dynamic symbology definition, it
is necessary to identify the graphic tag type and the component type. For this reason, PropertyName
inside Geometry element is present in graphic tag dynamic symbolizer.

9.2.6

Combined semantic classification
Combined semantic classification enables independent resymbolization of particular symbology
properties (i.e. color, opacity, weight, ...) In other words, various semantic classifications (for various
symbology properties) can be combined into one feature type symbolizer. It is possible to modify each
symbology properties according to different semantic attributes and different classification types.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

151

For any symbology property, one of these definitions can be used:
• no change – property is omitted, original static symbology value is used
• new static symbology - new static value replaces original static symbology value
• direct symbology - the value is taken directly from the given feature attribute
• interval classification
• discrete classification
• general classification




If a discrete classification is used in a combined classification, just one attribute can be used. It is a
limitation comparing to the standard discrete classification.

So far it is not possible to use the combined classification for collections and graphic tags.
In the following example, a feature type style with the combined classification is defined:
• in a scale smaller than 1:1000, the feature type is not displayed at all
• in a scale larger than 1:1000, the combined classification is used
• line style is changed according to attribute at_5010007
• general classification is used
• features with the value beginning with 6 are drawn using line style ls_1, the others (elseClass)
use style ls_2
• line color is changed according to attribute at_ 5012003
• discrete classification is used
• color is defined for values 2, 3, 4, 5, 10; for all other values (elseClass), one color is defined
• line width is changed according to at_ 5012102
• interval classification is used
• three classes are defined
• < 6200 bar
• >= 6200 bar to < 6400 bar
• >= 6400 bar
• other symbolizer attributes are not changed – they are defined by a static feature type symbolizer
Example: Combined semantic classification definition.
<ber:featureTypeStyle id="fs_321"
name="Main Pipeline Segment - combined">
<ber:description>Main Pipeline Segment - hide + combined</ber:description>
<se:FeatureTypeName>ft_5012100</se:FeatureTypeName>
<ber:combinedRule id="rule_80000"
name="Material-&gt;color; Pressure-&gt;line-width"
defaultScale="true">
<se:MaxScaleDenominator>1000</se:MaxScaleDenominator>
<ber:lineSymbolizer>
<se:Stroke>

Implementation Guide

152

9 – FEATURE SYMBOLOGY
<se:GraphicStroke>
<se:Graphic>
<se:ExternalGraphic>
<ber:OnlineResource>
<ber:generalClassification>
<!-- line style changed by combined classification -->
<ber:generalClass>
<ogc:Filter>
<ogc:PropertyIsLike wildCard="%" singleChar="_"
escape="\">
<ogc:PropertyName>at_5010007</ogc:PropertyName>
<ogc:Literal>6%</ogc:Literal>
</ogc:PropertyIsLike>
</ogc:Filter>
<ber:value id="fsv_01">resource.xml#ls_1</ber:value>
</ber:generalClass>
<ber:elseClass>
<ber:value id="fsv_02">resource.xml#ls_2</ber:value>
</ber:elseClass>
</ber:generalClassification>
</ber:OnlineResource>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
</se:GraphicStroke>
<se:SvgParameter name="stroke">
<ber:recode fallbackValue="#888888">
<!-- color changed by discrete classification -->
<se:LookupValue>
<ogc:PropertyName>at_5012003/ca_10201</ogc:PropertyName>
</se:LookupValue>
<ber:mapItem>
<ber:data>2</ber:data>
<ber:value id="fsv_11">#FF0000</ber:value>
</ber:mapItem>
<ber:mapItem>
<ber:data>4</ber:data>
<ber:value id="fsv_12">#FF0000</ber:value>
</ber:mapItem>
<ber:mapItem>
<ber:data>5</ber:data>
<ber:value id="fsv_13">#FF0000</ber:value>
</ber:mapItem>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

153

<ber:mapItem>
<ber:data>3</ber:data>
<ber:value id="fsv_14">#00FF00</ber:value>
</ber:mapItem>
<ber:mapItem>
<ber:data>10</ber:data>
<ber:value id="fsv_15">#0000FF</ber:value>
</ber:mapItem>
<ber:elseClass>
<ber:value id="fsv_16">#888888</ber:value>
</ber:elseClass>
</ber:recode>
</se:SvgParameter>
<se:SvgParameter name="stroke-width">
<se:Categorize fallbackValue="1">
<se:LookupValue>
<ogc:PropertyName>at_5012102</ogc:PropertyName>
</se:LookupValue>
<ber:value id="rule_80020">1</ber:value>
<se:Threshold>6200</se:Threshold>
<ber:value id="rule_80021">2</ber:value>
<se:Threshold>6400</se:Threshold>
<ber:value id="rule_80022">3</ber:value>
</se:Categorize>
</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
</ber:combinedRule>
<ber:scaleOnlyRule id="rule_80100" hiddenScale="true">
<se:MinScaleDenominator>1000</se:MinScaleDenominator>
</ber:scaleOnlyRule>
</ber:featureTypeStyle>

•
•

•
•

The metadata notation is based on OGC standard Symbology Encoding (SE) 1.1.0.
elseClass - Defined for each partial general and discrete classification. It makes no sense to define
elseClass for an interval classification. The whole possible range of attribute values is always
covered by a definition.
tresholdsBelongTo - Defines whether the split points belong to a preceding or succeeding (default)
interval.
fallbackValue - In SE specification defined as “a value of a symbolizer attribute which should be
used when the system is not able to evaluate the defined classification”. LIDS does not use this
value. It is preserved because of the compatibility with SE xsd schemes. It cannot be used for our
elseClass rule definition as it cannot have ID.

Implementation Guide

154
9.2.7

9 – FEATURE SYMBOLOGY
Symbology tokens

Symbology tokens are values of already evaluated classifications for feature type styles. Symbology
tokens for individual features are stored in the database, in the feature table. The values of the symbology
tokens are evaluated automatically by LIDS Application server when creating / updating the features.



The tokens are needed by LIDS Application server when rendering the features using dynamic
symbology. Only such dynamic symbologies which are supported by generated symbology tokens can
be used Application server.
The tokens are generated for:
- styles referred as dynamicSymbology in feature type definition in model.xml
- themes which include attribute utilizedForWMS=”true” in thematization.xml
This means, every feature can have symbology tokens from more styles stored in the feature table.



Symbology tokens can be used to optimize dynamic symbology performance also in LIDS Edit /
Explorer clients. LIDS Edit / Explorer clients can evaluate dynamic symbology rules by themselves.
But in such cases it’s necessary for the client to download not only the geometry but also all semantic
attributes in order to be able to evaluate the dynami symbology classification. This is time consuming.
If the symbology tokens exist for particular dynamic symbology definition, client application can apply
the symbology using the symbology tokens directly and it’s not necessary to download also the
attributes. This improves the performance of downloading the graphics significantly.
Following modes of downloading graphics into LIDS Edit / Explorer can occur:
• static symbology – no need to evaluate classification, just the geometry is downloaded to the clients
• dynamic symbology based on symbology tokens – classification is already evaluated, symbology
tokens are downloaded together with the geometry, no semantics is downloaded to the clients
• dynamic symbology without symbology tokens – classification has to be evaluated by the client
application, semantics has to be downloaded to the clients additionally to the geometry

Implementation Guide

Chapter 10
Containers

IMPLEMENTATION GUIDE VERSION 9.6

10.

157

Containers
In this chapter we will describe the database storage of features. In general, there are four main tables
for each feature type for storing semantic, graphic, security and system information in the database.
•
•
•
•



Semantic table – Contains all semantic attributes defined for a group of feature types.
Feature table – Contains all system attributes (Feature Identifier, Semantic Identifier, Update Date,
Updated By,...) and a collection of security attributes.
Graphic table – Contains all required columns for storing graphics.
Graphic tag table – Contains all required columns for storing graphic tags for features.

For more information about database structure see LIDS Database Guide.

10.1 Feature Types with Geometry and Semantics
If a feature type has both semantic attributes and geometry defined, its features are stored in semantic,
feature and graphic tables.

Semantic
sid,at1,at2,at3, ...

Feature
fid,sid,sec1, ...

Graphic
fid,gid,sdo_geom, ...

10.2 Semantic Feature Types without Geometry
If a feature type has a set of semantic attributes and does not have geometry defined (or defined as none),
its features are stored in semantic and feature tables.

Semantic
sid,at1,at2,at3, ...

Feature
fid,sid,sec1, ...

10.3 Geometric Feature Types without Semantics
If a feature type does not contain any attribute – that means that no semantic or security attributes are
defined for the feature type and all his parents, the feature type must have geometry. These feature types
are usually used as some kind of graphic marks. Features of this feature type is stored in feature and
graphic tables.

Feature
fid,sid, ...

Graphic
fid,gid,sdo_geom,...

Implementation Guide

158

10 – CONTAINERS

10.4 Defining Feature Containers
In a LIDS project there are all containers defined in the metamodel. Each feature container definition
includes name, description, dbName and spatialInfo. Feature containers are defined within a
containerArray.
Example: Feature container for Water main features.
<ber:model>
<ber:containerArray>
...
<ber:container id="ct_5040000" name="Water mains"
dbName="W_MAINS">
<ber:description>Water mains</ber:description>
<ber:spatialInfo srs="EPSG:31467" baseUnit="meter">
<ber:range>
<ber:x min="3449000" max="3464400"/>
<ber:y min="5476300" max="5490500"/>
<ber:z min="-150" max="1625"/>
</ber:range>
</ber:spatialInfo>
</ber:container>
...
</ber:containerArray>
</ber:model>

Example: Container with a reference to a group container.
<ber:container id="ct_geo_railway" name="Geo Railway" dbName="GEO_RAILWAY">
<ber:description>Railway container</ber:description>
<ber:groupContainer refId="gc_geography"/>
</ber:container>

Attributes
•
•
•
•

•

id – Unique identifier of a feature container.
name – Name of a feature container.
dbName – Name of a feature container database table.
versioned – Optional parameter. Possible values:
• false – default. No versioning is activated
• history - changes are recorded for keeping history
• longTransaction - changes are done in long transaction mode
measure – Boolean. If true, graphical table stores also m-coordinate of individual vertexes.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

159

Inner elements
•
•

•

description – Description of a feature container.
spatialInfo – Optional definition. If not defined, project spatialInfo is applied – see spatialInfo
chapter. Individual containers can define different tolerance and range. baseUnit and srs should be
the same for all containers and for the project. The range has to cover all geometries in a container.
It’s not possible to store a geometry which exceeds the range. Still, the range value should be set
reasonably according to project data. If set too large, many spatial operations don’t work correct. If
z range is defined, also z coordinates are stored for features in this container, enabling 3D
functionality
groupContainer – Reference to a group container.

10.5 Referring Feature Containers
Each non-abstract feature type must refer a feature container itself or it must have such ancestor. Then
the subordinate feature type inherits the feature container from its ancestor.
Example: The feature container is usually referred as follows.
<ber:model>
<ber:featureTypeArray>
...
<ber:featureType id="ft_5040000" name="Water mains"
parentId="ft_5000002" abstract="false">
<ber:description>Water mains</ber:description>

<ber:container refId="ct_5040000"/>

...
</ber:featureType>
...
</ber:featureTypeArray>
</ber:model>



In the previous example, there is Water mains feature type defined with features stored in W_MAINS
feature container. In the database there are four container tables:
•
•
•
•

W_MAINS – semantic table
W_MAINS_F – feature table
W_MAINS_GR – graphic table
W_MAINS_GT – table for graphic tags

10.6 Group Containers
In LIDS there is a possibility to group feature containers. It is possible to group feature and graphic
tables into one bigger table – group container. One big container table is usually faster for querying than
querying many smaller tables.

Implementation Guide

160



10 – CONTAINERS

Which feature types will be grouped into which group containers is really the project designer choice.
Any feature types can be grouped together, but usually there is a good practice to group together feature
types that will be often displayed together. Good idea is to group features for a LIDS 6 category.
The definition of group containers precede the definition of containers in a project model.
Example: Water group container defined. Several feature containers are grouped into this Water group
container.
<ber:model>
<ber:groupContainerArray>
<ber:groupContainer id="gc_5010000" name="Water"
dbName="W__GROUP" versioned="true">
<ber:description>Water group container</ber:description>
<ber:spatialInfo srs="EPSG:31467" baseUnit="meter">
<ber:range>
<ber:x min="3449000" max="3464400"/>
<ber:y min="5476300" max="5490500"/>
<ber:z min="-11034" max="8848"/>
</ber:range>
</ber:spatialInfo>
</ber:groupContainer>
...
</ber:groupContainerArray>

<ber:containerArray>
<ber:container id="ct_5010001" name="Pumping station"
dbName="W_PUMPSTAT">
<ber:description>Pumping station</ber:description>
<ber:groupContainer refId="gc_5010000"/>
</ber:container>

<ber:container id="ct_5010002" name="Extraction point"
dbName="W_EXTRPOINT">
<ber:description>Extraction point</ber:description>
<ber:groupContainer refId="gc_5010000"/>
</ber:container>

<ber:container id="ct_5010003" name="Pipeline"
dbName="W_PIPELINE">
<ber:description>Pipeline</ber:description>
<ber:groupContainer refId="gc_5010000"/>
</ber:container>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

161

<ber:container id="ct_5010005" name="Hydrant" dbName="W_HYDRANT">
<ber:description>Hydrant</ber:description>
<ber:groupContainer refId="gc_5010000"/>
</ber:container>

<ber:container id="ct_5010004" name="Protection pipeline"
dbName="W_PROTPIPE">
<ber:description>Protection pipeline</ber:description>
<ber:groupContainer refId="gc_5010000"/>
</ber:container>
</ber:containerArray>
...
<ber:featureTypeArray>
<ber:featureType id="ft_5010100" name="Pumping station"
parentId="ft_5010000" abstract="false">
<ber:description>Pumping station</ber:description>
<ber:container refId="ct_5010001"/>
...
</ber:featureType>
...
<ber:featureType id="ft_5010200" name="Extraction point"
parentId="ft_5010000" abstract="false">
<ber:description>Extraction point</ber:description>
<ber:container refId="ct_5010002"/>
...
</ber:featureType>
...
</ber:featureTypeArray>
</ber:model>

Attributes
•
•
•
•

•

id – Unique identifier of a group container.
name – Name of a group container.
dbName – Name of a group container database table.
versioned – Optional parameter. Possible values:
• false – default. No versioning is activated
• history – changes are recorded for keeping history. Value true can still be used because of
backwards compatibility and has same meaning
• longTransaction - changes are done in long transaction mode
measure – Boolean. If true, graphical table stores also m-coordinate of individual vertexes.

Implementation Guide

162

10 – CONTAINERS

Inner Elements
•
•

description – Contains a detailed description of the group container.
spatialInfo – Definition of reference system and units – see description in chapter describing
containers definition.

Implementation Guide

Chapter 11
Categories and Groups

IMPLEMENTATION GUIDE VERSION 9.6

11.

165

Categories and Groups
It’s useful to organize individual metadata items into some groups in some cases. This makes the
working with the application simpler for the end user while the system still works with the individual
items in the background.
The possible metadata groupingways include categories and groups.

11.1 Categories
Categories are collections of feature types that make working with feature types easier. The feature type
grouping in categories is quite loose, one feature type may belong to any number of categories including
zero. Furthermore, categories can be arranged in a tree structure. Such organization enables to logically
categorize feature types according to various aspects, which results in effective feature type handling.



The category tree does not represent inheritance in any sense, it is really just logical feature types
organization. Also inclusion of feature type in the category is not inherited through feature type
hierarchy.
Categories definitions are grouped together in the categoryArray collection.
Example: Definition of categories.
<ber:categoryArray>

<!-- Root level category -->
<ber:category id="cat_5010000" name="Water-supply network">
<ber:description>Water-supply network</ber:description>
<ber:featureIdArray>
<ber:item refId="ft_5040000"/>
<ber:item refId="ft_5010200"/>
<ber:item refId="ft_5012200"/>
<ber:item refId="ft_5011200"/>
<ber:item refId="ft_5012100"/>
<ber:item refId="ft_5011100"/>
<ber:item refId="ft_5012300"/>
<ber:item refId="ft_5020000"/>
<ber:item refId="ft_5010100"/>
</ber:featureIdArray>
</ber:category>

<!-- Another root level category -->
<ber:category id="cat_5020000" name="Electrical network">
<ber:description>Electrical network</ber:description>
<ber:featureIdArray>

Implementation Guide

11 – CATEGORIES AND GROUPS

166

<ber:item refId="ft_5020000"/>
<ber:item refId="ft_5090000"/>
</ber:featureIdArray>
</ber:category>

<!-- The electrical network subcategory -->
<ber:category id="cat_5023000" name="High voltage" parentId="cat_5020000">
<ber:description>High voltage</ber:description>
<ber:featureIdArray>
<ber:item refId="ft_5020000"/>
</ber:featureIdArray>
</ber:category>

<!-- Another electrical network subcategory -->
<ber:category id="cat_5022000" name="Low voltage" parentId="cat_5020000">
<ber:description>Low voltage</ber:description>
<ber:featureIdArray>
<ber:item refId="ft_5020000"/>
</ber:featureIdArray>
</ber:category>
...
</ber:categoryArray>

•
•
•

category – Single category definition.
parentId – References its super category in the category hierarchy. Optional.
featureIdArray – Collection of item elements, i.e. feature types contained in this category.

11.2 Backdrop Categories
Categories of backdrops have similar functionality as ordinary categories. The categories again do not
represent inheritance in any sense, it is really just logical backdrops organization that make working
with backdrops easier. Also inclusion of backdrop in the category is not inherited through backdrop
hierarchy. Backdrop categories definitions are grouped together in the backdropCategoryArray
collection.
Attributes
•
•
•

id – Unique identifier of a backdrop category.
name – Name of a backdrop category.
parentId – References its super category in the backdrop category hierarchy. Optional.

Inner Elements
•
•

description – Contains a detailed description of the group container.
backdropTypeIdArray – Collection of item elements, i.e. backdrop types contained in this category.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

167

Example: Backdrop category structure.
<ber:backdropCategoryArray>
<ber:backdropCategory id="cat_vicinity" name="Vicinities">
<ber:description>Vicinity backdrops</ber:description>
<ber:backdropTypeIdArray>
<ber:item refId="bd_04"/>
<ber:item refId="bd_05"/>
</ber:backdropTypeIdArray>
</ber:backdropCategory>
</ber:backdropCategoryArray>

11.3 Groups
Groups are more general than categories. While categories are limited to feature types only, groups can
contain feature types, codelists, associations and reports.
Individual metadata items are assigned to groups by specifying particular group id at the particular
metadata item definition directly. There is no explicit definition of groups. List of all groups is
dynamically generated by selecting all distinct group references from metadata.
Example: Assigining codelist to two groups.
<ber:codeList dbName="A" id="cl_1" name="Abc">
<ber:description>XYZ</ber:description>
<ber:groupsArray>
<ber:group id="group_1"/>
<ber:group id="group_2"/>
</ber:groupsArray>
<ber:columnArray>
…

Example: Assigining feature type to two groups.
<ber:featureType id="ft_1" name="Abc">
<ber:groupsArray>
<ber:group id="group_1"/>
<ber:group id="group_2"/>
</ber:groupsArray>
<ber:container refId="ct_1"/>
<ber:featureAttributeArray>
…

Implementation Guide

168

11 – CATEGORIES AND GROUPS

Example: Assigining association to two groups.
<ber:relationAssoc dbName="R_A" id="r_1" name="Abc">
<ber:groupsArray>
<ber:group id="group_1"/>
<ber:group id="group_2"/>
</ber:groupsArray>
<ber:srcRole refId="rt_1"/>
<ber:destRole refId="rt_2"/>
</ber:relationAssoc>





Some groups don’t have to be explicitly defined in project metadata. Such so called “system groups”
are generated dynamically by the system according to some other configuration. Example of such system
group: group search includes all feature types included in search.xml, group collaboration-comments
includes feature types from collaboration.xml.

Assigning parent feature type to a group means all its child feature types are assigned to the group as
well.

Content of one or more groups can be evaluated by executing following REST request (individual
groups separated by comma):
http://server:port/project/rest/metadata/group/business,collaboration-comments,search

Implementation Guide

Chapter 12
Backdrop Maps

IMPLEMENTATION GUIDE VERSION 9.6

12.

171

Backdrop Maps
Backdrop maps are auxiliary graphic data lying under the graphic presentation of the active data –
features. They can be both vectors and rasters (special case of raster backdrop is
binaryRasterBackdropType). Every backdrop map has its definition (backdrop type) in the metadata.
Every backdrop map can be provided in various formats and structures, so called layers. The definitions
are grouped together in backdropTypeArray collection.
General structure of backdrop is:
Attributes
•
•
•
•

id – Unique identifier of a backdrop.
name – Name of a backdrop.
versioned – Boolean. If true, it is used for recording changes and for „creating history“.
colorModelType="rgb/rgba/greyscale/palette". If specified, only rasters having this color model
may be inserted into the layer.

Inner Elements
•
•
•
•
•

description – Contains a detailed description of the group container.
featureType – Reference to a related feature type.
layerArray – Type of backdrop layer (mainTilledLayer/tilledLayer/plainLayer for raster backdrop,
tilledLayer/plainLayer for vector backdrop).
symbology – For example color and opacity of backdrop.
dynamicSymbology – Reference to symbology in thematization.xml.

Example: Structure of a backdrop type.
<ber:vectorBackdropType id="bd_01" name="Overview map" versioned="true">
<ber:description>More detailed vector backdrop</ber:description>
<ber:layerArray>
<ber:tiledLayer id="lay_bd_01_dgn" name="DGN overview map" format="dgn"/>
<ber:tiledLayer id="lay_bd_01_dwg" name="DWG overview map" format="dwg"/>
</ber:layerArray>
</ber:vectorBackdropType>

12.1 Vector Backdrop Maps
Vector backdrop types can have several vector layers. Supported formats for vector files are DGN,
DWG, DXF, SHP and SVG. Vector layers can by only tiled, which means that the layer is represented
by files covering a specified area using the tile structure. Tiles are of various sizes and can overlap. Tiles
of a particular layer need not create a continuous coverage.
Each backdrop map definition can specify its symbology. It can be either static (the same for all scales)
or dynamic (allows define visibility for scales and symbology according to element properties for vector
backdrop maps). Every backdrop type can define one default static and one default dynamic symbology.

Implementation Guide

12 – BACKDROP MAPS

172

While the static symbology is the part of the backdrop map definition, the dynamic symbology refers
special LIDS metadata section (in thematization.xml).
Example: Vector backdrop map definition.
<ber:backdropTypeArray>
<!-- More detailed vector backdrop -->
<ber:vectorBackdropType id="bd_01" name="Overview map">
<ber:description>More detailed vector backdrop</ber:description>
<ber:layerArray>
<ber:tiledLayer id="lay_bd_01_dgn" name="DGN overview map"
format="dgn"/>
<ber:tiledLayer id="lay_bd_01_dwg" name="DWG overview map"
format="dwg"/>
</ber:layerArray>
<!—Static symbology -->
<ber:simpleVectorSymbolizer>
<se:Opacity>0.5</se:Opacity>
</ber:simpleVectorSymbolizer>
<!—Reference to the dynamic symbology -->
<ber:dynamicSymbology xlink:href="thematization.xml#bs_01" />
</ber:vectorBackdropType>
...
</ber:backdropTypeArray>

12.1.1

Dynamic symbology
Dynamic symbology is defined in the thematization.xml metadata part. It consists of 2 parts:
• visibility based on the scales (optional) – if not set it is visible
• symbology (common for all scales)
• simple symbolizer (color and / or transparency) used for all elements
• symbology based on classification according element properties
Example: Vector backdrop dynamic symbology (part of thematization.xml).
<ber:vectorBackdropStyle id="bs_01" name="Colored by level and geometry type">
<!—Visibility according to scales -->
<ber:scaleRules hiddenDefault="false">
<ber:scaleOnlyRule hiddenScale="true">
<se:MinScaleDenominator>500</se:MinScaleDenominator>
<se:MaxScaleDenominator>2000</se:MaxScaleDenominator>
</ber:scaleOnlyRule>
</ber:scaleRules>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

173

<!— Classification rules -->
<ber:vectorRule id="bs_01_r1" name="Shape in STREET level">
<ogc:Filter>
<ogc:PropertyIsEqualTo>
<ogc:PropertyName>element.level</ogc:PropertyName>
<ogc:Literal>Street</ogc:Literal>
</ogc:PropertyIsEqualTo>
</ogc:Filter>
<ber:polygonSymbolizer>
<ber:fill>
<ber:fillStyle>none</ber:fillStyle>
</ber:fill>
<se:Stroke>
<se:SvgParameter name="stroke">#0000FF</se:SvgParameter>
</se:Stroke>
</ber:polygonSymbolizer>
</ber:vectorRule>
<ber:vectorRule id="bs_01_r2" name="Cells are replaced by symbol">
<ogc:Filter>
<ogc:PropertyIsEqualTo>
<ogc:PropertyName>element.type</ogc:PropertyName>
<ogc:Literal>Cell</ogc:Literal>
</ogc:PropertyIsEqualTo>
</ogc:Filter>
<ber:pointSymbolizer>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource
xlink:href="resource.xml#ber_LIDSdemo/66/center-center" />
<se:Format />
</se:ExternalGraphic>
</se:Graphic>
<ber:rgbColor>#00FF00</ber:rgbColor>
<ber:symbolHeight>4</ber:symbolHeight>
</ber:pointSymbolizer>
</ber:vectorRule>
</ber:vectorBackdropStyle>

•
•

PropertyName: These values are supported: file.format, element.type, element.level, element.color,
line.style, line.weight, font.name, cell.name
Literal – Possible values in case of PropertyName = element.type: Point, Ellipse, EllipseArc, Line,
Polyline, Multiline, Polygon, Spline, Text, TextNode, LineString, ComplexString, Dimension,
Shape, ComplexShape, Cell.

Implementation Guide

174

12 – BACKDROP MAPS

12.2 Raster Backdrop Maps
Raster backdrop type can have several layers. Each layer has format and structure. Supported raster
formats are TIFF, JPEG, PNG, CIT, COT, HMR, BMP and GIF. Raster backdrop layers can have tiled
(main tiled), hierarchical or plain structure.



If raster backdrop type contains monochromatic raster files only it should be defined as a special type
of backdrop type - binaryRasterBackdropType. It allows to define color and transparency for both
foreground and background.

Example: Raster backdrop map definition.
<ber:backdropTypeArray>
<ber:rasterBackdropType id="bd_02" name="Orthophoto">
<ber:description>Hierarchical orthophoto raster</ber:description>
<ber:layerArray>
<ber:mainTiledLayer id="lay_bd_02_tiff" name="TIFF Orthophoto"
format="tiff">
<ber:hierarchicalLayer id="lay_bd_02_jpeg" name="JPEG Orthophoto"
format="jpeg">
<ber:hierarchy decreaseRatio="3"
tileWidth="1000"
tileHeight="1000"/>
</ber:hierarchicalLayer>
</ber:mainTiledLayer>
</ber:layerArray>
</ber:rasterBackdropType>
<ber:rasterBackdropType id="bd_10" name="External WMS">
<ber:description>Germany GNU FDL/PGL</ber:description>
<ber:layerArray>
<ber:plainLayer id="lay_bd_10_png" name="PNG External WMS"
format="png"/>
</ber:layerArray>
</ber:rasterBackdropType>
<ber:binaryRasterBackdropType id="bd_06" name="Monochromatic city map">
<ber:description>Monochromatic city map</ber:description>
<ber:layerArray>
<ber:mainTiledLayer id="lay_bd_06_tif" name="TIFF" format="tiff" />
<ber:tiledLayer id="lay_bd_06_cit" name="CIT Layer" format="cit" />
</ber:layerArray>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

175

<ber:symbology>
<ber:binaryRasterSymbolizer>
<ber:foreground>
<ber:rgbColor>#00FF00</ber:rgbColor>
</ber:foreground>
<ber:background>
<ber:rgbColor>#005500</ber:rgbColor>
<se:Opacity>0.4</se:Opacity>
</ber:background>
</ber:binaryRasterSymbolizer>
</ber:symbology>
</ber:binaryRasterBackdropType>
</ber:backdropTypeArray>

Tiled, main tiled layers
The layer is represented by files covering a specified area using the tile structure. Tiles are of various
sizes and can overlap. Tiles of a particular layer need not create a continuous coverage. This structure
is used always after importing backdrop maps. The raster backdrop type with tiled layers has to have
just one main tiled and can contain one or more tiled layers.
Hierarchical layers
The layer is represented by files which cover the particular area in the hierarchy of various details. The
structure is very efficient for displaying large amount of raster data. When user works with large area,
the rough data (the pyramid top) is displayed. When zooming in, the rough data is replaced by more and
more detailed data (the pyramid base). The pyramidal structure is built from original data (main tiled
layer) by the LIDS Application Server. The structure has several parameters that define the size of tiles,
number of levels and the overall size of hierarchical layer:
• tileWidth – width of a single tile in a hierarchy (recommended value is 1024 px)
• tileHeight – height of a single tile in a hierarchy (recommended value is 1024 px)
• decreaseRatio – number of subordinate tiles in X axis which is the superior tile generated from
(recommended values is 3 or 4)
Plain layers
As a user works, the required areas of plain raster backdrop are generated by LIDS AS on the fly. The
plain layer is usually used when WMS data are defined as a project backdrop type.
• maxSize – Maximum pixel size of returned image (optional) – parameters width and height.
• maxParallelRequests – Maximum number of requests a single client can execute in parallel.

Implementation Guide

176
12.2.1

12 – BACKDROP MAPS
Dynamic symbology

Dynamic symbology is defined in the thematization.xml metadata part. It consists of 2 parts:
• visibility based on the scales (optional)
• symbology (common for all scales)
Example: Raster backdrop dynamic symbology (part of thematization.xml).
<ber:rasterBackdropStyle id="bts_201" name="Semitransparent raster">
<ber:rasterSymbolizer>
<se:Opacity>0.5</se:Opacity>
</ber:rasterSymbolizer>
</ber:rasterBackdropStyle>
<ber:binaryRasterBackdropStyle id="bts_301" name="Gray foreground">
<ber:binaryRasterSymbolizer>
<ber:foreground>
<ber:rgbColor>#AAAAAA</ber:rgbColor>
</ber:foreground>
</ber:binaryRasterSymbolizer>
</ber:binaryRasterBackdropStyle>

12.3 Backdrop feature / attributes
It’s possible to define a feature type reference as part of backrop type definition. In this case, the feature
type is used to store additional attributes of individual backdrop files. Features of this type shouldn’t be
accessed / edited using standard functionality. They are created / edited / deleted using the mechanism
of backrop maps. When a backdrop file is created, the corresponding feature is generated as well. The
GUI for working with the attributes depends on capabilities of individual client applications.




Feature type referenced from the backdrop type definition should define it’s own history. The feature
shouldn’t be stored in the versioned container.

Feature type referenced from the backdrop type definition has to be defined in separate feature types
hierarchy. All master feature types of such feature type are considered as backdrop feature types as well
and are hidden for the standard functionalities in LIDS clients.

Implementation Guide

Chapter 13
Overview Maps

IMPLEMENTATION GUIDE VERSION 9.6

13.

179

Overview Maps
Overview maps are auxiliary graphic data enabling orientation in the geographic space of the project.
Any number of overview maps can be defined in one project. In fact, an overview map is a set of
backdrop maps with a spatial restriction. Different spatial areas of the same backdrop map may, thus,
represent different overview maps within a project. The overview maps definitions are grouped together
in the vicinityMapArray collection.
Example: Overview maps definition.
<ber:vicinityMapArray>
<!-- Base simple overall vicinity -->
<ber:vicinityMap id="vi_01" name="Vicinity" default="true">
<ber:description>Vicinity</ber:description>
<ber:range>
<ber:x min="3449000" max="3464400"/>
<ber:y min="5476300" max="5490500"/>
</ber:range>
<ber:backdropTypeRefs>
<ber:backdropType refId="bd_04"/>
</ber:backdropTypeRefs>
</ber:vicinityMap>

<!-- More detailed overall overview map -->
<ber:vicinityMap id="vi_02" name="Overviewmap" default="false">
<ber:description>Overviewmap</ber:description>
<ber:range>
<ber:x min="3449000" max="3464400"/>
<ber:y min="5476300" max="5490500"/>
</ber:range>
<ber:backdropTypeRefs>
<ber:backdropType refId="bd_01"/>
</ber:backdropTypeRefs>
</ber:vicinityMap>

<!-- More detailed overview map of the restricted area -->
<ber:vicinityMap id="vi_03" name="Overviewmap - zoom" default="false">
<ber:description>Overviewmap - zoom</ber:description>
<ber:range>
<ber:x min="3450893" max="3452167"/>
<ber:y min="5481584" max="5482714"/>
</ber:range>

Implementation Guide

180

13 – OVERVIEW MAPS
<ber:backdropTypeRefs>
<ber:backdropType refId="bd_01"/>
</ber:backdropTypeRefs>
</ber:vicinityMap>

<!-- Raster map of the restricted area -->
<ber:vicinityMap id="vi_04" name="Citymap - zoom" default="false">
<ber:description>Citymap - zoom</ber:description>
<ber:range>
<ber:x min="3450893" max="3452167"/>
<ber:y min="5481584" max="5482714"/>
</ber:range>
<ber:backdropTypeRefs>
<ber:backdropType refId="bd_03"/>
</ber:backdropTypeRefs>
</ber:vicinityMap>
</ber:vicinityMapArray>

•
•
•

default – Defines whether the given overview map is used by default. At most one overview map
can be set as default.
range – Restricts the extent of an overview map, the use is not obligatory.
backdropTypeRefs – References the set of backdrop maps.

Implementation Guide

Chapter 14
Attachments

IMPLEMENTATION GUIDE VERSION 9.6

14.

183

Attachments
Each feature type can define one or more references to attachment. Attachment can be referenced to no
more than one feature type. Possibility of having an attachment is inherited from parent feature type to
child.
Attributes
•
•
•
•
•
•

id – Unique identifier of an attachment.
name – Name of an attachment.
storage – This attribute specifies storage type of an attachment. It can be either 'database' or
'filesystem'.
secured – Specifies whether or not the access rights are applied for an attachment.
georeferenced – Identifies whether or not the attachment contains geographical location.
userLink – Value comes from list: 'required'; 'optional'; 'prohibited'.

Inner Elements
•
•

description – Contains a detailed description of the attachment.
featureType – With attribute refId to set a related feature type for the attachment type. Optional.

Example: Attachment type definition.
<ber:attachmentTypeArray>
<ber:attachmentType id="att_pumpingstation_e" name="Pumping station - exterior"
storage="database" secured="false">
<ber:description>Picture of pumping station exterior</ber:description>
</ber:attachmentType>
<ber:attachmentType id="att_pumpingstation_i" name="Pumping station - interior"
storage="database" secured="true">
<ber:description>Picture of pumping station interior</ber:description>
</ber:attachmentType>
<ber:attachmentType id="att_pumpingstation_f" name="Pumping station - file
system geo" storage="filesystem" secured="false" georeferenced="true"
userLink="prohibited">
<ber:description>Georeferenced picture of pumping station stored on
application server file system</ber:description>
</ber:attachmentType>
<ber:attachmentType id="att_pumpingstation_l" name="Pumping station - link"
storage="database" secured="false" georeferenced="false" userLink="required">
<ber:description>Link attachment type</ber:description>
</ber:attachmentType>
<ber:attachmentType id="att_general_d" name="General attachment - DB, geo"
storage="database" secured="false" georeferenced="true">
<ber:description>Stored in the database, georeferenced</ber:description>
<ber:featureType refId="ft_g_attachment"/>
</ber:attachmentType>

Implementation Guide

184

14 – ATTACHMENTS

<ber:attachmentType id="att_general_f_att" name="General attachment - FS + att"
storage="filesystem" georeferenced="true">
<ber:description>Georeferenced picture with attributes stored on application
server file system</ber:description>
<ber:featureType refId="ft_g_attachment"/>
</ber:attachmentType>
</ber:attachmentTypeArray>

14.1 Versioning attachments
The attachments can maintain historical versions. New versions are generated automatically when
updating an attachment, with the possibility to enter the description of every version.
Whether an attachment type is versioned or not depends on the master feature type definition. So, if a
feature type is defined as versioned, its attachments are versioned as well.




Versioning is possible only for attachment type with storage="database". Versioning is not possible
for attachment type with storage="filesystem".

Historical versions of attachments are stored in LIDS_DOCUMENT_H table. The names / labels of the
versions are stored in LIDS_DOC_VERSION table. In current functionality the cardinality between
these tables is 1:1. But theoretically there can be more records in the LIDS_DOCUMENT_H table
related to one labelled version in LIDS_DOC_VERSION.

Implementation Guide

Chapter 15
Displayable Attributes

IMPLEMENTATION GUIDE VERSION 9.6

15.

187

Displayable Attributes
Displayable attributes (DA) are auxiliary graphic texts attached to graphic features. They are derived
from other feature data, either semantic attributes or graphic representation. The derivation rule is part
of the displayable attribute definition. They use the framework of graphic tags. It means that their
graphics (geometry + symbology) is defined in a standard way in model.xml and thematization.xml as
described before. On the other hand, the special definitions for active manipulation with displayable
attributes have the special metadata part in option.xml.
In the following examples, there is a procedure of defining the displayable attribute:
1. it is necessary to define the graphic type class
2. graphic type is defined with the reference to the graphic type class
3. graphic tag of particular feature type is defined referring graphic type
4. the displayable attribute itself is defined in option.xml referencing to model.xml.
Example: Definition of graphic type class.
<ber:graphicTypeClassArray>
<ber:graphicTypeClass id="DA" name="Displayable attribute">
<ber:description>Displayable attributes, graphic tag</ber:description>
</ber:graphicTypeClass>
…
</ber:graphicTypeClassArray>

Only one common graphic type class for all displayable attributes of a project is defined.
Id has to be “DA”, name and description are up to the project designer.
Example: Definition of graphic type.
<ber:graphicType id="gtda_5012102" name="DA labelline frame-outline">
<ber:class refId="DA"/>
<ber:collectionGraphicType>
<ber:symbology>
<ber:commonSymbolizer>
<ber:rgbColor>#1C32FF</ber:rgbColor>
</ber:commonSymbolizer>
</ber:symbology>
<ber:graphicTypeComponentArray>
<ber:graphicTypeComponent id="gtda_5012102_2" name="Label Line"
roleId="labelLine">
<ber:curveGraphicType>
<ber:symbology>
<ber:lineSymbolizer>
<se:Stroke>
<se:SvgParameter name="stroke-width">1</se:SvgParameter>
</se:Stroke>

Implementation Guide

188

15 – DISPLAYABLE ATTRIBUTES
</ber:lineSymbolizer>
</ber:symbology>
</ber:curveGraphicType>
</ber:graphicTypeComponent>

<ber:graphicTypeComponent id="gtda_5012102_1" name="DA Text"
roleId="text">
<ber:textGraphicType>
<ber:symbology>
<ber:textSymbolizer>
<ber:fontHeight>1</ber:fontHeight>
<ber:mask>
<ber:style>outline</ber:style>
</ber:mask>
</ber:textSymbolizer>
</ber:symbology>
<ber:defaultTextProperties>
<ber:anchorPoint>left-top</ber:anchorPoint>
</ber:defaultTextProperties>
</ber:textGraphicType>
</ber:graphicTypeComponent>
</ber:graphicTypeComponentArray>
</ber:collectionGraphicType>
</ber:graphicType>

Example: Definition of graphic tag type
<ber:graphicTagTypeArray>
<ber:graphicTagType id="gtda_mps_01" name="DA - Install date" drawPriority="-40">
<ber:description>Main pipeline segment - install date</ber:description>
<ber:graphics refId="gtda_5012102"/>
<ber:graphicTagType id="gtda_mps_02" name="DA - Description" drawPriority="-50">
<ber:description>Main pipeline segment - description</ber:description>
<ber:graphics refId="gtda_5012102"/>
</ber:graphicTagType>
<ber:graphicTagTypeArray>

Graphic tag type definition is part of feature type definition. More graphic tag types can be based on the
same graphic type definition.
Example: Displayable attribute definition (option.xml). It defines a displayable attribute – description
for main pipeline segments. Its instance can look like this:

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

189

<ber:displayableAttributeArray>
<ber:displayableAttribute id="da_5012102" name="W_DA_5012102">
<ber:graphicTagRefArray>
<ber:graphicTag xlink:href="model.xml# gtda_mps_01"/>
</ber:graphicTagRefArray>
<ber:daQuery>
<ber:simpleQuery>
<ber:attributeArray>
<ber:attribute xpath="at_5012100_diameter/ca_10502"/>
<ber:attribute xpath="at_5012002"/>
<ber:attribute xpath="at_5012003/ca_10202"/>
</ber:attributeArray>
<ber:format>{0}mm {1}m\n{2}</ber:format>
</ber:simpleQuery>
</ber:daQuery>
<ber:daAutoConstruction>
<ber:position ignoreMasterRotation="true">
<ber:distance>
<ber:dX>-1.5</ber:dX>
<ber:dY>-1</ber:dY>
</ber:distance>
<ber:lineMasterPoint lengthwise="centerPoint"
perpendicular="centerLine"/>
</ber:position>
<ber:angleFromMaster/>
<ber:legibility>false</ber:legibility>
<ber:labelLine/>
</ber:daAutoConstruction>
</ber:displayableAttribute>
...
</ber:displayableAttributeArray>

The displayable attribute definition contains the following information:
• id – Unique identifier of a displayable attribute type.
• name – Name of a displayable attribute type.
Implementation Guide

190
•
•
•

•



15 – DISPLAYABLE ATTRIBUTES
description – Description of a displayable attribute type.
graphicTagRefArray – References to graphic tag types that represent this displayable attribute type.
daQuery – Represents the query used for deriving displayable attribute value. Similarly to derived
feature attributes, it can contain simpleQuery or geometryQuery. Furthermore, multiLineQuery can
be used here; it is discussed in the following part.
daAutoConstruction – Optional definition of construction parameters; they are used only in case of
automatic generation of displayable attributes in bulk:
position – The dX, dY distance from the master graphic master point can be defined. For line
master graphic, the lineMasterPoint can be defined. The possible lengthwise positions are
startPoint, centerPoint, endPoint; the possible perpendicular positions are centerLine and
borderLine.
If ignoreMasterRotation attribute is set to true, the distance in the X box is determined in the
direction which is given by rotation of the point/text control feature or orientation of the segment
of the line control feature in the location of the reference point. The distance in the Y box is
determined in a perpendicular direction.
rotation – The default rotation is defined in graphic type definition. Here it can be redefined for
point and curve master graphics by switching angleFromMaster or anglePlus90 on. Optional
legibility element can disable the preserving of the legibility from bottom / right by allowing the
text to be placed upside down.
label line – For displayable attributes with label line component defined, the construction
including the label line can be set on.

You can use similar functions like in case of derived attributes, including geometric (see chapter 4.5.3).

15.1 Multiline Displayable Attributes
It is possible to join information from subordinate features (associated by 1:n relation) to one displayable
attribute. In this case, it usually has more lines so it is called multiline displayable attribute. Generally,
multiline displayable attributes consist of two parts. First part defines the first line – information from
master feature. The second part defines the subsequent lines of a displayable attribute. They are gathered
from subordinate features. Each part contains its definition for deriving and formating values.



As illustrated in the previous chapter, the simple displayable attribute can have more lines as well. So
the number of lines is not the main difference between simple and multiline displayable attributes.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

191

Example: Multiline displayable attributes definition. Consists of the main identification followed by
list of subordinate valves. Its instance can look like this:

<ber:displayableAttribute id="da_5012103" name="W_DA_5012103">
<ber:graphicTagRefArray>
<ber:graphicTag xlink:href="model.xml#ft_5012100_gtda_5012103"/>
</ber:graphicTagRefArray>
<ber:daQuery>
<!-- Define value and format of the first line -->
<ber:simpleQuery>
<ber:attributeArray>
<ber:attribute xpath="at_5010007"/>
</ber:attributeArray>
<!-- Main identification: -->
<ber:format>{0}: </ber:format>
</ber:simpleQuery>
<!-- Define values and format of subsequent lines -->
<ber:multiLineQuery>
<ber:attributeArray>
<ber:attribute xpath="at_5010007"/>
<ber:attribute xpath="at_5011101/ca_10602"/>
</ber:attributeArray>
<!-- Valve Identification – Valve Type -->
<ber:format>{0} - {1}</ber:format>
<!-- Main and valves are joined by relation sr_5012100_5011100 ->
<ber:relationAssoc xlink:href="model.xml#sr_5012100_5011100"/>
<!-- One subsequent feature per line -->
<ber:lineFormat maxChars="50" maxLines="3">{0}\r\n</ber:lineFormat>
</ber:multiLineQuery>
</ber:daQuery>
</ber:displayableAttribute>

Implementation Guide

192

15 – DISPLAYABLE ATTRIBUTES

The multiline displayable attribute definition is similar to simple displayable attribute definition:
• simpleQuery – The same structure as for simple displayable attribute; here it defines the first line
of the displayable attribute.
• multiLineQuery – Defines the subsequent lines of the displayable attribute; it is about subordinate
features.
• relationAssoc – Relation that connects subordinate features to master feature.
• lineFormat – Auxiliary formatting definition. Maximal number of lines (maxLines) and characters
per line (maxChars) can be specified.

15.2 Compound Displayable Attributes
Compound displayable attributes are special kind of displayable attributes. They consist of individual
text components. Every text component:
• represents one feature related to the master feature of the graphic tag
• is a feature delegate – the delegated feature form can be opened after clicking on the graphics
• can be of different type – the symbology can be different
The related features to be represented by compound displayable attributes can be searched by more
levels. They don’t need to related to the master feature directly. The level of relationship can be
represented by horizontal offset when aligning individual texts below each other.
Optionally, compound displayable attribute can contain:
• header component which represents the master feature itself. It can include either simple or
geometry query
• index component used for plotting functionality in LIDS Explorer
The definition of compond displayable attributes is very similar to the standard displayable attributes.
Example: Definition of graphic type class.
<ber:graphicTypeClass id="CompoundDA" name="Compound displayable attribute">
<ber:description>Multicolor displayable attributes of related
features</ber:description>
</ber:graphicTypeClass>

Example: Definition of graphic type.
<ber:graphicType id="gtcda_01" name="Compound DA1">
<ber:class refId="CompoundDA"/>
<ber:collectionGraphicType>
<ber:graphicTypeComponentArray>
<ber:graphicTypeComponent id="gtcda_01_route" name="Route" roleId="DA">
<ber:textGraphicType>
<ber:symbology>
</ber:symbology>
<ber:defaultTextProperties>
<ber:anchorPoint>left-bottom</ber:anchorPoint>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

193

</ber:defaultTextProperties>
</ber:textGraphicType>
</ber:graphicTypeComponent>
<ber:graphicTypeComponent id="gtcda_index" name="Route" roleId="index">
<ber:textGraphicType>
<ber:symbology>
<ber:textSymbolizer>
<ber:mask>
<ber:style>fill</ber:style>
</ber:mask>
</ber:textSymbolizer>
</ber:symbology>
</ber:textGraphicType>
</ber:graphicTypeComponent>
<ber:delegateGraphicTypeComponent id="gtcda_01_c1" name="Cable 1" roleId="DA">
<ber:textGraphicType>
<ber:symbology>
</ber:symbology>
<ber:defaultTextProperties>
<ber:anchorPoint>left-bottom</ber:anchorPoint>
</ber:defaultTextProperties>
</ber:textGraphicType>
<ber:featureTypeDelegate refId="ft_cable_1"/>
</ber:delegateGraphicTypeComponent>
<ber:delegateGraphicTypeComponent id="gtcda_01_c2" name="Cable 2" roleId="DA">
<ber:textGraphicType>
<ber:symbology>
</ber:symbology>
<ber:defaultTextProperties>
<ber:anchorPoint>left-bottom</ber:anchorPoint>
</ber:defaultTextProperties>
</ber:textGraphicType>
<ber:featureTypeDelegate refId="ft_cable_2"/>
</ber:delegateGraphicTypeComponent>
<ber:delegateGraphicTypeComponent id="gtcda_01_pps" name="Duct" roleId="DA">
<ber:textGraphicType>
<ber:symbology>
</ber:symbology>
<ber:defaultTextProperties>
<ber:anchorPoint>left-bottom</ber:anchorPoint>

Implementation Guide

194

15 – DISPLAYABLE ATTRIBUTES
</ber:defaultTextProperties>
</ber:textGraphicType>
<ber:featureTypeDelegate refId="ft_e_protpipe"/>
</ber:delegateGraphicTypeComponent>
<ber:graphicTypeComponent

id="gtcda_01_ll"

name="Label

line"

roleId="labelLine">
<ber:curveGraphicType>
<ber:symbology>
</ber:symbology>
</ber:curveGraphicType>
</ber:graphicTypeComponent>
</ber:graphicTypeComponentArray>
</ber:collectionGraphicType>
</ber:graphicType>

Example: Definition of graphic tag type
<ber:graphicTagType id="gt_e_route_gtcda_01" name="DAs of ducts / cables">
<ber:description>Displayable attributes of ducts and cables</ber:description>
<ber:graphics refId="gtcda_01"/>
</ber:graphicTagType>

Example: Definition in option.xml
<ber:compoundDisplayableAttributeArray>
<ber:compoundDisplayableAttribute id="da_ducts_cables" name="Route,ducts,cables">
<ber:graphicTagRefArray>
<ber:graphicTag xlink:href="model.xml#gt_e_route_gtcda_01"/>
</ber:graphicTagRefArray>
<ber:daQuery>
<ber:simpleQuery>
<ber:attributeArray>
<ber:attribute xpath="at_e5121011"/>
<ber:attribute xpath="at_e5121006/ca_31902"/>
</ber:attributeArray>
<ber:format>CS Name: {0}\nDiameter: {1}</ber:format>
</ber:simpleQuery>
<ber:headerComponent lineHeight="1.5">
<ber:graphicTypeComponent xlink:href="model.xml#gtcda_01_route"/>
</ber:headerComponent>
<ber:compoundQuery>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

195

<ber:attributeArray>
<ber:attribute xpath="at_5120005"/>
</ber:attributeArray>
<ber:format>({0})</ber:format>
<ber:relationAssoc xlink:href="model.xml#r_route_duct"/>
<ber:layout lineHeight="1.2" levelOffset="0.0"/>
<ber:compoundQuery>
<ber:attributeArray>
<ber:attribute xpath="at_5120005"/>
</ber:attributeArray>
<ber:format>*{0}*</ber:format>
<ber:relationAssoc xlink:href="model.xml#r_duct_cable"/>
<ber:layout lineHeight="1.2" levelOffset="1.0"/>
</ber:compoundQuery>
<ber:compoundQuery ignoreEmptyLines="true">
<ber:attributeArray>
<ber:attribute xpath="at_telco_id"/>
</ber:attributeArray>
<ber:format>{0}</ber:format>
<ber:relationAssoc xlink:href="model.xml#r_duct_t_cable"/>
<ber:layout lineHeight="1.2" levelOffset="1.0"/>
</ber:compoundQuery>
</ber:compoundQuery>
<ber:compoundQuery>
<ber:attributeArray>
<ber:attribute xpath="at_5120005"/>
</ber:attributeArray>
<ber:format>*{0}*</ber:format>
<ber:relationAssoc xlink:href="model.xml#r_route_cable"/>
<ber:layout lineHeight="1.2" levelOffset="0.0"/>
</ber:compoundQuery>
</ber:daQuery>
<ber:daAutoConstruction>
<ber:position>
<ber:distance>
<ber:dX>-5</ber:dX>
<ber:dY>-0.8</ber:dY>
</ber:distance>
<ber:lineMasterPoint lengthwise="endPoint"/>
</ber:position>

Implementation Guide

196

15 – DISPLAYABLE ATTRIBUTES
<ber:angleFromMaster/>
</ber:daAutoConstruction>
</ber:compoundDisplayableAttribute>

</ber:compoundDisplayableAttributeArray>

•

ignoreEmptyLines – optional attribute; when set to true, empty lines and all subordinate rows will
be excluded

Implementation Guide

Chapter 16
Associations

IMPLEMENTATION GUIDE VERSION 9.6

16.

199

Associations
Associations are relations between features. An association is a general definition for several classes of
associations. The classes of the association types are Relation, Detail association, Linear and Areal
topology association.
An association type contains roles. An association type can contain one or more identified role types
which contains feature types.

Association Type:
as_1

Role Type:

Role Type:

role 1

Feature Type:
ft_1

Feature Type:
ft_2

role 2

Feature Type:
ft_2

Feature Type:
ft_2

Feature Type:
ft_2

Associations can be unary (contain only one role), binary (contains two roles), ternary (contains three
roles),...
The structure of an association is defined by an Association Type. The Association Type defines the
name of the type and the type of roles in the association type. The definition of roles contains references
to feature types.

16.1 Relations
A Relation is binary association. Each Relation Type must contain two Role Types – Source Role and
Destination Role. A relation type contains, as all element types in a project, identifier, name, description
and the database name.
The definition of relation types is situated within the assocTypeArray XML collection. Role types are
defined within the roleTypeArray XML collection.

Implementation Guide

16 – ASSOCIATIONS

200

Association Type:

Mains --> Main pipeline segment

Role Type:

Role Type:

Water mains

Main pipeline segment

Feature Type:

Feature Type:

Water mains

Main pipeline segment

Example: Structure of role type and association type.
<ber:model>
...
<ber:roleTypeArray>
<!-- Define the source role with feature types inside -->
<ber:relationRole id="rt_mains" name="Water mains"
dbName="MAINS">
<ber:ftItem refId="ft_mains"/>
</ber:relationRole>
<!-- Define the destination role with feature types inside -->
<ber:relationRole id="rt_pipe" name="Main pipeline segment"
dbName="PIPE">
<ber:ftItem refId="ft_pipe_a"/>
<ber:ftItem refId="ft_pipe_b"/>

</ber:relationRole>

</ber:roleTypeArray>

<ber:assocTypeArray>
<!-- Define the relation between Mains and Main Pipelines-->
<ber:relationAssoc id="r_mains_pipes"
name="Mains --&gt; Main pipeline segment" dbName="R_MAINS_PIPES">
<!-- The Source role reference -->
<ber:srcRole refId="rt_mains" cardinality="1"/>
<!-- The Destination role reference -->
<ber:destRole refId="rt_pipe"/>
</ber:relationAssoc>
</ber:assocTypeArray>
</ber:model>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6
16.1.1

201

Role Type Definition
The role type definition can be defined by XML element relationRole. The relationRole element can be
reused more times in relation associations regardless of whether it represents source or destination role.
There are some restrictions in relation association concerning using relationRole:
• relation role can include more feature types, but they have to share the same container
• relation association must not refer the same relation roles (with the same identifier).
• relation association must not contain relation roles with the same database name.
The role type definition contains the following information:
• id – Unique identifier of a role type. Maximum length is limited depending on the used database.
The id is used as an alias in case of some select statements. Moreover, it can be expanded by a
postfix to preserve alias uniqueness. Therefore it’s not possible to define the strict limit in advance.
It’s safe, if the length is less than 50 characters in case of databases supporting up to 63 characters
identifiers
• name – Name of a role type.
• dbName – Name of a database column in a relation table.
• ftItem – List of feature types that can appear in a relation.
Interface Role
Standard relationRole definition is limited to feature types from the same container. In some cases it’s
desired to create relationship between more heterogeneous set of features in a role. Interface and
interfaceRole can be used in such case.
Interface role definition doesn’t include individual feature types in the definition, but refers an interface.
All feature types implementing the interface are included in the role.
The interfaceRole type definition contains the following information:
• id – Unique identifier of a role type.
• name – Name of a role type.
• dbName – Name of a database column in a relation table and also name of database views providing
the content of the interface. The views are generated by database synchronizing from Application
server console
• interface – interface definition used to define content of the interface in terms of feature types and
the attributes
Example: Definition of interfaceRole.
<ber:interfaceRole id="rt_station_content" name="Station content"
dbName="STATION_CONTENT" interface="if_station_content"/>

InterfaceRole definition limitations
•
•

Interface attribute used in featureRefAttribute can’t be implemented by defaultValue with constant.
It can still be implemented by empty value
It’s recommended for performance reasons to implement an interface attribute by the same feature
attribute for all feature types in the same container
Implementation Guide

202
•
•
•

16.1.2

16 – ASSOCIATIONS
Derived attribute using relationQuery on interface role must define interface attributes instead of
feature attributes in the attributeArray
Interface role can’t be combined with spatialRelation
Feature types included in interfaceRole have to implement their security attributes in the interface

Relation Type Definition
The relation association contains references to two roles – source and destination role.
Example: Definition of relation association.
<ber:relationAssoc id="r_cable_sch_axis" name="Cable - Axis (Scheme)"
dbName="R_SCH_CABLE_AXIS">
<ber:srcRole refId="rt_cable_sch_s" deleteWithDestFeature="true"/>
<ber:destRole refId="rt_e_route_sch_d" cardinality="1"/>
</ber:relationAssoc>

Attributes
•
•
•
•



id – Unique identifier of a relation type.
name – Name of a relation type.
dbName – Name of a database container for the relation.
versioned – Optional parameter. Possible values:
• false – default. No versioning is activated
• history - changes are recorded for keeping history
• longTransaction - changes are done in long transaction mode

Following limitations need to be considered when versioning relations:
•
•

•

It is not permitted for versioned relations to contain feature types from non-versioned containers in
any role.
If a container is versioned for long transactions, all its relations have to be versioned for long
transactions too. The containers in the other roles of such relations have to be versioned either for
history or for long transactions.
Standard relation with cardinality 1 in any role can’t be versioned for long transactions. Only
unbounded (m:n) or featureRefRelations can be versioned for long transactions.

Inner elements
•
•

srcRole – Reference to a source role.
destRole – Reference to a destination.

Both srcRole and destRole roles can have optional attribute cardinality and deleteWithDestFeature.
• cardinality – The possible values are 1; unbounded. The value 1 means that one feature can be at
most in one relation instance. The value unbounded means that one feature can be in unlimited
number of relation instances.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6
•

16.1.3

203

deleteWithDestFeature/deleteWithSrcFeature - Attribute identifies whether or not the related
feature(s) in source/destination role will be deleted during destination/source feature deletion.

Spatial relations
There can be a spatial relation defined between features. The spatial relation is based on spatial
interaction of two features; it is managed automatically by system. The spatial relation is defined by
interaction condition. If the condition is fulfilled, the relation is created. Then, if one of the feature is
moved so as the interaction condition stops to be fulfilled, the relation is automatically deleted.
Spatial relation has the same structure of parameters as a common relation, in addition there are 2
parameters:
• roleFilter – It allows to choose only required feature types (especially shared semantics graphic
child) to be related automatically. Optional.
• interactionType – Defines interaction condition.
There are these types of interactions conditions:
• pointToPoint – A point feature is near to another point feature; the maximal distance is defined as
snapRadius.
• lineToPoint – A point feature is near to a vertex of a line feature; the maximal distance is defined
as snapRadius. The parameter spatialCondition defines which line vertexes interact with the point:
only first vertex (firstVertex), only last vertex (lastVertex), any of the end vertexes (endVertices),
any of inner vertexes (innerVertices), any of all line vertexes (allVertices).
• Parallel lines (lineToLine) – Represents a line to line spatial interaction with the given spatial
condition on parallel lines. This interaction considers master-slave relationship and resolves whether
the slave line meets spatial condition to the master line. The parameter spatialCondition defines
whether the lines are:
• partialParallel – The whole destination line is parallel to a part of a source line. The destination
line has to start / end in a vertex of source line
• fullParallel – The two lines are parallel in the whole length.
• parallel – They are either fully parallel or partially parallel. Furthermore, it is irrelevant which
of lines is source and which of them is destination in this case. Both directions are considered.
• Intersecting lines (lineToLine)
• commonVertex – The vertexes of both lines are near to each other.
• intersects – Any interaction of both lines is considered.
• lastToFirstVertex – The two lines have the same orientation (end vertex of first line is coincident
with start vertex of second line).
• faceToPoint - The parameter spatialCondition defines whether the surface anyhow contains (either
inside or on the boundary) point (intersects) or whether the point lays on the surface boundary
(touches).
• faceToLine – The parameter spatialCondition defines whether:
• the surface anyhow contains (either inside or on the boundary) the whole line (contains).
• the whole line lays on the surface boundary (boundary contains).
• the line touches the surface (touches).
• the line anyhow interacts with the surface (intersects).
• faceToFace - The parameter spatialCondition defines whether:
• the source surface contains the whole destination surface (contains).
Implementation Guide

16 – ASSOCIATIONS

204
•
•
•

both surfaces overlap each other – common parts form a polygon (overlaps)
both surfaces touch each other – common parts form a line (touches).
both surfaces anyhow interact (intersects).

Example: Defining spatial relation between main pipeline segments and valves.
<ber:model>
...
<ber:roleTypeArray>
<!-- Define the feature types in the source role -->
<ber:relationRole id="rt_5012100_s" name="Main pipeline segment"
dbName="SRC_SID_1">
<ber:ftItem refId="ft_5012100"/>
</ber:relationRole>

<!-- Define the feature types in the destination role -->
<ber:relationRole id="rt_5011100_d" name="Valve"
dbName="DEST_SID_1">
<ber:ftItem refId="ft_5011100"/>
</ber:relationRole>
</ber:roleTypeArray>
<ber:assocTypeArray>
<!-- Define the spatial relation between a Main pipeline segment
and a Valve -->
<ber:spatialRelationAssoc id="sr_5012100_5011100"
name="Main pipeline segment -&gt; Valve"
dbName="SR_5012100_5011100" versioned="history">
<ber:srcRole refId="rt_5012100_s"/>
<ber:destRole refId="rt_5011100_d"/>
<!-- Define an interaction type -->
<ber:interactionType>
<ber:lineToPoint snapRadius="5" spatialCondition="allVertices"/>
</ber:interactionType>
</ber:spatialRelationAssoc>
</ber:assocTypeArray>
</ber:model>

Example: Use of roleFilter parameter.
<ber:spatialRelationAssoc id="sr_5012000" name="Main pipeline segment, Service
pipe --&gt; Protection pipe" dbName="SR_5012000">
<ber:srcRole refId="rt_5012100_5012200_s" cardinality="1"/>
<ber:destRole refId="rt_5012300_d"/>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

205

<ber:interactionType>
<ber:lineToLine spatialCondition="partialParallel"/>
<ber:roleFilter refId="rt_5012300_d">
<ber:featureType refId="ft_5012300"/>
</ber:roleFilter>
</ber:interactionType>
</ber:spatialRelationAssoc>

16.1.4

Relation constraints
A relation definition can include set of rules defining conditions and constrains when the relation can
be created:
- one relation type can include zero or more rules
o all rules must be met to be able to create the relation
- one rule can contain zero or more conditions
o more conditions are evaluated using AND operator
- one rule can contain one or more constraints
o if condition is not TRUE, the constraints are not evaluated
o if condition is TRUE, all constraints are evaluated
o if condition is not defined, the constraints are evaluated always
Syntax of both condition and constraint is the same:
<ber:condition r1.roleId="rx" r2.roleId="ry" r1.ftids="ft_1 ft_2" r2.ftids="ft_3">
{r1.at_1} != 'AAA'
</ber:condition>
<ber:constraint r1.roleId="rx" r2.roleId="ry">{r1.at_2} = {r2.at_3} </ber:constraint>

•
•
•

r1.roleId – mandatory attribute. Defines the first role a condition / constraint is applied to
r2.roleId – optional attribute. Defines the second role a condition / constraint is applied to
r1.ftids, r2.ftids – optional attribute. Defines feature types of the first / second role a condition /
constraint is applied to. If it’s not defined, all feature types of the role are evaluated
• r1.attribute, r2.attribute – optional definition. It enables filter the features the condition / constraint
is applied to
• text attributes – values are written in apostrophes
• decimal attributes – values are written without apostrophes
• codelist attributes – values are identified by primary key of the codelist
• empty value – is written as NULL
• operators – currently supported operators include: =, !=, <, >, <=, >=, IN
The index r1 and r2 is applied for one element only. In one rule definition, index r1 can be assigned to
different roles in different constraints



Relation rules of spatial relations behavior is configured by rule attribute cascadeRollback:
- true – if rule is violated, it’s not possible to place features spatially interacting. This definition can’t be
Implementation Guide

206

16 – ASSOCIATIONS

used for feature types captured in the light clients (e.g. LIDS Mobile). LIDS Mobile creates a feature
using default values first and opens the form for specifying the attributes in the next step. In such case,
the default values might violate the constraint, so the creation would not be possible at all.
- false (default) – if rule is violated, features can be created, spatial relation is not generated
Example: Rule for one role without condition – evaluated always. Feature types in role 1 must be always
YELLOW, otherwise the relation can’t be created
<ber:rule id="" name="" cascadeRollback="true">
<ber:constraint r1.roleId="rt_1">{r1.at_color} = 'YELLOW'</ber:constraint>
</ber:rule>

Example: Rule for one role with condition. If feature in role 1 has material GOLD, the color must be
YELLOW. If the material is not GOLD, the rule is not evaluated
<ber:rule id="" name="">
<ber:condition r1.roleId="rt_1">{r1.at_material} = 'GOLD'</ber:condition>
<ber:constraint r1.roleId="rt_1">{r1.at_color} = 'YELLOW'</ber:constraint>
</ber:rule>

Example: Rule for two roles with condition. If feature in role 1 has material GOLD, the related feature
on role 2 must be YELLOW.
<ber:rule id="" name="">
<ber:condition r1.roleId="rt_1">{r1.at_material} = 'GOLD'</ber:condition>
<ber:constraint r1.roleId="rt_2">{r1.at_color} = 'YELLOW'</ber:constraint>
</ber:rule>

Example: Rule defining only allowed feature types combination. If feature in role 1 has feature type 1,
the feature in role 2 must be feature type 2
<ber:rule id="" name="">
<ber:condition r1.roleId="rt_1" r1.ftids="ft_1"/>
<ber:constraint r1.roleId="rt_2" r1.ftids="ft_2"/>
</ber:rule>

Example: Rule based on feature type and attribute conditions. If feature type is 1 or 2 and the material
is GOLD, the related feature type has to be 3 or 4 and the color has to be YELLOW or GREEN
<ber:rule id="" name="">
<ber:condition r1.roleId="rt_1" r1.ftids="ft_1 ft_2">{r1.at_material} = 'GOLD'
</ber:condition>
<ber:constraint r1.roleId="rt_2" r1.ftids="ft_3 ft_4">{r1.at_color} IN
('YELLOW', 'GREEN')
</ber:constraint>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

207

</ber:rule>

Example: Rule using more constraints. All must be met. If feature type is 1 or 2 and the material is
GOLD, the color has to be YELLOW. The related feature has to have also YELLOW color
<ber:rule id="" name="">
<ber:condition r1.roleId="rt_1" r1.ftids="ft_1 ft_2">{r1.at_material} = 'GOLD'
</ber:condition>
<ber:constraint r1.roleId="rt_1">{r1.at_color} = 'YELLOW'</ber:constraint>
<ber:constraint r1.roleId="rt_2">{r1.at_color} = 'YELLOW'</ber:constraint>
</ber:rule>

Example: Rule based on comparing values of attributes of different roles. If material in the role 1 is not
null, the color attributes of related features have to be the same
<ber:rule id="" name="">
<ber:condition r1.roleId="rt_1">{r1.at_material} != NULL</ber:condition>
<ber:constraint r1.roleId="rt_1" r2.roleId="rt_2">
{r1.at_color} = {r2.at_color}
</ber:constraint>
</ber:rule>

Example: defining relation rules for relations.
<ber:featureRefRelationAssoc id="r_1" name="Pipe --> Inspection">
<ber:masterRole refId="rt_5012100_s"/>
<ber:childRole refId="rt_inspection_d" deleteWithMasterFeature="true"/>
<ber:relationRuleArray>
<ber:rule id="rc_1" name="…">
<ber:description>Inspection can’t be related to pipe with Unknown
diameter</ber:description>
<ber:condition r1.roleId="rt_inspection" r1.ftids="ft_damage
ft_pig_inspection"/>
<ber:constraint r1.roleId="rt_pipe">{r1.at_diameter} != -1</ber:constraint>
</ber:rule>
</ber:relationRuleArray>
</ber:featureRefRelationAssoc>

Implementation Guide

16 – ASSOCIATIONS

208

16.2 Details
A Detail is a type of binary association. The detail association contains two roles: master role and detail
role. The master role (defined as XML element masterRole) defines the role of the master feature which
contains the detail. The detail role (defined as XML element detailRole) contains a list of feature types
that can occur in the detail association. More than one feature type can be defined in both master and
detail roles.

Association Type:

Pumping station - detail

Role Type:

Role Type:

Pumping station
- master feature

Detail - detail feature

Feature Type:

Feature Type:

Fuse

Conductor

Feature Type:
Pumping station

Feature Type:
Busbar

Feature Type:

Feature Type:

Switch

Outlet

Example: Defining the detail association for the pumping station feature type.
<ber:model>
...
<ber:roleTypeArray>
<!-- Define the master role with Pumping station feature type in it -->
<ber:masterRole id="rt_5010100_mst"
name="Pumping station - master feature">
<ber:description>Pumping station - master feature</ber:description>
<ber:ftItem refId="ft_5010100"/> <!-- The Pumping station -->
</ber:masterRole>

<!-- Define the detail role with many feature types in it -->
<ber:detailRole id="rt_5090000_det" name="Detail - detail feature">
<ber:description>Detail - detail feature</ber:description>
<ber:ftItem refId="ft_5091000"/> <!-- The Conductor -->
<ber:ftItem refId="ft_5092000"/> <!-- The Busbar -->
<ber:ftItem refId="ft_5093000"/> <!-- The Switch -->
<ber:ftItem refId="ft_5094000"/> <!-- The Fuse -->
<ber:ftItem refId="ft_5095000"/> <!-- The Outlet -->

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

209

</ber:detailRole>
</ber:roleTypeArray>
<ber:assocTypeArray>
<!-- Define the detail association between the master element Pumping station and detail elements -->
<ber:detailAssoc id="det_5010100_1" name="Pumping station - detail">
<ber:description>Pumping station - detail</ber:description>
<ber:masterRole refId="rt_5010100_mst"/>
<ber:detailRole refId="rt_5090000_det"/>
</ber:detailAssoc>
</ber:assocTypeArray>
</ber:model>




In case of shared semantics the detailRole definition should contain the graphic feature types only.
Semantic parent shouldn’t be defined in this role.

Optional attribute deleteWithMasterFeature defines, whether the features in detail content role are
deleted automatically when deleting the detail association.

<ber:detailAssoc id="det_1" name="ABC">
<ber:description>Detail content automatically deleted</ber:description>
<ber:masterRole refId="rt_1_mst"/>
<ber:detailRole refId="rt_1_det" deleteWithDetail="true"/>
</ber:detailAssoc>

Implementation Guide

210

16 – ASSOCIATIONS

Implementation Guide

Chapter 17
Topology

IMPLEMENTATION GUIDE VERSION 9.6

17.

213

Topology
Topology is a type of association in LIDS. There are two types of topology associations: Linear topology
association – for linear graph and Areal topology association – for areal graph.

17.1 Linear Topology
Linear topology association is a binary association with nodeRole and edgeRole roles. All feature types
that can act as nodes in the linear graph are included in the nodeRole. Similarly, all feature types that
can act as edges in the linear graph are included in the edgeRole.
Linear topology graph can be directed or undirected. There is no edge direction in the undirected linear
topology graph as it is unimportant. On the other hand the directed linear graph has all edges directed.
Every edge in the directed graph has start node and end node.

17.1.1

Graph creation
Graph elements – nodes and edges are derived from standard features’ geometry. The graph elements
are created / updated / deleted when source features are created, updated / deleted. Connection between
edges and nodes is derived according to spatial position. If a node is created at the start / end of an edge,
they are topologically connected.
Point features
Features with point geometry can be used to create nodes. Usually, one node feature is represented by a
single node in the topology graph.
Following limitations exist:
• Two nodes of the same graph can’t exist on the same position. It’s not possible to construct two
point features defined as nodes of the same graph on the same coordinates.
• Multigeometry is prohibited for point features defined as nodes
Linear features
Features with linear geometry can be used to create edges but also nodes.One linear feature can be
represented by one or many many topology edges. If there are usually nodes situated on the inner
vertexes of lines it is useful to split the line feature into several edges. Then the inner vertexes have
correct topology connection to the topology edges. The definition for splitting edge features into many
topology edges is included in the edge role metadata definition.



One feature in a node role can be represented by more than one topology node also. This unusual
situation can only happen when node have a line-string geometry. For feature vertexes topology nodes
are created and the nodes are connected by system edges.
System nodes
System node is special kind of node not related to point feature. It can’t be created manually by the user.
System node is generated automatically on edge end, if there is nostandard node in the specified
distance. Typically, system nodes are generated after constructing linear features away from point
features.
Implementation Guide

214

17 – TOPOLOGY

When point feature is created on the position where system node exists, the system node is replaced by
the standard one.
Example: The example of simple linear graph definition for Water category.

Association Type:
WATER

Role Type:

Role Type:

nodeRole

Feature Type:

Feature Type:

Extraction Point

17.1.2

edgeRole

Valve

Feature Type:
Service Pipe

Undirected graph
There are no directed edges in the undirected linear topology graph. The direction for the graph is not
important.
Example: Definition of simple linear graph Water.
<ber:linearTopologyAssoc xmlns:ber="http://www.berit.com/ber"
id="ast_01" name="WATER" dbName="WATER"
snapRadius="0.5" update="online">

<!-- Defines the Node Role -->
<ber:nodeRole id="ast_01_node" name="Node of Water graph">
<ber:description>Node of Water graph</ber:description>
<ber:nodeType systemEdge="none">
<!-- Extraction Point -->
<ber:featureType refId="ft_5010200"/>
</ber:nodeType>
<ber:nodeType systemEdge="none">
<!-- Valve -->
<ber:featureType refId="ft_5011100"/>
</ber:nodeType>
<ber:pointSymbolizer>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

215

<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ber_LIDSdemo/35"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
<ber:rgbColor>#FF0000</ber:rgbColor>
</ber:pointSymbolizer>
</ber:nodeRole>

<!-- Defines the Edge Role -->
<ber:edgeRole id="ast_01_edge" name="Edge of Water graph">
<ber:edgeType systemNode="terminal" processVertices="terminal">
<!-- Service Pipe -->
<ber:featureType refId="ft_5012200"/>
</ber:edgeType>
<ber:lineSymbolizer>
<se:Stroke>
<se:SvgParameter name="stroke">#FF0000</se:SvgParameter>
<se:SvgParameter name="stroke-width">3</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
</ber:edgeRole>
</ber:linearTopologyAssoc>

Linear Topology Association
A linear topology association is defined by the linearTopologyAssoc XML element. There are following
important attributes in the definition:
Attributes
• id – Unique identifier of the linear topology association.
• name – Name of the linear topology association.
• dbName – The database table prefix for topology tables. Following tables are created
xxx_NODE, xxx_EDGE, where xxx is the value of dbName attribute.
• snapRadius – The double tolerance value. It is the maximal value for considering two nodes
to be identical.
• update – The update flag. One of online, batch. The online graph are updated online, when
master features are updated (inserted, updated, deleted). The batch flag defines the linear
graph to be updated only in a batch mode. The online flag allows batch updating also.
Node Role
The node role contains one or more node types defined by a nodeType XML element. The nodeRole is
defined inline – it means that the actual definition of nodeRole is inside the linearTopologyAssoc XML
element

Implementation Guide

216

17 – TOPOLOGY
Attributes
• id – Unique identifier of the node role.
• name – Name of the node role.

Node Type
The nodeType XML element aggregates feature types that should be considered to be nodes in the graph.
There can be one or more feature type references included in the node type definition.
Attributes
• systemEdge – (none, all). This parameter makes sense only for linear feature types. When set
to all, features with line-string geometry can be used as topology nodes. For each vertex of
the feature a node is created. Nodes are then connected by a system edges. When none is
defined, features with line-string geometry cannot be used in the topology as nodes.
Inner elements
• featureType – List of feature type references. All referenced feature types can be topology
nodes in the graph. Cannot be empty.
Point Symbolizer
Defines symbology for graph nodes visualization.
Edge Role
The edgeRole XML element contains one or more edge types. The edgeRole is defined inline – it means
that the actual definition of edgeRole is inside the linearTopologyAssoc.
Attributes
• id – Unique identifier of the edge role.
• name – Name of the edge role.
Edge Type
The edgeType XML element aggregates feature types that should be edges in the linear graph. There
can be one or more feature type references included in the edge type. The edge type contains two
attributes systemNode and processVertices.
Attributes
• systemNode – (all, inner, terminal) It defines the possibility to create system nodes when
needed. When all is selected there are no restrictions where to create system nodes. When
inner is selected the system nodes can be created only on internal vertexes of a line-string
feature. This means: the terminal nodes must be standard nodes – point features must exist at
the start and end of the line string. When terminal is selected the system nodes can be created
only on terminal vertexes of a line-string feature. This means: point features must exist at the
internal vertexes of the line string.
• processVertices – (all, terminal) It defines the behavior of the algorithm for creating edges
from features. When process vertexes is set to all it means that a line-string feature should be
divided into several lines. There is an edge created from each line. When set to terminal for
a one line-string feature there will be only one edge created.
Inner elements
• featureType – List of feature type references. All referenced feature types can be topology
edges in the graph. Cannot be empty.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

217

Line Symbolizer
Defines symbology for graph edges visualization.

17.1.3

Directed graph
The directed linear topology graph is a graph where each edge is directed. There is always a start node
and end node for each edge in the graph. AS the direction of edges is defined by the direction of
geometries, the definition of a directed and undirected topology graph is almost same.
Example: Definition of simple linear directed graph Water.
<ber:linearDirectedTopologyAssoc xmlns:ber="http://www.berit.com/ber"
id="ast_01" name="WATER" dbName="WATER"
snapRadius="0.5" update="online">

<!-- Defines the Node Role -->
<ber:nodeRole id="ast_01_node" name="Node of Water graph">
<ber:description>Node of Water graph</ber:description>
<ber:nodeType systemEdge="none">
<!-- Extraction Point -->
<ber:featureType refId="ft_5010200"/>
</ber:nodeType>
<ber:nodeType systemEdge="none">
<!-- Valve -->
<ber:featureType refId="ft_5011100"/>
</ber:nodeType>
</ber:nodeRole>

<!-- Defines the Edge Role -->
<ber:edgeRole id="ast_01_edge" name="Edge of Water graph">
<ber:edgeType systemNode="terminal" processVertices="terminal">
<!-- Service Pipe -->
<ber:featureType refId="ft_5012200"/>
</ber:edgeType>
</ber:edgeRole>
</ber:linearDirectedTopologyAssoc>

17.1.4

Constraints
There is a possibility to define constraints defining which types of nodes can be connected to which
types of edges. The constraints are based on feature type x feature type restrictions. There are node
constraints and edge constraints. Their meaning differs depending on the type of graph – directed or
undirected.
Implementation Guide

218

17 – TOPOLOGY

Undirected constraints
•
•

Node Constraint – Defines possible feature types in the edge role which a feature type in the node
role can be connected to.
Edge Constraint – Defines pair of feature types in the node role which a feature type in the edge
role can be connected by.

Directed constraints
•

•

Node Constraint – For a feature type in the node role defines a set of feature types in the edge role
that can go out from the node and a set of feature types in the edge role that can come in to the node.
There is a possibility to define more constraints – combination of incoming and outgoing edges.
Edge Constraint – For a feature type in the edge role it defines a set of feature types in the node
role which can start in and a set of feature types in the edge role which can end to. There can be
more constraints – combinations of start and end nodes.

Node constraints are defined inside the nodeType element. Edge constraints are defined inside the
edgeType element.

17.1.5

Constraints for undirected graph
Node Constraints
Node constraints for undirected graph are defined in node types.
Example: Definition of node constraints.
<ber:nodeRole id="ast_01_node" name="Node of Water graph">
<ber:nodeType systemEdge="none">
<ber:featureType refId="ft_5010200"/>

<!-- Extraction Point -->

<ber:constraint>
<ber:featureType refId="ft_5012200"/> <!-- Service Pipe -->
</ber:constraint>
</ber:nodeType>

<ber:nodeType systemEdge="none">
<ber:featureType refId="ft_5011100"/> <!-- Valve -->
<ber:constraint>
<ber:featureType refId="ft_5012200"/>
</ber:constraint>
</ber:nodeType>
</ber:nodeRole>

Implementation Guide

<!-- Service Pipe -->

IMPLEMENTATION GUIDE VERSION 9.6

219

Constraint
The constraint element for nodes in undirected linear graph contains list of feature types references that
are included in the edge role. For the specified list of feature types in the actual node type it defines the
possible feature types in the edge role the node can be connected to. If the list is empty then this node
cannot be connected to any edge. When the constraint element is not present, node can be connected to
all features.
Inner elements
•

featureType – List of feature type references. All referenced feature types can be connected to the
node. If there is no feature type reference then this node cannot be connected to any edge.

Edge Constraints
Edge constraints for undirected graph are defined in edge types.
Example: Definition of edge constraints.
<ber:edgeRole id="ast_01_edge" name="Edge of Water graph">
<ber:edgeType systemNode="terminal" processVertices="terminal">
<ber:featureType refId="ft_5012200"/> <!-- Service Pipe -->
<ber:constraint allowsSystemNode="true">
<ber:featureType refId="ft_5010200"/> <!-- Extraction Point -->
<ber:featureType refId="ft_5011100"/> <!-- Valve -->
</ber:constraint>
</ber:edgeType>
</ber:edgeRole>

Constraint
The constraint element for edges in undirected linear graph contains list of feature types references that
are included in the node role. For the specified list of feature types in the actual edge type it defines the
possible feature types in the node role the edge can be connected to. If the list is empty then this edge
cannot be connected to any feature node. When the constraint element is not present, the edge can be
connected to all feature nodes.
Attributes
•

allowsSystemNode – (true, false) This flag defines whether the edge can be connected to a system
node – a node generated by the system, node does not refer to a feature.

Inner elements
•

featureType – List of feature type references. All referenced feature types can be connected to the
node. When no feature type is referenced then this edge cannot be connected to any feature node.

Implementation Guide

220
17.1.6

17 – TOPOLOGY
Constraints for directed graph

Constraints for directed graph allows defining incoming and outgoing edges for nodes and start or end
nodes for edges.
We will define directed graph with directed constraint in the following example. Consider following
situation. Let's have two node types – Extraction Point and Valve and one node type – Service Pipe. We
will define directed graph. Consider following restrictions:
• Service pipe can start only in Valve
• Service pipe can end in Extraction Point, Valve or system node.

Valve

Valve

Extraction
Point

Valve

System
Node

Node Constraints
Node constraints are defined in node types. For the specified list of feature types in the actual node type
it defines the possible set of incoming edge feature types and possible set of outgoing edge feature types.
Example: Definition of directed node constraints.
<ber:nodeRole id="ast_01_node" name="Node of Water graph">
<!-- systemEdge="none" -> only point geometries are allowed -->
<ber:nodeType systemEdge="none">
<ber:featureType refId="ft_5010200"/> <!-- Extraction Point -->
<ber:directedConstraintArray>
<!-- Only Service Pipe feature can be incoming for this node type -->
<ber:directedConstraint>
<ber:inEdge>
<ber:featureType refId="ft_5012200"/> <!-- Service Pipe -->
</ber:inEdge>
</ber:directedConstraint>
</ber:directedConstraintArray>
</ber:nodeType>

<ber:nodeType systemEdge="none">
<ber:featureType refId="ft_5011100"/> <!-- Valve -->
<ber:directedConstraintArray>
<!-- Only Service Pipe feature can be outgoing for this node type -->

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

221

<ber:directedConstraint>
<ber:outEdge>
<ber:featureType refId="ft_5012200"/> <!-- Service Pipe -->
</ber:outEdge>
</ber:directedConstraint>
</ber:directedConstraintArray>
</ber:nodeType>
</ber:nodeRole>

•
•
•
•

directedConstraintArray – holds list of directedConstraint elements.
directedConstraint – sequence of inEdge and outEdge elements. If the inEdge or outEdge element
is missing it means that all incoming feature edges or all outgoing feature edges are allowed.
inEdge – contains list of feature types in the edge role that can come in to the node. If the list is
empty it means that no feature edges can be incoming to the node.
outEdge – contains list of feature types in the edge role that can go out from the node. If the list is
empty it means that no feature edges can be outgoing from the node.

Edge Constraints
Edge constraints for directed graph defines possible start nodes and end nodes for an edge type. Edge
constraints are defined inside the edgeType definition.
Example: Definition of edge constraint
<ber:edgeRole id="ast_01_edge" name="Edge of Water graph">
<ber:edgeType systemNode="terminal" processVertices="terminal">
<ber:featureType refId="ft_5012200"/> <!-- Service Pipe -->

<ber:directedConstraintArray>
<ber:directedConstraint>
<!-- start nodes constraint
-> Service Pipe can start only in Valve feature -->
<ber:startNode allowsSystemNode="false">
<!-- allowsSystemNode="false" -> the edge cannot
start in a system node -->
<ber:featureType refId="ft_5011100"/>

<!-- Valve -->

</ber:startNode>

<!-- end nodes constraint
-> Service Pipe can end in Valve, Extraction Point
or system node -->
<ber:endNode allowsSystemNode="true">
<!-- allowsSystemNode="true" -> the edge can
start in a system node -->
<ber:featureType refId="ft_5011100"/>

<!-- Valve -->

Implementation Guide

222

17 – TOPOLOGY
<ber:featureType refId="ft_5010200"/> <!-- Extraction Point -->
</ber:endNode>
</ber:directedConstraint>
</ber:directedConstraintArray>
</ber:edgeType>

</ber:edgeRole>

•
•

•

•

directedConstraintArray – Holds list of directedConstraint elements.
directedConstraint – Sequence of startNode and endNode elements. If the inEdge or outEdge
element is missing it means that all incoming feature edges or all outgoing feature edges are allowed.
If the startNode element is missing, it means that the edge can start in all feature types in node role
including system nodes. If the endNode element is missing, it means that the edge can end in all
feature types in node role including system nodes.
startNode – Defines a list of start feature types in the node role. If no feature type is defined it means
that the edge can start in no node feature. The startNode element contains one attribute
allowsSystemNode (true, false). This flag defines whether the edge can start in a system node – a
node generated by the system, node does not refer to a feature.
endNode – Defines a list of end feature types in the node role for the edge. If no feature type is
defined it means that the edge can end in no node feature. The endNode element contains one
attribute allowsSystemNode (true, false). This flag defines whether the edge can start in a system
node – a node generated by the system, node does not refer to a feature.

Example: We will define a directed graph with two feature nodes – Valve and Extraction Point and
one feature edge – Service Pipe with following restrictions:
•
•
•

Service Pipe can start in a Valve and end in a Valve
Service Pipe can start in a Valve and end in a system node
Service Pipe can start in a system node and end in Extraction point

Valve

Valve

System
Node

Valve

System
Node

Extraction
Point

The xml definition for the constraint looks like following:
<ber:linearDirectedTopologyAssoc
id="ast_01" name="WATER" dbName="WATER" snapRadius="0.5"
update="online">

<ber:nodeRole id="ast_01_node" name="Node of Water graph">
<ber:nodeType systemEdge="none">
<ber:featureType refId="ft_5010200"/> <!-- Extraction Point -->
<ber:directedConstraintArray>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

223

<ber:directedConstraint>
<ber:inEdge>
<!-- Only Service Pipe can come in the node -->
<ber:featureType refId="ft_5012200"/> <!-- Service Pipe -->
</ber:inEdge>
<ber:outEdge>
<!-- No edges can go out -->
</ber:outEdge>
</ber:directedConstraint>
</ber:directedConstraintArray>
</ber:nodeType>
<ber:nodeType systemEdge="none">
<ber:featureType refId="ft_5011100"/> <!-- Valve -->
<ber:directedConstraintArray>
<ber:directedConstraint>
<ber:inEdge>
<!-- Only Service Pipe can come in the node -->
<ber:featureType refId="ft_5012200"/> <!-- Service Pipe -->
</ber:inEdge>
<ber:outEdge>
<!-- Only Service Pipe can go out from the node -->
<ber:featureType refId="ft_5012200"/>

<!-- Service Pipe -->

</ber:outEdge>
</ber:directedConstraint>
</ber:directedConstraintArray>
</ber:nodeType>
</ber:nodeRole>
<ber:edgeRole id="ast_01_edge" name="Edge of Water graph">
<ber:edgeType systemNode="terminal" processVertices="terminal">
<ber:featureType refId="ft_5012200"/> <!-- Service Pipe -->
<ber:directedConstraintArray>
<ber:directedConstraint>
<ber:startNode allowsSystemNode="false">
<!-- Service Pipe can start in Valve -->
<ber:featureType refId="ft_5011100"/> <!-- Valve -->
</ber:startNode>
<ber:endNode allowsSystemNode="true">
<!-- Service Pipe can end in Valve or system node -->
<ber:featureType refId="ft_5011100"/> <!-- Valve -->
</ber:endNode>
</ber:directedConstraint>

Implementation Guide

224

17 – TOPOLOGY
<ber:directedConstraint>
<ber:startNode allowsSystemNode="true">
<!-- Service Pipe can start in a system node -->
</ber:startNode>
<ber:endNode allowsSystemNode="false">
<!-- Service Pipe can end in a Extraction point -->
<ber:featureType refId="ft_5010200"/> <!-- Extraction point -->
</ber:endNode>
</ber:directedConstraint>
</ber:directedConstraintArray>

</ber:edgeType>
</ber:edgeRole>
</ber:linearDirectedTopologyAssoc>

17.1.7

Bridges
Bridges are nongraphical, topological only elements used for connecting standard elements of linear
graph. Bridges are considered during tracing functionality and enable tracing to pass through elements
which are not geometrically connected. Bridges can connect either two nodes or two edges of the same
or different graphs. Apart from nodes and edges, bridges are not derived from the source features
automatically and must be created manually by the user.



Special kind of bridges connect nodes or edges created by features with shared semantics. Such bridges
can be generated automatically.
Metadata definition of a brige – linearTopologyConnection - includes (apart from the standard id and
name attributes):
• type – bridge type can be edgeToEdge or nodeToNode
• startRole and endRole ftItem – feature type connected by the starting or ending node of the bridge
• lineSymbolizer – symbology used to display bridge in the client application
Example: Definition of edge to edge bridge
<ber:linearTopologyConnection

id="ltc_1"

name="Pipeline

segments

type="edgeToEdge">
<ber:startRole id="start_r_asltc_1" name="Start pipeline segment role">
<ber:ftItem refId="ft_5012100"/>
</ber:startRole>
<ber:endRole id="end_r_asltc_1" name="End pipeline segment role">
<ber:ftItem refId="ft_5012100"/>
</ber:endRole>
<ber:lineSymbolizer>
<se:Stroke>

Implementation Guide

brige"

IMPLEMENTATION GUIDE VERSION 9.6

225

<se:SvgParameter name="stroke">#880000</se:SvgParameter>
<se:SvgParameter name="stroke-width">1</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
</ber:linearTopologyConnection>

Example: Definition of node to node bridge
<ber:linearTopologyConnection

id="ltc_2"

name="Station

-

Valve

bridge"

type="nodeToNode">
<ber:startRole id="start_r_asltc_2" name="Station role">
<ber:ftItem refId="ft_5010100"/>
</ber:startRole>
<ber:endRole id="end_r_asltc_2" name="Valve role">
<ber:ftItem refId="ft_5011100"/>
</ber:endRole>
<ber:lineSymbolizer>
<se:Stroke>
<se:SvgParameter name="stroke">#990000</se:SvgParameter>
<se:SvgParameter name="stroke-width">4</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
</ber:linearTopologyConnection>

Implementation Guide

226

17 – TOPOLOGY

Implementation Guide

Chapter 18
Reports

IMPLEMENTATION GUIDE VERSION 9.6

18.

229

Reports
LIDS system supports reporting functionality for feature types including master-detail report types.
Reporting service is based on Jasper Reports tool. It is a Java based open source reporting library with
flexible data sources and wide range of output formats. Output formats include PDF, HTML, XLS, CSV
or RTF. Data used to populate a report may be supplied either as input parameter from a user program,
or as a data source defined within report.

Report Design
JRXML

Document

SQL

PDF, HTML, XLS,
RTF, TXT

EJB

JasperReports

Document
XML
The report definitions are stored as a JasperReports templates.
The application server fills that templates with a concrete data when a request on a report is invoked.
However, some additional metadata is needed to make the report template fully functional. The reporting
service is configured by reportArray element in presentation.xml file. Reporting service reads
configuration from this file including jasper report template file location.

18.1 Reporting Services Architecture
The architecture behind reporting service is a classical 3-tier architecture:
• The user may select a particular report template within client application including output format of
the response.
• A report request is sent to the LIDS Application Server.
• Application server selects an appropriate JasperReports template and sends a query to the storage
engine.
• The data returned from storage is used by LIDS Application Server to populate the report.
• The report is outputted in specified format to the response.
• Client application receives the response and opens it the associated viewer.

Implementation Guide

230

18 – REPORTS
LIDS Explorer/
LIDS Edit
Get
report
rp_1

report.pdf

10

Database

LIDS AS

1
Report

WFS

2
Select Jasper
template 3

Templates

4
Get features
as XML

6a
5

7a
?
8

7b
6b
External GIS

9

18.2 Reports Kinds
Currently LIDS Application Server supports various kinds of reports classified by following properties:
• Static or dynamic
• Simple or masterDetail
• WFS based or SQL based
Report type
Dynamic
MasterDetail
WFS based
SQL based
staticReport
No
No
Yes
No
dynamicReport
Yes
No
Yes
No
masterDetailReport
No
Yes
Yes
No
dynamicMasterDetailReport
Yes
Yes
Yes
No
jasperReport
No
Yes
No
Yes
dynamicJasperReport
Yes
Yes
No
Yes

18.2.1

SQL based report data source
The data source for reporting is specified bywriting SQL statement directly.

18.2.2

WFS based report data source
The data source for reporting is a XML document generated by the Web Feature Service. This brings
advantages compared to the direct database querying approach:
• All security constrains are applied
• Independent of data layer (LIDS native SQL-database, external GIS)
• Virtual attributes are evaluated during request processing
• Designing the reports using metadata entities not the database tables/columns

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

231

However, this scenario brings a significant disadvantage when designing complex multi-join reports.
Every detail section of master-detail reports must be modeled as an association.

18.2.3

Static reports
A static report definition has a static defined report template including query that selects the data. It
means that the layout of the report will always look the same (the same data fields) and contain the same
type of data (particular feature types and their attribute columns). This type of reports may be useful for
features that change over the time. This is the simplest possible report to create.

18.2.4

Dynamic reports
The report template is dynamically modified by the request sent from client as well as query that selects
the data. User usually selects a list of features from client application and sends a report request for these
features. The report template is modified to include feature specific attributes, custom title etc.
This type of reports are very complex and difficult to create. Jasper report templates for these reports
should be designed to be able to visualize all kinds of feature types and unlimited number of attribute
columns. The LIDS Application Server contains universal set of dynamic reports with portrait and
landscape layout, therefore these report templates should be sufficient for most cases and projects.

18.2.5

Master–detail reports
Master–detail reports are special kind of static reports that contains detail section for every master
record. It represents master-detail view on data using feature associations.
Dynamic MasterDetail report is same as MasterDetail report, but features from master role are given by
ogc filter in report service request and feature types of master role of the relation assoc.

18.3 Reporting Service Metadata
Besides report template (JasperReports XML-file) the application server needs to know additional
informations for each report template. Generally, these metadata tells the reporting service the name of
the report, its description, name of the report template file, supported output formats and user defined
parameters. Each type of report has also several other properties.

18.3.1

Dynamic reports
Dynamic reports are identified by dynamicReport element followed by report identifier, its displayable
name and page orientation.
• description element contains simple description of this report.
• outputFormatArray contains outputFormat elements that defines possible formats of report files.
The output format element has one optional attribute named default which is set to false as default.
If the report request does not specify output format then default one is taken.

Implementation Guide

232
•

•
•

18 – REPORTS
inputParameterArray contains a list of inputParameter elements. Users may set these parameters
in report request. Parameters are then used inside jasper report templates. The common usage for
these parameters is report title, page footers, employee id etc. The id attribute serves as a unique
identifier inside each report and needs to be referenced from jasper report template with exactly the
same name. name attribute is a displayable name of this attribute used inside client environment.
nillable attribute defines, if is a parameter is mandatory or not. description and defaultValue
elements are self explaining. dataType defines data type of parameter. Currently supported data
types include decimal, string, date and codeListRefExt for codelist reference.
templateName contains jasper template file name which is located inside resources/report
directory.
attributeTemplateName contains XML Stylesheet file name located inside resources/report
directory. This file transforms jasper template file for each report request and fills feature type name
and attributes information.

Example: Dynamic report configuration (presentation.xml).
<ber:reportArray>
<ber:dynamicReport id="rp_1" name="Default Portrait" orientation="portrait"
default="true">
<ber:description>Default Portrait Report Template</ber:description>
<ber:outputFormatArray>
<ber:outputFormat default="true">pdf</ber:outputFormat>
<ber:outputFormat>html</ber:outputFormat>
<ber:outputFormat>csv</ber:outputFormat>
<ber:outputFormat>xls</ber:outputFormat>
</ber:outputFormatArray>
<ber:inputParameterArray>
<ber:inputParameter id="TITLE" name="Report Title">
<ber:description>The report title</ber:description>
<ber:defaultValue>Feature Report</ber:defaultValue>
</ber:inputParameter>
<ber:inputParameter id="MODEL_NAME" name="Model Name">
<ber:description>The name of the project (footnote)</ber:description>
<ber:defaultValue>LIDSdemo</ber:defaultValue>
</ber:inputParameter>
<ber:inputParameter id="DATE1" name="Some date">
<ber:description>Date for filtering the data</ber:description>
<ber:defaultValue>2010-10-01 23:59:59</ber:defaultValue>
<ber:dataType>
<ber:date/>
</ber:dataType>
</ber:inputParameter>
<ber:inputParameter id="DATE2" name="Some date">
<ber:description>Date for filtering the data</ber:description>
<ber:defaultValue>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

233

<ber:currentDate/>
</ber:defaultValue>
<ber:dataType>
<ber:date/>
</ber:dataType>
</ber:inputParameter>
<ber:inputParameter id="YEAR" name="Report Year" nillable="false">
<ber:description>Used as title text</ber:description>
<ber:defaultValue>2013</ber:defaultValue>
<ber:dataType>
<ber:decimal precision="4" scale="0"/>
</ber:dataType>
</ber:inputParameter>
<ber:inputParameter id="MATERIAL" name="Material type">
<ber:description>Used for material type</ber:description>
<ber:dataType>
<ber:codeListRefExt>
<ber:codeList xlink:href="model.xml#cl_204"/>
<ber:displayColumn xlink:href="model.xml#ca_20402"/>
</ber:codeListRefExt>
</ber:dataType>
</ber:inputParameter>
</ber:inputParameterArray>
<ber:templateName>default.template.jrxml</ber:templateName>
<ber:attributeTemplateName>default.template.xsl</ber:attributeTemplateName>
</ber:dynamicReport>

18.3.2

Relative path to resources
It’s possible to include resources in reports by specifying the path relative to application or resource
root.
Two new string parameters can be used now:
$P{APPLICATION_ROOT} - root of LIDS metadata

or
$P{RESOURCE_ROOT} - root of LIDS resources) in your path

Don't forget to declare parameter in your report:
<parameter name="RESOURCE_ROOT" isForPrompting="false" class="java.lang.String"/>

Implementation Guide

234

18 – REPORTS

Example of usage:
<imageExpression><![CDATA[$P{RESOURCE_ROOT}+"/report/file.jpg"]]></imageExpression>

Packaged project will use relative path as for all other resources.

18.4 Limitations
•
•
•
•

Master–detail reports may contain only one level deep detail section.
Since data are processed sequentially the charting functionality is limited. Charts use so-called
groups of ordered data.
In case of jasperReport and dynamicJasperReport the user access rights are not evaluated.
LIDS Browser supports jasperReport and dynamicJasperReport only.

18.5 Creating Simple Report
The simplest approach is to create a report template using JasperSoft Studio design tool – an open source
WYSIWYG report designer for JasperReports. It is used to design templates even with very complex
layout.
This chapter describes step-by-step process how to create simple static report using JasperSoft Studio
design tool, how to register such a report in LIDS Application Server environment and how to request
that report within LIDS Explorer.

18.5.1

Creating report template using JasperSoft Studio
The iReport is capable of querying multiple data sources including databases using JDBC driver.
Fortunately there is LIDS JDBC driver available that can process simple SQL-queries by translating
them into wfs:GetFeature requests.

JasperSoft Studio supports basic SQL queries with WHERE, ORDER BY, GROUP BY, HAVING, and
currently also single JOIN conditions.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

235

JasperSoft Studio installation and setup
Download JasperSoft Studio from the following page:
http://community.jaspersoft.com/project/jaspersoft-studio/releases
Install the application as usual and launch it.
First thing that needs to be done is to create data source for the report. Select CreateData Adapter.

Inside the Data Adapter Wizard choose Database JDBC Connection and set connection to an existing
database (lidsdemo) with your username and password:

Then we need to install LIDS JDBC driver to be able to connect to the application server and acquire
some data. Go to Driver Classpath, then click Add and set path to jar files. Finally you can test your
connection and click Finish.

Implementation Guide

236

18 – REPORTS

Creating report
After creating the connection you may create an actual report from scratch or use predefined templates:
1. From main menu select File → New → Jasper Report.
2. On next dialog select template (we recommend “Blank A4 Table based”), click Next. In the
following dialog, fill in the name of the template. Default storage path for templates is usually:
C:\Users\user_name\JaspersoftWorkspace\MyReports
3. In the following Data Source dialog select your Data Adapter created before.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

237

4. Now you need to specify the query that will select data from LIDS-system. You can write SQL
query in tab Texts yourself, or you can use tab Outline, where you have predefined query
structure and by right-click on the operator you can choose tables or expressions. The tab
Diagram shows the query as a diagram. If you are unsure of available columns (attributes) select
all of them by * character.
Example: SQL query for static report.
SELECT c_g_city_part, COUNT(*)
FROM PARCEL
GROUP BY c_g_city_part;

5. Proceed to the next step where you may select available columns. Select the columns you like
using arrow icons. You can change order of fields with up and down buttons on the left.

Implementation Guide

238

18 – REPORTS
6. Next step allows you to group fields.

7. Click Finish. Your basic report template is created and you may customize it to suit your needs.
The template will be saved as a JRXML-file.

Viewing report result
You may see the filled report with actual data inside JasperSoft Studio environment. There are three
modes – Design, Source and Preview. Design mode allows you to modify your report, add or remove
Fields, etc. In the Source mode you can see XML structure of the report and you can directly edit report
definition and finally Preview mode generates preview of the report filled with actual data. In Preview
mode , it’s possible to fill values for input parameters which are used in given report as well.

Extension and adjustment of the report layout
If you choose predefined template for your report, you will probably need to make some adjustments. If
you use blank template, you will have to design your report from scratch. In Design mode, you can
remove or add fields to your report, add some basic elements to layout and change formatting.
Ultimate button which enables you to change source data for the report is called “Edit, Query, Filter and
sort options” and can be found in the Properties panel → Report → Dataset (bottom – right) when
selecting main node from the Outline panel (bottom – left).

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

239

In the dialog that appears, you can perform these operations:
• specify a new SQL query
• edit existing SQL query
• update a list of fields for current query definition by means of Read Fields button
• update individual fields properties in tab Fields in the bottom part of the dialog by means of
Edit button, e.g. field description, field class type
• add or edit attributes for sorting in tab Sorting in the bottom part of the dialog
• view all and edit properties for custom parameters in tab Parameters in the bottom part of the
dialog
• run data preview based on current query definition
After clicking on OK button new or updated definition is used for selected report.

Implementation Guide

240

18 – REPORTS

Layout of the report in main window is divided to multiple parts. Generally report may be composed of
these bands (parts):
• Title – opening report title; it's created only once a report
• Page Header – header of pages; the page header appears on all printed pages in the same position
• Column Header – the column header band is printed at the beginning of each detail band
• Detail – represents data content of report; report may contain more "detail" sections if report
has subreports
• Group Header – a report can contain zero or more group bands, which permit the collection of
detail records in real groups. A group header is always accompanied by a group footer (both can
be independently visible or not) different properties are associated with a group.
• Group Footer – the group footer band completes a group; usually it contains fields to view
subtotals or separation graphic elements, such as lines.
• Column Footer – the column footer band appears on at the end of every detail band
• Page Footer – the page footer band appears on every page where there is a page header
• Summary – the summary band allows to insert fields concerning total calculations, means, or
whatever you want to insert at the end of the report.
• Last Page Footer – If you want to make the last page footer different from the other footers, it
is possible to use the special last page footer band.
• Summary – The summary band allows to insert fields concerning total calculations, means, or
whatever you want to insert at the end of the report.
• Background – The background band was introduced after insistent requests from many users
who wanted to be able to create watermarks and similar effects.
On the picture below you can see an illustration of the standardly used bands for 3 pages report.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

241

You can either remove some of bands or add another. By changing their width you define the space
between parts or single elements in the final report. For example you need to change the width of Detail
section to narrow (or remove) the space between table rows.
The best way to control the bands is via Outline panel. There is a list of bands and their components.
After selecting one of the bands or component you can set the size or position by means of Properties
panel (in Appearance tab) or with using of graphical elements in Design panel. You can also remove
band or field from report by right-click on the field in layout or in Outline panel and then use Delete
function.





If Outline panel is not available it's possible to activate it again from menu Window -> Show view ->
Other ... select General -> Outline.

It is recommended to use blank templates because problem with background images may occur when
exporting report from LIDS.

Implementation Guide

242

18 – REPORTS

You can add Basic and Composite Elements to layout from Palette panel (up-right) by drag and drop.
This contains for example Text Field, Static Text, Image, Break, Line, Chart, Map, Frame, Rectangle,
Subreport, Page numberand other. For every field object in the layout JasperSoft Studio creates a text
field element and sets the text field expression for that element to $F{NAME}. This text can be further
formatted in Properties → TextField → Appearance.



If you use blank template you have to add all fields to layout yourself. You can do that just by dragging
them from the list in Fields section in Outline panel to the main window to Detail section. Automatically
there will be also headers created in Column header section.
For each report element is possible to set many properties. The best way how to set or edit properties is
to use Properties panel. The enumeration of properties is very wide and is divided to several tabs in the
panel – as you can see on the picture below. Detail description of individual properties can be found in
JasperSoft Studio help.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

243

Inserting company logo
You can enrich your report with images, for example your company´s logo.
1. Choose Image from Basic Elements in Pallete and drag it to the section of your choice. The
following dialog appears:

2. Select Absolute Path and choose the path to your picture, which should be stored on your local
driver. Click OK.
3. You can now move and resize your picture, either with mouse or in the Properties panel.
Using styles and conditional styles
It can be useful to define styles for repeated use for more report elements. Creating new style is
possible from Outline panel, under the Styles list a fubction Create style is available. Then you can
define or adjust style characteristics via Properties panel.
If you want to define conditional style first create style and then from context menu over created
style choose Create conditional style. Then it’s necessary to define conditon via Expression Editor
dialog (e.g. $F{ATTRIBUTE1}=0 ) and finally you can define or adjust style characteristics via
Properties panel.
Assigning the style to some report element is done using Properties panel as well. After selecting
given report element use Appearance tab and then select required style by means of Style combobox.

Implementation Guide

18 – REPORTS

244

Using more datasets in report – using of Table element
If you want to create report with more queries (with more various datasets) you can utilize Table
element for it. The procedure how to add and configure “table” dataset and layout is below.
1.

Choose Table from Basic Elements in Pallete and drag it to the section of your choice (typically
to some Detail band).

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

245

2. The following dialog appears. You will probably have to choose creating table using a new
dataset. Click on Next button.

3. Enter name for new dataset (you can use the name predefined by system). Click on Next button.

4. Select the Data Adapter and then definition of the query is same as when creating a report (see
chapter 18.5.1.2 step 4). Click on Next button always.

Implementation Guide

246

18 – REPORTS

5. Last dialog allows you to set/modify simple formatting for the table. At the bottom of the dialog
checkboxes for activating/deactivating table sections are available. Set them according to your
needs (typically based on dataset definition, e.g. Group Header and Group Footer has sense only
if dataset uses grouping). Next sections in the dialog allow to set color schema or color definition
for individual table sections, style for cell borders etc. Finish whole procedure by clicking on
Finish button. The table will be added to the selected band.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

247

6. You can get the similar result as on picture below. The table element is placed to selected band
with choosen colour schema and with predefined size and position. In Outline panel new
“dataset” and “table” elements are added automatically as well.

7. Tuning of all table and table cells properties is possible by double click on given table. Design tab
for table appears and individual properties can be modified both in graphic window or by means of
Properties panel for selected row, column or cell.

Implementation Guide

248

18 – REPORTS

8. Example report with 4 tables (datasets), each placed in separate detail band you can see on picture
below.

Creating report with subreports
If you want to create report with subreport – it means with part which displayes data from subquery related to records from
main report query – you can use 2 basic techniques.

a/ Creating subreport with using Table element
Table element can be used for subreport as well. Place and adjust Table element in the similar way as described
in "Using more datasets in report – using of Table element" chapter. If you use Table element for subreport there
are two important things to do:
• Use proper parameter in table dataset query for interconnection between subrecords and record from main
query. Example of dataset query is:
SELECT fk_attribute, attribute1, attribute2, ...
FROM table
WHERE table.fk_attribute = $P{input_parameter_for_interconnection} ….
where $P{input_parameter_for_interconnection} is parameter defined under given Dataset
• Then it is necessary to define “mapping” of parameters. For this operation you can use these steps:
o Find element Table in given Detail band and click on it to display Properties panel
o In Properties panel switch to Dataset tab and use Parameters button
o Click on Add or Edit button, select appropriate parameter and fill in proper Parameter
Expression, typically in this syntax $F{attribute_from_main_query}, e.g. $F{SID} – see on
picture below.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

249

b/ Creating subreport using Subreport element
Select Subreport element from Pallete and use these steps from dialog for creating subreport:
• Create a new report
• Select report template
• Select or fill in report file name
• Select data adapter
• Define query – in query you should define clause which ensure interconnection between subreport and
main report; typically by means of parameter used in WHERE condition, e.g.
WHERE fk_attribute = $P{Norma}, where fk_attribute can be foreign key from subqeury table pointing
on primary key in main query table
• Select report fields and group by fields
• Specify connection
• Add dataset parameters – add parameter(s) used within query for interconnection between subreport and
main report
After clicking on Finish button subreport element is created and added to selected detail band.
Then it is necessary to define “mapping” of parameters. For this operation you can use these steps:
• Find element Subreport in given Detail band and click on it to display Properties panel
• In Properties panel switch to Subreport tab and use Edit Parameters button
• Click on Add or Edit button, select appropriate parameter and fill in proper Parameter Expression,
typically in this syntax $F{attribute_from_main_query}, e.g. $F{SID}.
Implementation Guide

250

18 – REPORTS
Dynamic reports

Several changes must be made to report template in order to create a dynamic report. For dynamic
reports, it is necessary to define and use SID_LIST report parameter. It is a collection of LIDS features
SID values. They will be provided dynamically by user when performing the report. The SID_LIST
definition and usage is illustrated at following pictures.
If this type of report is requesting on the server, in the request are definied WFS queries. In report filling
process, parameter SID_LIST will be filled with collection of SIDs of feature collection responded from
WFS.
SID_LIST parameter is defined as java.util.Collection class. If this class can not be found in combobox
list fill down the value manually.

SID_LIST parameter also needs to be used in Query. Here sid is column name in LIDS DB table
w_pumpstat. $X{IN, sid, SID_LIST} means ‘sid IN SID_LIST’ but must be written this way as this is
JasperReports collection syntax.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

251

Example: SQL query for dynamic report.
SELECT *
FROM W_PUMPSTAT
WHERE $X{IN, sid, SID_LIST};

18.5.2

Registering report inside LIDS Application Server
When you are satisfied with your report template design, you may place that report inside LIDS
Application Server to make the report available in LIDS Explorer. This section describes the steps
needed to accomplish this task.

JasperSoft Studio reports
Report type JasperReport allows to generate report from native jasper report template format which uses
sql query language. Data are queried directly from database.

Implementation Guide

252

18 – REPORTS

Example: Static report (Blank_A4_jasper.jrxml) from JasperSoft Studio.
http://jasperreports.sourceforge.net/xsd/jasperreport.xsd" name="Blank_A4_jasper"
pageWidth="595" pageHeight="842" columnWidth="555" leftMargin="20" rightMargin="20"
topMargin="20" bottomMargin="20" uuid="6360915a-5381-42a6-9553-dec75020a510">
<property name="com.jaspersoft.studio.data.sql.tables" value=""/>
<property name="com.jaspersoft.studio.data.defaultdataadapter"
value="LIDSDEMO"/>
<queryString language="SQL">
<![CDATA[SELECT "W_PUMPSTAT"."X_COORD",
"W_PUMPSTAT"."Y_COORD"
FROM "W_PUMPSTAT"]]>
</queryString>
<field name="X_COORD" class="java.math.BigDecimal"/>
<field name="Y_COORD" class="java.math.BigDecimal"/>
<background>
<band splitType="Stretch"/>
</background>
<title>
...
<textFieldExpression><![CDATA["NADPIS"]]></textFieldExpression>
...
<textFieldExpression><![CDATA[$F{X_COORD}]]></textFieldExpression>
...
<textFieldExpression><![CDATA[$F{Y_COORD}]]></textFieldExpression>
...
</jasperReport>

Example: Dynamic report (Blank_A4_jasper.jrxml) from JasperSoft Studio.
<?xml version="1.0" encoding="UTF-8"?>
<!-- Created with Jaspersoft Studio version 6.3.1.final using JasperReports Library
version 6.3.1 -->
<!-- 2017-03-13T16:50:32 -->
<jasperReport xmlns="http://jasperreports.sourceforge.net/jasperreports"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://jasperreports.sourceforge.net/jasperreports
http://jasperreports.sourceforge.net/xsd/jasperreport.xsd"
name="Blank_A4_jasper_dyn" pageWidth="595" pageHeight="842" columnWidth="555"
leftMargin="20" rightMargin="20" topMargin="20" bottomMargin="20" uuid="6360915a5381-42a6-9553-dec75020a510">
<property name="com.jaspersoft.studio.data.sql.tables" value=""/>
<property name="com.jaspersoft.studio.data.defaultdataadapter" value="One
Empty Record"/>
<parameter name="SID_LIST" class="java.util.Collection">
<defaultValueExpression><![CDATA[]]></defaultValueExpression>
</parameter>
<queryString language="SQL">

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

253

<![CDATA[SELECT *
FROM "W_PUMPSTAT"
WHERE $X{IN,sid,SID_LIST}]]>
</queryString>
<field name="X_COORD" class="java.math.BigDecimal"/>
<field name="Y_COORD" class="java.math.BigDecimal"/>
...
</jasperReport>

Application Server and Presentation.xml
After you are done with report customizations place the JasperReports template (.jrxml file) inside
Resources/Report directory of the LIDS Application Server.
The last thing that needs to be done is to register a newly created report inside project Presentation.xml
file. These reports are labelled as <ber:jasperReport> and <ber:dynamicJasperReport>.
Example: Registration of static report Blank_A4_jasper.jrxml inside presentation.xml.
<ber:jasperReport id="jrp_tibco" name="Test TIBCO Jasper"
orientation="portrait">
<ber:description>report in jasper format</ber:description>
<ber:outputFormatArray>
<ber:outputFormat default="true">pdf</ber:outputFormat>
<ber:outputFormat>html</ber:outputFormat>
<ber:outputFormat>csv</ber:outputFormat>
<ber:outputFormat>xls</ber:outputFormat>
</ber:outputFormatArray>
<ber:templateName>Blank_A4_jasper.jrxml</ber:templateName>
</ber:jasperReport>

Example: Registration of dynamic report Blank_A4_jasper_dyn.jrxml inside presentation.xml.
<ber:dynamicJasperReport id="dyn_pump" name="Pumping station"
orientation="portrait">
<ber:description>SID test of dynamic jasper</ber:description>
<ber:outputFormatArray>
<ber:outputFormat default="true">pdf</ber:outputFormat>
<ber:outputFormat>html</ber:outputFormat>
<ber:outputFormat>csv</ber:outputFormat>
<ber:outputFormat>xls</ber:outputFormat>
</ber:outputFormatArray>
<ber:templateName>Blank_A4_jasper_dyn.jrxml</ber:templateName>

Implementation Guide

254

18 – REPORTS
<ber:featureTypeArray>
<ber:featureType xlink:href="model.xml#ft_5010100"/>
</ber:featureTypeArray>
</ber:dynamicJasperReport>

Report from software iReport
A few modifications to the report template must be done if the report is created in older software e.g.
iReport 5.6.0. You have to replace database names with metadata identifications of these attributes.
Open the report template JRXML-file with you favorite text editor.
If you rename the JasperReports template file be sure that the name attribute inside jasperReport element
contains the same name.
Find field elements section and for each field do the following:
1. Change the name of the field to the metadata identification:
• If it is a feature system attribute, prefix it with */@.
Example: createDate → */@createDate
• If it an ordinary feature attribute that is not of a codelist type, change it to suit the
*/<at_identifier> format.
Example: LENGTH → */at_52013
• If it is a codelist feature attribute, change it to suit the
*/<at_identifier>/<codelist_display_column> format.
Example: C_G_CITY_PART → */at_5010004/ca_00402
2. If the class attribute contains anything else than java.lang.String, change it to the
java.lang.String value.
3. Search for textFieldExpression element that contains the old name of the field and change the
value to the new one.
4. If the class attribute of the textFieldExpression element contains anything else than
java.lang.String, change it to the java.lang.String value.
Application Server and Presentation.xml
After you are done with report customizations place the JasperReports template (.jrxml file) inside
Resources/Report directory of the LIDS Application Server.
The last thing that needs to be done is to register a newly created report inside project Presentation.xml
file.
These
reports
are
labelled
as
<ber:staticReport>,
<ber:dynamicReport>,
<ber:masterDetailReport> or <ber:dynamicMasterDetailReport>.
Example: Static report section may look like the following.
<ber:staticReport id="rp_my" name="Main Pipeline Segment Report"
orientation="portrait">
<ber:description>Main Pipeline Segment Report</ber:description>
<ber:outputFormatArray>
<ber:outputFormat default="true">pdf</ber:outputFormat>
<ber:outputFormat>html</ber:outputFormat>
<ber:outputFormat>csv</ber:outputFormat>
<ber:outputFormat>xls</ber:outputFormat>
</ber:outputFormatArray>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

255

<ber:templateName>my_report.jrxml</ber:templateName>
<ber:reportQueryArray>
<ber:reportQuery>
<ber:featureType xlink:href="model.xml#ft_5012100"/>
<ber:attributeArray>
<ber:attribute xlink:href="model.xml#at_5010004"/>
<ber:attribute xlink:href="model.xml#at_5012002"/>
<ber:attribute xlink:href="model.xml#at_5012102"/>
</ber:attributeArray>
<ogc:Filter>
<ogc:PropertyIsBetween>
<ogc:PropertyName>at_5012102</ogc:PropertyName>
<ogc:UpperBoundary>
<ogc:Literal>9003</ogc:Literal>
</ogc:UpperBoundary>
<ogc:LowerBoundary>
<ogc:Literal>9000</ogc:Literal>
</ogc:LowerBoundary>
</ogc:PropertyIsBetween>
</ogc:Filter>
</ber:reportQuery>
<ber:orderBy>
<ber:orderByItem direction="ascending">
<ber:commonAttribute attributeName="at_5012102">
<ber:featureType featureTypeName="ft_5012100"/>
</ber:commonAttribute>
</ber:orderByItem>
</ber:orderBy>
</ber:reportQueryArray>
</ber:staticReport>

18.5.3

Testing report
The report should be available in client application. However, if you want to test the report if it works
properly, you can use LIDS Ultra Light Client that can be found on
http://<LIDS_AS_URL>/utils/request.html address. Report Service section allows the user to query the
server for reports.

Implementation Guide

256

18 – REPORTS

Implementation Guide

Chapter 19
Tools

IMPLEMENTATION GUIDE VERSION 9.6

19.

259

Tools
It’s possible to define set of project specific tools using the tool.xml definition. These tools are available
in LIDS Edit and LIDS Explorer clients. The tools define their own icons and are organized into tool
paletes or ribbon pages.
Common properties of individual tools and tool paletes definitions include:
• name – Title of the tool displayed as the first line in the tooltip
• description – Optional description displayed as the second line in the tooltip
• icon – References an icon representing the tool in GUI. The icons are defined in resource.xml
metadata file and stored on AS in the appropriate subdirectories of the ${project folder}lidsas/resources/icon/bmp16x16 directory.



Detailed description of all possible modules and functions which can be defined in tools is included
in LIDS Edit / Explorer user’s documentation.

19.1 Tool Palettes
Tool palettes are groups of tools created to enable tools logical arrangement. The palettes can be nested
into each other, i.e. subpalettes can be created. One tool can be included in several palettes. A definition
of a tool palette can include:
- references to the tools it contains
- separators
- reference to a superior palette (optional)
- link to an icon representing the palette in LIDS GUI.
The definitions of tool palettes are grouped together in the toolBoxArray collection.
Example: Definition of tool palettes.
<ber:toolBoxArray>
<!-- Root level tool palette definition -->
<ber:toolBox id="tb_01" name="Main toolbox">
<ber:description>Toolbox with 6 tools and 2 sub-toolboxes</ber:description>
<ber:icon xlink:href="resource.xml#ic_01"/>
<ber:subToolArray>
<ber:tool refId="ti_1"/>
<ber:tool refId="ti_2"/>
<ber:tool refId="ti_3"/>
<ber:separator/>
<ber:tool refId="ti_4"/>
<ber:tool refId="ti_5"/>
<ber:separator/>

Implementation Guide

260

19 – TOOLS
<ber:tool refId="ti_6"/>
</ber:subToolArray>
</ber:toolBox>

<!-- Tool subpalette definition -->
<ber:toolBox id="tb_011" name="Sub-toolbox 1">
<ber:description>4 tools</ber:description>
<ber:icon xlink:href="resource.xml#ic_011"/>
<ber:superToolBox refId="tb_01"/>
<ber:subToolArray>
<ber:tool refId="ti_10"/>
<ber:tool refId="ti_11"/>
<ber:tool refId="ti_12"/>
<ber:tool refId="ti_13"/>
</ber:subToolArray>
</ber:toolBox>

<!-- Another tool subpalette definition -->
<ber:toolBox id="tb_012" name=" Sub-toolbox 2">
<ber:description>3 tools</ber:description>
<ber:icon xlink:href="resource.xml#ic_012"/>
<ber:superToolBox refId="tb_01"/>
<ber:subToolArray>
<ber:tool refId="ti_20"/>
<ber:tool refId="ti_21"/>
<ber:tool refId="ti_22"/>
</ber:subToolArray>
</ber:toolBox>
</ber:toolBoxArray>

•
•
•

toolBox – Defines a tool palette.
superToolBox – Optionally references a superior palette.
subToolArray – References tools (tool) that the palette contains.

19.2 Ribbon Pages
LIDS Explorer enables selection of the menu style as ribbon. In this case the project tools definition in
toolBoxArray is ignored. It’s necessary to define section ribbonPageArray which will be used instead
of tool pallettes. The definition of individual tools is common for both modes.
The definition of ribbon cosists of:
• ribbonPage – defines the main section in the ribbon

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6
•

261

ribbonPageGroup – section inside a ribbonPage with individual tools and separators
• collapsed – optional attribute. If set to true, the ribbonPageGroup appears as collapsed list of
tools.
• icon – image on button representing the collapsed ribbonPageGroup
• description – tooltip over the button representing the collapsed ribbonPageGroup
• maxRows – if the collapsed ribbonPageGroup includes more tools than the value of this
parameter, the tools are displayed in more columns

Tool definition inside ribbon page group consists of:
• refId – reference to tool definition in toolArray
• style – optional definition
• Large – default
• SmallWithText
• SmallWithoutText
• label - optional definition; tool name is used if omitted
Example: Definition of ribbon pages.
<ber:ribbonPageArray>
<ber:ribbonPage id="rp_p1" name="Page 1">
<ber:ribbonPageGroup id="rpg_g1" name="Group 1">
<ber:tool refId="ti_1" style="Large" label="Tool 1"/>
<ber:tool refId="ti_2" style="SmallWithText" label="Tool 2"/>
<ber:separator/>
<ber:tool refId="ti_3"/>
</ber:ribbonPageGroup>
<ber:ribbonPageGroup id="rpg_g2" name="Group 2">
<ber:tool refId="ti_4"/>
</ber:ribbonPageGroup>
</ber:ribbonPage>
<ber:ribbonPage id="rp_p2" name="Page 2">
<ber:ribbonPageGroup id="rpg_g3" >
<ber:tool refId="ti_5" style="SmallWithText"/>
<ber:tool refId="ti_6" style="SmallWithoutText"/>
</ber:ribbonPageGroup>
</ber:ribbonPage>
</ber:ribbonPageArray>

Implementation Guide

262

19 – TOOLS

Implementation Guide

Chapter 20
Display Model

IMPLEMENTATION GUIDE VERSION 9.6

20.

265

Display Model
Display model used for plotting is a special kind of setting (visualisationmodel.xml). It specifies:
• what graphic data will be plotted - by reference to a template, saved data selection, backdrop map
or external data,
• what symbology will be used for displaying this data - by reference to a theme
Order of selected templates, saved data selections, backdrop maps and references to external data inside
display model specifies their draw priority when plotting (first of them will be drawn over the others).
For templates and saved data selections it is possible to change:
• order of contained feature types,
• for each feature type its visibility (to draw it or not),
• for each feature type, visibility and order of its components,
• assigning display model to zoom features, references to zoomed area, references to detail and
references to cross section - an appropriate data will be plotted by assigned display model.

20.1 Tips
After migration display model from LIDS 6 it is not possible to cover automatically some original
behavior. Here are some tips how to handle it.



LIDS6 is able to draw plot features in order across plot definitions.
Proposed solution:
• detach surface features from each plot definition that means for each original plot definition create
two templates: one with surface feature types, second with other feature types
• enter the template with surface feature types to the end of display model so surface features will
always be drawn under other features.



LIDS6 defines displayable attributes as features so they have their own priority independent on master
feature.
Proposed solution:
If a displayable attribute DA1 of feature type F1 should „jump over“ another feature types (contained
in the same or another template)
• define visible=true for its master graphics and visible=false for this graphic tag type in the template
• add new template into display model containing this feature type definition in this way:
visible=false for its master graphics and visible=true for this graphic tag type
• enter this new template before templates containing feature types that should be drawn under DA1

Implementation Guide

266

20 – DISPLAY MODEL

Implementation Guide

Chapter 21
Profile

IMPLEMENTATION GUIDE VERSION 9.6

21.

269

Profile
Metadata extension Profile can be used for 2 purposes: longitudinal profile and TELCO Service Report.
In both cases, the result is a graphical representation of the "path" with edges, nodes, and other graphical
elements. The longitudinal profile options are similar to those in the LIDS V6 system. For TELCO
Service Report, it is possible to display the path of a specific service and information about individual
elements. Metadata extension has definition in XML (profile.xml) and for user defined templates is used
new kind of XML setting – “Profile template”. Extension definition specifies:
• what graphic data will be used as nodes and edges,
• what symbology will be used for displaying this data
• what semantic informations will be visible in profile

21.1 Tips
For setting symbology properties of displayed graphical elements for metadata template use dialog
Settings and saving modified template – created and saved template XML can be added into metadata
templates in profile.xml

21.2 Using profile definition in „Change Coordinates – Table“
Window Change Coordinates – Table includes 3D preview, if 3D line was selected. The content of the
preview can be tuned the same way as longitudinal profile. It’s necessary to use following hardcoded
ids in profile.xml:
• "generic3D" for template
• "node3D" for nodes
• "edge3D" for edges

Implementation Guide

270

21 – PROFILE
The preview can look like this in such case:

Example: Definition for the screenshot above
<?xml version="1.0" encoding="UTF-8"?>
<ber:modelProfile xmlns:ber="http://www.berit.com/ber"
xmlns:xlink="http://www.w3.org/1999/xlink"
xmlns:se="http://www.opengis.net/se"
xmlns:sld="http://www.opengis.net/sld">
<ber:version>
<ber:metadata>1</ber:metadata>
<ber:minClient>8888</ber:minClient>
<ber:minAS>12517</ber:minAS>
</ber:version>
<ber:profileDefinition kind="longitudinalProfile" tracingTolerance="1.5">
<ber:options>
<ber:defaultSymbology>
<ber:pointSymbolizer>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ber_LIDSdemo/64/centercenter"/>
<se:Format/>
</se:ExternalGraphic>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

271

</se:Graphic>
<ber:rgbColor>#000000</ber:rgbColor>
<ber:symbolHeight>0.1</ber:symbolHeight>
</ber:pointSymbolizer>
<ber:lineSymbolizer>
<se:Stroke>
<se:SvgParameter name="stroke">#000000</se:SvgParameter>
<se:SvgParameter name="stroke-width">0</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
<ber:polygonSymbolizer>
<ber:fill>
<ber:fillStyle>none</ber:fillStyle>
</ber:fill>
<se:Stroke>
<se:SvgParameter name="stroke">#000000</se:SvgParameter>
<se:SvgParameter name="stroke-opacity">1</se:SvgParameter>
<se:SvgParameter name="stroke-width">0</se:SvgParameter>
</se:Stroke>
</ber:polygonSymbolizer>
<ber:textSymbolizer>
<se:Fill>
<se:SvgParameter name="fill">#000000</se:SvgParameter>
</se:Fill>
<ber:fontHeight>0.5</ber:fontHeight>
</ber:textSymbolizer>
</ber:defaultSymbology>
<ber:parameterArray>
<ber:parameter name="defaultNodeDepth">5.0</ber:parameter>
<ber:parameter name="defaultNodeDiameter">2.0</ber:parameter>
<ber:parameter name="defaultEdgeDiameter">0.5</ber:parameter>
</ber:parameterArray>
</ber:options>
<ber:nodes>
<ber:profileElementArray>
<ber:profileElement id="node3D">
<ber:featureTypeArray/>
<ber:attributeArray/>
</ber:profileElement>
</ber:profileElementArray>
</ber:nodes>
<ber:edges>
<ber:profileElementArray>

Implementation Guide

272

21 – PROFILE
<ber:profileElement id="edge3D">
<ber:featureTypeArray/>
<ber:attributeArray/>
</ber:profileElement>
</ber:profileElementArray>
</ber:edges>
<ber:templates>

<ber:template exaggeration="1" connectEdgeToNode="Center" id="generic3D"
name="Generic 3D template">
<ber:description>Used for Edit coordinates - table</ber:description>
<ber:templateElementArray>
<ber:templateElement>
<ber:profileElement xlink:href="node3D"/>
<ber:drawingStyle type="Symbol">
<ber:pointSymbolizer>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource
xlink:href="resource.xml#ber_LIDSdemo/35/center-center"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
<ber:rgbColor>#000000</ber:rgbColor>
<ber:symbolHeight>0.5</ber:symbolHeight>
</ber:pointSymbolizer>
</ber:drawingStyle>
<ber:parameterArray>
<ber:parameter
name="nodeBottomAltitudeFromGeometry">1</ber:parameter>
<ber:parameter name="ignoreDefaultZAltitude">1</ber:parameter>
</ber:parameterArray>
</ber:templateElement>
<ber:templateElement>
<ber:profileElement xlink:href="edge3D"/>
<ber:drawingStyle type="Linear"/>
<ber:parameterArray>
<ber:parameter name="edgeAltitudeFromGeometry">1</ber:parameter>
<ber:parameter name="showEdgeInnerVertices">1</ber:parameter>
<ber:parameter name="ignoreDefaultZAltitude">1</ber:parameter>
</ber:parameterArray>
</ber:templateElement>
</ber:templateElementArray>
<ber:baseline verticalOffset="10">
<ber:drawingStyle>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

273

<ber:lineSymbolizer>
<se:Stroke>
<se:SvgParameter name="stroke">#FFFFFF</se:SvgParameter>
<se:SvgParameter name="stroke-width">1</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
</ber:drawingStyle>
<ber:nodeMileage>
<ber:mark length="1.3" verticalOffset="1.3">
<ber:drawingStyle>
<ber:lineSymbolizer>
<se:Stroke>
<se:SvgParameter name="stroke">#FFFFFF</se:SvgParameter>
<se:SvgParameter name="stroke-width">2</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
</ber:drawingStyle>
</ber:mark>
<ber:value verticalOffset="2">
<ber:textStyle anchorPoint="right-center" orientation="Vertical"
format="{0:0.00}">
<ber:drawingStyle>
<ber:textSymbolizer/>
</ber:drawingStyle>
</ber:textStyle>
</ber:value>
</ber:nodeMileage>
<ber:constantMileage>
<ber:mileageDefinition startValue="0" step="5"/>
<ber:mark length="1" verticalOffset="0.5">
<ber:drawingStyle>
<ber:lineSymbolizer>
<se:Stroke>
<se:GraphicStroke>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="system.linestyle#solid"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
</se:GraphicStroke>
<se:SvgParameter name="stroke">#FFFFFF</se:SvgParameter>
<se:SvgParameter name="stroke-width">0</se:SvgParameter>
</se:Stroke>

Implementation Guide

274

21 – PROFILE
</ber:lineSymbolizer>
</ber:drawingStyle>
</ber:mark>
<ber:value verticalOffset="1.5">
<ber:textStyle anchorPoint="center-top" orientation="Horizontal">
<ber:drawingStyle>
<ber:textSymbolizer>
<se:Fill>
<se:SvgParameter name="fill">#FFFFFF</se:SvgParameter>
</se:Fill>
<ber:fontHeight>0.5</ber:fontHeight>
</ber:textSymbolizer>
</ber:drawingStyle>
</ber:textStyle>
</ber:value>
</ber:constantMileage>
</ber:baseline>
<ber:verticals virtualNodes="true">
<ber:drawingStyle>
<ber:lineSymbolizer>
<se:Stroke>
<se:SvgParameter name="stroke">#0080FF</se:SvgParameter>
<se:SvgParameter name="stroke-width">0</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
</ber:drawingStyle>
</ber:verticals>
<ber:turns arrowLength="1"/>
<ber:semanticDataArray>

<ber:semanticData legendHorizontalOffset="1.5" legendVerticalOffset="0"
type="Verticals" verticalOffset="5">
<ber:border>
<ber:drawingStyle>
<ber:polygonSymbolizer/>
</ber:drawingStyle>
</ber:border>
<ber:textStyle orientation="Vertical" anchorPoint="center-center"
format="{0:0.00}">
<ber:drawingStyle>
<ber:textSymbolizer>
<se:Font>
<se:SvgParameter name="font-family">Times New
Roman</se:SvgParameter>
</se:Font>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

275

<se:Fill>
<se:SvgParameter name="fill">#000000</se:SvgParameter>
</se:Fill>
<ber:fontHeight>1</ber:fontHeight>
<ber:mask>
<ber:style>fill</ber:style>
</ber:mask>
</ber:textSymbolizer>
</ber:drawingStyle>
</ber:textStyle>
<ber:rowDefinitions>
<ber:rowDefinition>
<ber:label horizontalOffset="1" name="Altitude [m]">
<ber:textStyle orientation="Vertical" anchorPoint="centerbottom">
<ber:drawingStyle>
<ber:textSymbolizer/>
</ber:drawingStyle>
</ber:textStyle>
</ber:label>
<ber:profileAttribute xlink:href="bottomAltitude"/>
</ber:rowDefinition>
</ber:rowDefinitions>
</ber:semanticData>
</ber:semanticDataArray>
</ber:template>
</ber:templates>
</ber:profileDefinition>
</ber:modelProfile>

Implementation Guide

276

21 – PROFILE

Implementation Guide

Chapter 22
LIDS Edit / Explorer

IMPLEMENTATION GUIDE VERSION 9.6

22.

279

LIDS Edit / Explorer

22.1 explorer.xml
explorer.xml is optional extension file, which enables further configuration specific for thick clients. It's
common for LIDS Edit and LIDS Explorer.
Example: Structure of explorer.xml.
<?xml version="1.0" encoding="UTF-8"?>
<ber:modelExplorer xmlns:ber="http://www.berit.com/ber"
xmlns:xlink="http://www.w3.org/1999/xlink">
<ber:version>
<ber:metadata>1</ber:metadata>
<ber:minClient>7676</ber:minClient>
<ber:minAS>171001</ber:minAS>
</ber:version>
<ber:groupArray>
<group key="businessMetaGroup" value="explorerBusiness,requests"/>
<group key="searchMetaGroup" value="explorerSearch,territory"/>
<group key="relationTreeMetaGroups" value="territory,water,roads"/>
<group key="snapMetaGroups" value="Water_network,inspections"/>
</ber:groupArray>
<businessAssignmentArray>
<businessAssignment assetAssignFillAttributes="true"
boAssignFillAttributes="true" copyAfterAssetSplit="true">
<ber:featureType xlink:href="model.xml#ft_bo_assign"/>
<ber:relationAssoc xlink:href="model.xml#as_bo_assign"/>
<ber:assetRelationAssocArray>
<ber:relationAssoc xlink:href="model.xml#as_bo_asset_1"/>
<ber:relationAssoc xlink:href="model.xml#as_bo_asset_2"/>
<ber:relationAssoc xlink:href="model.xml#as_bo_asset_3"/>
</ber:assetRelationAssocArray>
</businessAssignment>
</businessAssignmentArray>
<ber:dynamicDAArray>
<ber:graphicTagType xlink:href="model.xml#ft_street_da_name"/>
</ber:dynamicDAArray>
<ber:parameterArray>
<ber:parameter name="as_timeout" value="666666"/>
<ber:parameter name="automatic_download_relations" value="true"/>
<ber:parameter name="explorer_detail_max_scale" value="35"/>

Implementation Guide

280

22 – LIDS EDIT / EXPLORER
<ber:parameter name="uStn_respect_backdrop_GO" value="true"/>
<ber:parameter name="uStn_master_units" value="m"/>
</ber:parameterArray>
<ber:unavailableFunctions>
<ber:module name="Module1">
<ber:function name="Function1"/>
<ber:function name="Function2"/>
</ber:module>
<ber:module name="Module2">
<ber:function name="Function3"/>
</ber:module>
</ber:unavailableFunctions>
<ber:dependentFormArray>
<ber:dependentForm>
<ber:featureType xlink:href="model.xml#ft_A"/>
<ber:attribute xlink:href="model.xml#at_01/ca_01"/>
</ber:dependentForm>
</ber:dependentFormArray>
<ber:onDemandDownloadRelationTypeArray>
<ber:relationAssoc xlink:href="model.xml#as_1">
<ber:relationRole xlink:href="model.xml#rt_2"/>
</ber:relationAssoc>
</ber:onDemandDownloadRelationTypeArray>

</ber:modelExplorer>

•

•

•

•
•

businessMetaGroup – comma separated names of metadata groups. Forms of feature types from
these groups only will include possibility to call SAMO business actions. If value “business” is used,
forms of all feature types which have a SAMO business action defined will be expanded by the
appropriate functions. The group business is a system group, it doesn’t have to be defined in
model.xml. If businessMetaGroup definition is missing, no SAMO business actions are available in
LIDS Edit / Explorer
searchMetaGroup – comma separated names of metadata groups. If defined, only feature types
from these groups will be queried by the function Search out. If not defined, all feature types defined
in Search extension are queried
relationTreeMetaGroups – comma separated names of metadata groups. If defined, only these
groups will be offered for the filter in Subordinate Features Tree dialog. If not defined, all groups
containing at least one relationship type will be offered
snapMetaGroups – comma separated names of metadata groups. If defined, these groups will be
offered for exclusive snapping in LIDS Explorer graphic view
forbiddenFTChangeMetaGroups – comma separated names of metadata groups. If defined, feature
types from these groups can’t be selected as source or destination for the feature type change
function. In case of shared semantics, any feature type included in this group causes a semantic
parent and all graphical children to be excluded

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6
•

•
•
•
•

•

22.1.1

281

businessAssignmentArray – section for defining the SAMO assignment
• assetAssignFillAttributes – true / false attribute defines, whether the form for filling the
assignment attributes is opened, when the assigning of asset is started from business object form
• boAssignFillAttributes – true / false attribute defines, whether the form for filling the
assignment attributes is opened, when the assigning of business object is started from asset form
• copyAfterAssetSplit – true / false attribute defines behavior of split line function. If set to true,
the assignment feature is copyied and related to the newly created line segment
• featureType – assignemnt feature type used to bind SAMO business object and assets
• relationAssoc – relation between the assignment feature type and SAMO business object
• assetRelationAssocArray – list of relations between the assignment feature type and assets
dynamicDAArray – list of displayable attribute types, which will be moved automatically to fit into
map frame
parameterArray – various parameters described in the separate chapter
unavailableFunctions – optional definition of client functions, which should be hidden on the
project, for all users
dependentForm – defines feature type attribute, typically codelist attribute, including form id. The
form with corresponding id will be used for displaying feature attributes in the form window. This
way it’s possible to control the used form by attribute value
onDemandDownloadRelationType – defines list of relations + roles, whose content will not be
downloaded automatically when activating particular relation type in the related features
component. It’s useful for relations with big amount of related features

Parameters
The following parameters were included in config.xml and were editable by LIDS Application server
console using the Client properties section up to version 7.7. Starting with version 8.0, the parameters
are part of standard project metadata.

General parameters
•

•

•
•
•
•

as_timeout (integer)
Time limit (sec) for receiving a response to a request passed on to the application server. After a
timeout, the original request is canceled on the client side.
automatic_project_logoff_timeout (integer)
Time limit (sec) for inactivity of LIDS Explorer / LIDS Edit clients. If no communication between
the client application and the server takes place in the defined interval, a dialog box is displayed
for the user with a 30 s countdown. Once this has expired, the client application will be
terminated. Minimum allowed value is 30s.
automatic_download_relations (true/false)
Manages automatic downloading of relations at the moment when the feature form is displayed.
feature_page_size (number >= 1)
Number of records on one page when downloading data to browse and form.
feature_page_size_till_end (number >= 1)
Number of records on one page when downloading all remaining data in browse and form.
autocommit (true/false)
Switches on/off option Automatic committing of operations after logging in to the project.

Implementation Guide

282
•
•

•

•

•
•
•
•
•
•
•

•

•
•

•

•
•

•
•

22 – LIDS EDIT / EXPLORER
backdropCache_dir (directory path)
Name of directory for temporary saving of backdrop map files.
backdropCache_exclusive (true/false)
Suppression of downloading backdrop map files from the AS – requested files are only searched
for in the local cache.
backdropCache_update (true/false)
Suppression of downloading backdrop map files from the local cache – requested files are always
downloaded from the AS.
offline_download_all_codelists (true/false)
Manages downloading of codelists on transfer to off-line mode (all codelists / only codelists
defined for feature types selected for off-line mode).
explorer_max_scale (number >= 0.1)
Maximum allowed scale for Graphic View window in LIDS Explorer.
explorer_detail_max_scale (number >= 1)
Maximum allowed scale for window displaying a detail.
uStn_master_units (km/m/cm/mm/um)
Master units of created DGN files. Used for exported DGN and for system DGN in LIDS Edit.
uStn_sub_units (km/m/cm/mm/um)
Subunits of created DGN files. Used for exported DGN and for system DGN in LIDS Edit.
uStn_working_per_master (integer)
Ratio of master units and subunits for LIDS Edit with MicroStation.
uStn_3d_seed_file (true/false)
Manages use of 2D/3D seed file for LIDS Edit with MicroStation.
uStn_local_seed_only (true/false)
Flag defining priority use of the seed file installed on the local computer over the seed file
registered on the application server.
uStn_respect_backdrop_GO (true/false)
Flag defining if global origin of DGN files is considered when attaching backdrop maps. Default
is false.
dgn_export_model_name (text)
Defines the name of the model for the output dgn file for the Save into dgn file function.
maxRequestImportItems (number >= 1)
Defines the maximum number of imported features which will be sent in one request when using
the Import file function.
exp_XML_max_levels
Defines the maximum allowed value for Related non-graphic features - To level in the function
Export to XML.
project_info
The parameter contains URL of the Web page that appears after the user logs on to the project.
project_info_time
The parameter specifies the timestamp for the webpage defined in the project_info parameter. It
has the following format: YYYY-MM-DD HH:MM:SS.
infra3d_url
The parameter contains URL of the infra3d server application.
system_settings_folderId (setting id in the format „id_1234567890“)
The parameter contains id of folder in store, where the „system“ settings should be stored. The
setting types include e.g. useroptions, projectoptions,keyboardshortcuts, guicustomized etc. The
folder has to be created manually and the existing settings should be moved there

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6
•

283

coordinatesScale (whole number >= 0)
Defines the number of fraction digits for displaying coordinates in some windows. In LIDS 8.22
limited to the window Change Coordinates - Scale

Parameters for projects with configuration with SIAS
•
•
•

dynamic_vector_download (true/false)
Manages availability of control icons for downloading of vector data.
detail_raster_format (jpg, png)
Format of files displaying a detail.
allow_plain_scale_lock (true/false)
Manages availability of function to lock scale for backdrop maps download.

Parameters for projects with configuration with TOMS
•
•
•
•

•
•

toms_use_sid (true/false)
Manages use of SID or FID identifiers for requests sent from TOMS to LIDS AS.
toms_max_objects (number 1 to 1000000)
Maximum allowed number for tab page TOMS.
tdm_timeout (number)
Time interval (sec) for checking the ECHO signal from TOMS Desktop Manager.
toms_startup_raster (number >=0)
Defines which raster will be displayed when GIS Explorer is launched from the TOMS module.
The value determines the position of the given type of backdrop map in backdropTypeArray in
model.xml.
toms_encoding
Encoding used in terms of communication by TOMS modules with GIS Explorer.
redline_featuretype
Identification of feature type used for redline.
Supported up to TOMS version 3.2.

22.2 Project Options settings
LIDS Edit / Explorer applications can be configured also interactively using the options available in the
Settings dialog box. There are a lot of options to configure this way. Though every user can tune the
options individually, it’s useful to preconfigure some options on the project level, for all users.
The client application includes functions for managing two types of option settings:
• The Project Settings dialog box allows a user with the appropriate rights to manage the project
options setting.
• The Settings dialog box allows a user to manage its user options setting
Both, the project options setting and user options settings are stored in database in the LIDS_SETTINGS
table. There can be up to one project options setting for whole project and one user options setting for
every user.

Implementation Guide

284

22 – LIDS EDIT / EXPLORER

The client application always generates complete user options setting including all possible parameters
when connecting to the project. It reads both the project options setting and the saved version of the user
options setting:
• If some parameter doesn't exist in the user options, the value from project options is copied to user
options with the flag changed="False"
• If some parameter exists in the user options with the flag changed="False", the value is updated
according to the project options and the flag changed="False" is preserved
• If some parameter exists in the user options with the flag changed="True", the value from user
options wins and the value from project options is ignored



Following possibilities exist to make particular entry from project options to appear in the user options:
•
•
•
•

Delete user options setting completely. It will be regenerated according to the project options during
the next logging into the client
Delete particular entry from the user options setting. It will be regenerated according to the project
options during the next logging into the client
Set the value of particular entry in the user options to changed="False". It will be updated according
to the project options during the next logging into the client
It’s always possible to update the particular entry directly in user options and set the flag
changed="True". That’s exactly what the interactive manipulation in the Settings dialog box does

22.3 LIDS Edit on Bentley platform
22.3.1

system.dgn generating
The procedure of creating system.dgn follows:
1. Seed file is copied and opened
a. If seedDgn resource is registered in project, the seed file is used from project resources
b. If seedDgn resource is not registered in project, seed.dgn from client installation is used
2. It is converted to 3D if project is 3D or uStn_3d_seed_file property is set to true
3. Colors for background, selection set and highlight are set according to project / user Options
4. Units are set according to client properties (uStn_master_units, uStn_sub_units and
uStn_working_per_master)
5. Project RSC and LIN line style are imported into the file
6. Project fonts are initialized in the file
7. Library of symbol hatching styles is generated and attached to the file
8. Project coordinate system is assigned to the file according to EPSG
9. File Views are set according to default situation

22.4 Copy features configuration
The function for copying features can operate in two modes. The new features either take over the type
of the source feature or they can be assigned another type on the basis of rules saved in metadata.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

285

The rules are defined in option.xml in featureCopyArray. Every rule can define following properties:
• parameters – preconfigured geometry operations rotation, scaleFactor, horizontalFlip, verticalFlip
• copyFTArray – pairs of source feature type - inputFT and target feature type – outputFT
• sharedSemantic – optional attribute, default value is false. If sharedSemantic=“true“, the source
and target features are assigned to a common group sharing the semantics.
Example: featureCopy definitions in option.xml
<ber:featureCopyArray>
<ber:featureCopy id="fc_1" name="Map A converted to map B and transformed">
<ber:parameters

rotation="180"

scaleFactor="1.5"

horizontalFlip="true"

verticalFlip="true"/>
<ber:copyFTArray>
<ber:copyFT sharedSemantic="false">
<ber:inputFT xlink:href="model.xml#ft_A1"/>
<ber:outputFT xlink:href="model.xml#ft_B1"/>
</ber:copyFT>
<ber:copyFT sharedSemantic="true">
<ber:inputFT xlink:href="model.xml#ft_A2"/>
<ber:outputFT xlink:href="model.xml#ft_B2"/>
</ber:copyFT>
<ber:copyFT sharedSemantic="true">
<ber:inputFT xlink:href="model.xml#ft_A3"/>
<ber:outputFT xlink:href="model.xml#ft_A3"/>
</ber:copyFT>
</ber:copyFTArray>
</ber:featureCopy>
<ber:featureCopy id="fc_2" name="...">
<ber:parameters

rotation="0"

scaleFactor="1.0"

horizontalFlip="false"

verticalFlip="false"/>
<ber:copyFTArray>
<ber:copyFT sharedSemantic="true">
<ber:inputFT xlink:href="model.xml#ft_1"/>
<ber:outputFT xlink:href="model.xml#ft_1"/>
</ber:copyFT>
<ber:copyFT sharedSemantic="true">
<ber:inputFT xlink:href="model.xml#ft_2"/>
<ber:outputFT xlink:href="model.xml#ft_3"/>
</ber:copyFT>

Implementation Guide

286

22 – LIDS EDIT / EXPLORER
</ber:copyFTArray>
</ber:featureCopy>
</ber:featureCopyArray>

Implementation Guide

Chapter 23
LIDS Browser

IMPLEMENTATION GUIDE VERSION 9.6

23.

289

LIDS Browser
Configuration of LIDS Browser and its graphical user interface (GUI) is defined in metadata extension
browser.xml. Basic model (model.xml) defines a range of possible used data (feature types, attributes,
relationships).
Privileges and access rights are controlled the same way as in LIDS by LIDS Security. LIDS Settings
defines used data layers. Legends are raster images representing „static“ legends with symbology.
Example: Structure of browser.xml.
<ber:modelBrowser>
<version> [1]
<metadata> xsd:unsignedInt </metadata> [1]
<minClient> xsd:unsignedInt </minClient> [0..1]
<minAS> xsd:unsignedInt </minAS> [0..1]
</version>
<ber:mainMap> ber:MainMapType </ber:mainMap> [1]
<ber:locatorMap> ber:LocatorMapType </ber:locatorMap> [1]
<ber:includedLayers> ber:IncludedLayersType
<!-Uniqueness Constraint - UniqueOrder
Selector - ./*/ber:layer
Field(s) - @order
-->
</ber:includedLayers> [1]
<ber:externalWMS> [0..1]
<ber:externalServers> ber:ExternalServersType </ber:externalServers> [0..1]
<ber:allowedHosts> ber:AllowedHostsType </ber:allowedHosts> [0..1]
</ber:externalWMS>
<ber:locationForms> ber:LocationFormsType </ber:locationForms> [0..1]
<ber:legends> ber:LegendsType </ber:legends> [0..1]
<ber:redlineTaskArray> ber:RedlineTaskArrayType </ber:redlineTaskArray> [0..1]
<ber:plotLayouts> ber:PlotLayoutsType </ber:plotLayouts> [0..1]
<ber:defaultUserSettings> ber:DefaultUserSettingsType
</ber:defaultUserSettings> [0..1]
<ber:disablePasswordChange> xsd:boolean </ber:disablePasswordChange> [0..1]
<ber:disableLayersAccessRightsChecking> xsd:boolean
</ber:disableLayersAccessRightsChecking> [0..1]
<ber:plugins> ber:PluginsType </ber:plugins> [0..1]
<ber:guiConfiguration> ber:GuiConfigurationType </ber:guiConfiguration> [0..1]
<ber:timeout> xsd:decimal </ber:timeout> [0..1]
<ber:embedit> xsd:boolean </ber:embedit> [0..1]
<ber:areaMeasurement> ber:AreaMeasurementType </ber:areaMeasurement> [0..1]
<ber:mapContextCache> xsd:boolean </ber:mapContextCache> [0..1]

Implementation Guide

290

23 – LIDS BROWSER
<ber:backdropLayers> ber:BackdropLayersType </ber:backdropLayers> [0..1]

<ber:measurementSnappingLayers> ber:MeasurementSnappingLayersType
</ber:measurementSnappingLayers> [0..1]
<ber:attachments
maxScaleDenominator="ber:ScaleType [0..1]"
defaultIcon="xsd:string [0..1]"
openIcon="xsd:string [0..1]"
hoverIcon="xsd:string [0..1]"/> [0..1]
<ber:vectorGraphicSymbology> ber:VectorGraphicSymbologyType
</ber:vectorGraphicSymbology> [0..1]
<ber:featureBrowse> ber:FeatureBrowseType </ber:featureBrowse> [0..1]
<ber:centerCoord> ber:CenterCoordType </ber:centerCoord> [0..1]
<ber:contexts> ber:ConfigurationContextstType </ber:contexts> [0..1]
</ber:modelBrowser>

Deploying configuration for LIDS Browser
1. Upload browser.xml – LIDS AS Admin console => Project Control => Metadata extension Files
=> LIDS Browser
2. Start project – LIDS AS Admin console => Project Control
3. Configure LIDS Browser - LIDS AS Admin console => Browser & Map Services => Configure
LIDS Browser
Transformed files are stored in {project_folder}\browser\context\ folder.
Example: Metadata system versioning.
<ber:version>
<ber:metadata>2</ber:metadata>
<ber:minClient>2754</ber:minClient>
<ber:minAS>11904</ber:minAS>
</ber:version>

23.1 Main Map
Defines settings of the map components.
• range – Range of map which will be displayed after initialization of LIDS Browser.
• minScaleDenominator/maxScaleDenominator – Minimal and maximal scale for displaying data.
• scales – List of map scales for displaying – scale “levels” for displaying data.
• locationSymbology – Symbology properties for element location (general / for specified feature
types).
• stampText, usageLink – Text content for stamp (company name, version etc.) and for link to Terms.
<ber:mainMap>
<ber:initialSettings>
<ber:range>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

291

<ber:x min="3451400.00" max="3451850.00"/>
<ber:y min="5481600.00" max="5481900.00"/>
</ber:range>
</ber:initialSettings>
<ber:minScaleDenominator>100</ber:minScaleDenominator>
<ber:maxScaleDenominator>500000</ber:maxScaleDenominator>
<ber:scales>
<ber:scale>200000</ber:scale>
<ber:scale>100000</ber:scale>
<ber:scale>50000</ber:scale>
<ber:scale>20000</ber:scale>
<ber:scale>10000</ber:scale>
<ber:scale>5000</ber:scale>
<ber:scale>2000</ber:scale>
<ber:scale>1000</ber:scale>
<ber:scale>500</ber:scale>
<ber:scale>200</ber:scale>
<ber:scale>100</ber:scale>
</ber:scales>
<ber:backgroundColor>#FFFFFF</ber:backgroundColor>
<ber:locationSymbology>
<ber:rgbColor>#FF00FF</ber:rgbColor>
<ber:strokeWidth>2</ber:strokeWidth>
<ber:featureTypeSymbolizerArray>
<ber:featureTypeSymbolizer ftid="ft_5012100">
<ber:fillColor>#FF0000</ber:fillColor>
<ber:fillOpacity>0.5</ber:fillOpacity>
<ber:strokeWidth>5</ber:strokeWidth>
<ber:strokeColor>#FF0000</ber:strokeColor>
</ber:featureTypeSymbolizer>
<ber:featureTypeSymbolizer ftid="ft_5060000">
<ber:fillColor>#FF9C00</ber:fillColor>
<ber:fillOpacity>0.5</ber:fillOpacity>
<ber:strokeWidth>8</ber:strokeWidth>
<ber:strokeColor>#FF0000</ber:strokeColor>
</ber:featureTypeSymbolizer>
</ber:featureTypeSymbolizerArray>
</ber:locationSymbology>
<ber:stampText>© 2016 Asseco CE</ber:stampText>
<ber:usageLink usageLinkUrl="http://asseco.com/ce/">Terms of
Usage</ber:usageLink>
</ber:mainMap>

Implementation Guide

292

23 – LIDS BROWSER

23.2 Overview Map
Name of registered backdrop layer which represents overview (vicinity) map and initial range from
backdrop file which will be displayed in overview map window is defined in <ber:locatorMap>.
Example: Overview map.
<ber:locatorMap>
<ber:range>
<ber:x min="3440000.00" max="3470000.00"/>
<ber:y min="5476000.00" max="5491000.00"/>
</ber:range>
<ber:layer refId="bd_05"/>
</ber:locatorMap>

23.3 Layers
Displayed to user as „map layers“ and used for downloading LIDS data.
• refId – Identifier of data source. There are 4 alternatives: category (cat_: identifier of category
defined in model.xml), set definition (setdefinition_: identifier of LIDS set definition stored in
LIDS_SETTINGS table), backdrop (defined in model.xml), TMS layer (defined in mapservice.xml) and external layer (identifier of external server, stored in LIDS store).
• visible – Boolean. Implicit visibility of the layer.
• queryable – Boolean. Possibility to download alphanumerical data.
• opacity – Boolean. Implicit opacity of the layer.
• minScaleDenominator/maxScaleDenominator – The lowest and the highest map scale for
downloading data.
Layer grouping
Group of layers is displayed as 1 named layer for user. All the assigned layers (<ber:layerGroup…>)
are controlled by 1 checkbox. Parameter visible can be defined only for the whole group. Other
parameters can be defined for the particular layer or for the whole group.
Hierarchy of layers
Layers can be also sorted into folders (<ber:folder…>). Each folder has its name and id and optional
boolean parameter expanded.
Example: Included layers.
<ber:includedLayers>
<ber:layer refId="setdefinition_88680012216213984"/>
<ber:layer refId="setdefinition_2011050282" visible="true"
minScaleDenominator="100" maxScaleDenominator="2000"/>
<ber:layer refId="setdefinition_201105021258"/>
<!-- Hierarchy modeled using nonexpandable master category
<ber:layer refId="cat_redlining_sketch"/>

Implementation Guide

-->

IMPLEMENTATION GUIDE VERSION 9.6

293

<!-- Hierarchy modeled using folder -->
<ber:folder name="Redlining + Sketch as folder" id="rs_folder" expanded="true">
<ber:layer refId="cat_5070000"/>
<ber:layer refId="cat_5080000"/>
</ber:folder>
<ber:layer refId="cat_5010000"/>
<ber:layerGroup id="waterGroup1" name="Water group">
<ber:layer refId="tms_water" minScaleDenominator="300"/>
...
<ber:layer refId="tms_detailed_plan" minScaleDenominator="100"
maxScaleDenominator="150"/>
</ber:layerGroup>
...
</ber:includedLayers>

23.4 Web Map Service
Defines external WMS server by means of LIDS setting or by URL address.
• allowedHosts – For now constant value „*.berit.cz”.
Example:
<ber:externalWMS>
<ber:externalServers>
<ber:externalServer xlink:href="setting#id_2064886259077533"/>
<ber:externalServer xlink:href="http://brnoas1.berit.cz:9200/LIDSdemo_DEV/WebMapService"/>
</ber:externalServers>
<ber:allowedHosts>
<ber:allowedHost>*.berit.cz</ber:allowedHost>
</ber:allowedHosts>
</ber:externalWMS>

23.5 Location Forms



LIDS Browser doesn’t support Interface forms.
Enable user to search (locate) elements according to a defined filter. Name is displayed to user. This
element is optional.
• request – Definition of form displayed to user.
• form – HTML description of content of the location form; the variables from the form are refered
in GetFeature request as :variable_name: (e.g. from example below „variable1“).

Implementation Guide

294

23 – LIDS BROWSER

Request subelement
WFS GetFeature request. This request must contain filter with an attribute condition.
• wfs:Query – Can contain more elements (each with feature type identifier typeName) for searching
more feature types by means of 1 location form.
• ogc:Filter – Possible values are for example PropertyIsLike, PropertyIsEqualTo,
PropertyIsBetween.
• ogc:PropertyName – Attribute identifier (ft_parcel_face/at_parcel_number) or codelist attribute
identifier (ft_5060000/at_5060002/ca_00903).
• ogc:Literal – Link to variable.
• ogc:And – More attributes can be used for filtering (searching).
Form subelement
HTML tags <table>, <tr>, <td> are used for making structure / layout of form.
• td – Cell definition contains name of cell (item) displayed to user and properties for input variable
(name, type, size, required flag, default value); also other HTML tags can be used (e.g. bgcolor,
style etc.).
• input – Parameters name, size, value, type (text: parameter isNumber – true/false; date: isNumber
– true/false; codelist: clId – codelist identifier; keyId – codelist code attribute identifier; displayId –
codelist description attribute identifier).
Example: Location form.
<ber:locationForm name="Service organization unit - locate">
<ber:request>
<wfs:GetFeature xmlns:wfs="http://www.opengis.net/wfs"
xmlns:ogc="http://www.opengis.net/ogc" version="1.0.0" service="WFS"
outputFormat="WMS_GML">
<wfs:Query typeName="ft_5060000">
<ogc:Filter>
<ogc:PropertyIsLike wildCard="*" singleChar="?" escapeChar="\">
<ogc:PropertyName>ft_5060000/at_5060002/ca_00903</ogc:PropertyName>
<ogc:Literal>:variable1:*</ogc:Literal>
</ogc:PropertyIsLike>
</ogc:Filter>
</wfs:Query>
</wfs:GetFeature>
</ber:request>
<ber:form>
<table xmlns="http://www.w3.org/1999/xhtml">
<tr>
<td>Unit name:</td>
<td>
<input name="variable1" type="text" size="10" value="Centrum"/>
</td>
</tr>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

295

</table>
</ber:form>
</ber:locationForm>

23.6 Legends
Contains list of the legends definitions which are shown in LIDS Browser Legend window. This element
is optional.
• file – Location. The folder is predefined {project_folder}\browser\resource.
• refId – List of related layers (category, set definition, backdrop, tms) for which the given legend is
displayed.
Example: Legend.
<ber:legends>
<ber:legend name="Water" file="water.png">
<ber:layer refId="cat_5010000"/>
<ber:layer refId="setdefinition_2011050282"/>
<ber:layer refId="tms_water"/>
</ber:legend>
<ber:legend name="Common objects" file="common_objects.png">
<ber:layer refId="cat_5010000" minScaleDenominator="250"
maxScaleDenominator="1200"/>
<ber:layer refId="cat_5040000"/>
</ber:legend>
</ber:legends>

23.7 Redline Tasks
Contains list of redline task definitions. This element is optional.
• featureType – Refers to feature type from model.xml.
• noteAttribute – Refers the feature attribute for inserting the text value. This element is optional. If
this element is missing then LIDS Browser insert only geometry.
• layer – Refers a category or setting containing this feature type.
• showMeasurement – Enables displaying of length / surface of the drawn line / polygon.
• snappingLayers – Defines layers for snapping during drawing.
Example: Redline task.
</ber:redlineTaskArray>
<ber:group name="Sketch">
<ber:redlineTask>
<ber:featureType xlink:href="model.xml#ft_5081000"/>
<ber:noteAttribute xlink:href="model.xml#at_5080003"/>

Implementation Guide

296

23 – LIDS BROWSER
<ber:layer refId="cat_5080000"/>
</ber:redlineTask>
<ber:redlineTask showMeasurement="true">
<ber:featureType xlink:href="model.xml#ft_5082000"/>
<ber:noteAttribute xlink:href="model.xml#at_5080003"/>
<ber:layer refId="cat_5080000"/>
</ber:redlineTask>
<ber:redlineTask showMeasurement="true">
<ber:featureType xlink:href="model.xml#ft_5083000"/>
<!-- ber:noteAttribute xlink:href="model.xml#at_5080003"/-->
<ber:layer refId="cat_5080000"/>
<ber:snappingLayers>
<ber:layer refId="setdefinition_1903258049794461"/>
</ber:snappingLayers>
</ber:redlineTask>
<ber:redlineTask>
<ber:featureType xlink:href="model.xml#ft_5084000"/>
<ber:noteAttribute xlink:href="model.xml#at_5080003"/>
<ber:layer refId="cat_5080000"/>
</ber:redlineTask>
</ber:group>
</ber:redlineTaskArray>

23.8 Create Features without Graphics
Section insertFeatureTypeArray defines list of features types to be created without graphics.
If assocsArray element is defined, the feature without graphics is created only as the related feature to
an existing one.
Example:
<ber:insertFeatureTypeArray>
<ber:featureType xlink:href="model.xml#ft_1"/>
<ber:featureType xlink:href="model.xml#ft_2"/>
<ber:featureType xlink:href="model.xml#ft_3">
<ber:assocsArray>
<ber:assoc id="r_1" srcFt="ft_4" srcRole="rt_1" destRole="rt_2"/>
</ber:assocsArray>
</ber:featureType>
</ber:insertFeatureTypeArray>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

297

23.9 Plot Layouts
Contains list of plot settings. It should contain plottinglayout settings and default plot layout. List of
predefined plot layouts (creating is possible in LIDS Explorer) which can be used in LIDS Browser.
Plot layout contains static text, frames, pictures.
• xlink:href – Link to LIDS setting of type “plottinglayout”; it contains global definition for output
map layout and for its individual components.
• scales – List of possible map scales which can be used for given plot layout.
• rotations – List of possible rotations which can be used for given plot layout (from -180 to 180).



LIDS Browser supports only single-page plot layouts with following components:
•
•
•
•
•
•
•

Map frame – Supported with limitations.
Overview map frame
North arrow frame
Scale frame – Supported with limitations.
Text frame
Variable frame
Rubberstamp frame – Supported with limitations.

Example: Plot layout.
<ber:plotLayouts>
<ber:defaultPlotLayout name="Plot layout - default"/>
<ber:plotLayout xlink:href="setting#id_1266">
<ber:scales>
<ber:scale>500</ber:scale>
<ber:scale>1000</ber:scale>
<ber:scale>3500</ber:scale>
</ber:scales>
<ber:rotations>
<ber:rotation>-45</ber:rotation>
<ber:rotation>-25.5</ber:rotation>
<ber:rotation>0</ber:rotation>
<ber:rotation>15</ber:rotation>
<ber:rotation>155.2</ber:rotation>
</ber:rotations>
</ber:plotLayout>
</ber:plotLayouts>

Implementation Guide

298

23 – LIDS BROWSER

23.10 Default Settings
•
•
•
•
•
•
•

highlightSelectedFeatures – True = features selected in browse are highlighted.
animateZoom – True = zooming of graphic data display is animated.
clickSelector – True = features for reading alphanumerical data are selected by double click, False
= features for reading alphanumerical data are selected by an area.
snappingModes – Implicit „turn on“ of particular snapping modes (node, edge, vertex, intersections,
centroid).
attachmentsSort – Defines field for attachments ordering. Possible values: content, contentType,
contentId, description, name, openText, previewId, userLink. Default is name.
maxFeaturesMapSelected – defines maximum number of features sent to form when selecting
features in map. Default is 1000
maxSizeDialogForm – defines size of dialog for working with details

Example: Default user settings.
<ber:defaultUserSettings>
<ber:highlightSelectedFeatures>true</ber:highlightSelectedFeatures>
<ber:animateZoom>true</ber:animateZoom>
<ber:clickSelector>false</ber:clickSelector>
<ber:maxFeaturesMapSelected>2000</ber:maxFeaturesMapSelected>
<ber:snappingModes>
<ber:snappingMode id="node">true</ber:snappingMode>
<ber:snappingMode id="edge">true</ber:snappingMode>
<ber:snappingMode id="vertex">true</ber:snappingMode>
<ber:snappingMode id="intersections">true</ber:snappingMode>
<ber:snappingMode id="centroid">true</ber:snappingMode>
</ber:snappingModes>
<ber:maxSizeDialogForm width="500" height="400"/>
<ber:attachmentsSort orderBy="description"/>
</ber:defaultUserSettings>

23.11 Plugins
Contains list of the enabled plugins for LIDS Browser. This element is optional.
• id – LIDS Browser plugin definition. Permitted values: „cuzk“, „addressPoint“, „ap“,
„elevationInfo“.
• form – Reference to a form from model.xml.
Example: Plugin.
<ber:plugin id="addressPoint">
<ber:configuration>
<ber:forms>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

299

<ber:form xlink:href="model.xml#fmx_50121"/>
</ber:forms>
</ber:configuration>
</ber:plugin>

23.12 GUI Configuration
Metadata definition of graphical user interface. If defined according the following example, interface
will look like this:

23.12.1 Modules
Module is extension of Lids Browser funcionality. Lids Browser contains native modules, but it could
be extended by special project modules. Native modules are defined only by id. Other modules must
have defined path.
Example: Metadata definition of main menu and top right toolbar.
<ber:modules>
<ber:mainMenu>
<ber:module id="layers"/>

Implementation Guide

300

23 – LIDS BROWSER
<ber:module id="views"/>
<ber:module id="search"/>
<ber:module id="externalLayers"/>
</ber:mainMenu>
<ber:toolBar>
<ber:module id="draw"/>
<ber:module id="print"/>
<ber:module id="legends"/>
<ber:module id="history"/>
</ber:toolBar>
</ber:modules>

Main menu consists of four panels:

Top right toolbar contains the following icons:

23.12.2 Toolbars
Section <ber:toolbars> defines two tollbars located on the left of top toolbar menu – mapToolbar and
applicationToolbar.
Example: Map and application toolbars.
<ber:toolbars>
<ber:mapToolbar>
<ber:toolbarItem type="button" id="zoomIn"/>
<ber:toolbarItem type="button" id="zoomOut"/>
<ber:toolbarItem type="button" id="zoomBox"/>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

301

<ber:toolbarItem type="button" id="hand"/>
<ber:toolbarItem type="separator"/>
<ber:toolbarItem type="button" id="back"/>
<ber:toolbarItem type="button" id="forward"/>
<ber:toolbarItem type="button" id="home"/>
<ber:toolbarItem type="separator"/>
<ber:toolbarItem type="button" id="measurement"/>
<ber:toolbarItem type="separator"/>
<ber:toolbarItem type="button" id="info"/>
<ber:toolbarItem type="button" id="clear"/>
<ber:toolbarItem type="button" id="attachments"/>
<ber:toolbarItem type="separator"/>
</ber:mapToolbar>
<ber:applicationToolbar>
<ber:toolbarItem type="button" id="settings"/>
<ber:toolbarItem type="button" id="user"/>
<ber:toolbarItem type="button" id="help"/>
<ber:toolbarItem type="button" id="about"/>
</ber:applicationToolbar>
</ber:toolbars>

Map toolbar:

Applicaton toolbar:

23.12.3 Drawing dialog box
Metadata definition of movable window “Drawing” which is referenced by <ber:module id="draw"/>.
Example: Drawing dialog box.
<ber:paintingPanel>
<ber:paintingPanelItem id="insert"/>
<ber:paintingPanelItem id="modify"/>
<ber:paintingPanelItem id="cutHole"/>
<ber:paintingPanelItem id="deleteHole"/>

Implementation Guide

302

23 – LIDS BROWSER
<ber:paintingPanelItem id="delete"/>
<ber:paintingPanelItem id="deleteSingle"/>
</ber:paintingPanel>

23.12.4 Styles
Definition of visualisation of buttons, toolbars etc. For example color and its gradient.
Example: Visualisation style.
<ber:styles>
<ber:style id="mainGradientFrom">#F2F7FF</ber:style>
<ber:style id="mainGradientTo">#DAE6FE</ber:style>
<ber:style id="mainColor">#000000</ber:style>
...
<ber:style id="border">#b3b3b3</ber:style>
...
<ber:style id="toolBar">#505050</ber:style>
</ber:styles>

23.13 Symbology of Vector Graphics
Enables to define symbology for predefined types of operations with vector data.
• id – specifies operation type (drawFeature, measurement, modifyFeature, selectfeature,
wktFeature, selectPolygonFeature).
• symbolizer properties – fillColor, fillOpacity, strokeWidth, strokeColor, fontSize.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

303

Example: Symbology of vector graphics.
<ber:vectorGraphicSymbology>
<ber:symbolizer id="drawFeature">
<ber:fillColor>#FF8000</ber:fillColor>
<ber:fillOpacity>0.2</ber:fillOpacity>
<ber:strokeWidth>2</ber:strokeWidth>
<ber:strokeColor>#91A3B0</ber:strokeColor>
</ber:symbolizer>
...
</ber:vectorGraphicSymbology>

23.14 Additional Layers
The graphical data displaying in the map is mainly based on loading the layers in the form of raster
response from map services. On the other hand, some functions require graphical data to be downloaded
as vectors. This means the data has to be loaded twice (raster for display and vector for function specific
needs).Only the data from explicitly defined layers are loaded in the vector form parallel to the rasters,
in order to minimize the network traffic and server load.
Definition includes parameters typical for layerType – refId, min/maxScaleDenominator or visible.
measurementSnappingLayers - layers used for snapping during measurement
featureTooltipInfoLayers – feature info is displayed for the features from these layers
selectByPolygonLayers – the polygon features from these layers can be used for the function
Information on Features – by existing polygon
Example: Definition of additional layers.
<ber:featureTooltipInfoLayers>
<ber:layer refId="setdefinition_1"/>
<ber:layer refId="setdefinition_2"/>
<ber:layer refId="setdefinition_3"/>
</ber:featureTooltipInfoLayers>
<ber:selectByPolygonLayers>
<ber:layer refId="setdefinition_2"/>
<ber:layer refId="setdefinition 4"/>
</ber:selectByPolygonLayers>

23.15 Tracing linear topology
Calling of tracing function is possible by selecting some of the predefined tracing tasks. The list of
available tracing tasks is defined in <ber:topoTracingArray>

Implementation Guide

23 – LIDS BROWSER

304

Example: Topological tracing tasks.
<ber:topoTracingArray>
<ber:traceOut xlink:href="option.xml#tr_1"/>
<ber:traceOut xlink:href="option.xml#tr_2"/>
<ber:traceOut xlink:href="option.xml#tr_3"/>
</ber:topoTracingArray>

23.16 Contexts
Configuration for LIDS Browser used for some named context = initialization of LIDS Browser from
certain part (context) of “control” application. Using of “context” element enables to use one
browser.xml with different GUI/function/layer configurations. Section <ber:contexts> has similar
structure as the whole browser.xml.
Example: Context.
<ber:contexts>
<ber:context id="context_01">
<ber:mainMap>
...
</ber:mainMap>
<ber:locatorMap>
...
</ber:contexts>



Calling LIDS Browser with use of CONTEXT parameter:
http://appsrv:9696/LIDSDemo/browser/api?CONTEXT=spotCheckReport

23.17 Special Parameters
•
•
•
•
•
•
•
•

<ber:disablePasswordChange> Contains boolean value for disabling password change in Browser.
<ber:disableLayersAccessRightsChecking> Contains boolean value for checking access rights.
<ber:timeout> Decimal value in minutes.
<ber:mapContextCache> True/false.
<ber:areaMeasurement unit="ha" scale="2"/> Measurement in metres is always used, here is
defined additional measurement unit (ha/a) and count of numbers right to the decimal point.
<ber:featureBrowse><ber:pageSize> Number of records with alphanumerical data per page,
<ber:exportMax> Maximum size of export – decimal.
<ber:centerCoord><ber:rgbColor><ber:pointRadius> Color and radius of cross which marks
position in the map.
<ber:embedit> Boolean. True to run LIDS Browser in embedded mode in IFRAME.

Implementation Guide

Chapter 24
LIDS Mobile

IMPLEMENTATION GUIDE VERSION 9.6

24.

307

LIDS Mobile
Configuration specific for LIDS Mobile client application is included in metadata extension mobile.xml.



Configuration is common for both applications: LIDS Mobile for Android and LIDS Mobile for iOS.
The applications are developed independent on each other and are in different development stage. It
might happen, that particular functionality / configuration is valid only for one platform. Please, check
the development plan for up to date information about finished / missing functionality.
Basic project definition of possible used data (feature types, attributes, relationships) is included in
standard project model.
Privileges and access rights are controlled the same way as in LIDS by LIDS Security. LIDS Settings
defines used data layers.
Displaying of feature attributes expects specific forms definitions:
• assignedForm usage="mobileSimple" – form with up to three attributes to be used in the list of
features found by selection from graphics
• assignedForm usage="mobileFull" – form used to display attributes in detailed form
If these forms are not defined, all attributes are used. For the features list the first three attributes are
used.



Searching for features according to attribute condition requires Search extension to be configured.

Example: Structure of mobile.xml.
<?xml version="1.0" encoding="UTF-8"?>
<ber:modelMobile xmlns:xlink="http://www.w3.org/1999/xlink"
xmlns:ber="http://www.berit.com/ber">
<ber:version>
<ber:metadata>1</ber:metadata>
<ber:minClient>2754</ber:minClient>
<ber:minAS>11904</ber:minAS>
</ber:version>
<ber:projectInfo name="Project name">
<ber:spatialInfo srs="EPSG:31467">
<ber:initialSituation zoomLevel="18.75">3451628.5
5481750.8</ber:initialSituation>
</ber:spatialInfo>
</ber:projectInfo>
<ber:serverArray>
<ber:server name="LIDS WMS" defaultTurnOn="false" showAsOneLayer="false"
defaultQueryLayer="false" type="LIDS-WMS"
xlink:href="WebMapService?VERSION=1.1.1&amp;REQUEST=GetCapabilities&amp;SERVICE=WMS
">
<ber:layerArray>
<ber:layer id="l_1" name="" defaultTurnOn="true"/>
<ber:layer id="l_2" name="" defaultTurnOn="false"/>

Implementation Guide

308

24 – LIDS MOBILE
<ber:layer id="l_3" name="" defaultTurnOn="false"/>
</ber:layerArray>
</ber:server>

<ber:server name="LIDS WMTS" defaultTurnOn="false" showAsOneLayer="false"
defaultQueryLayer="true" type="LIDS-WMTS"
xlink:href="WMTS?SERVICE=WMTS&amp;VERSION=1.0.0&amp;REQUEST=GetCapabilities">
<ber:layerArray>
<ber:layer id="l_4" name="" defaultTurnOn="true"/>
<ber:layer id="l_5" name="" defaultTurnOn="false"/>
<ber:layer id="l_6" name="" defaultTurnOn="false"/>
</ber:layerArray>
</ber:server>
</ber:serverArray>
<ber:sketchTaskArray>
<ber:group name="Group1">
<ber:sketchTask>
<ber:featureType xlink:href="model.xml#ft_1"/>
<ber:featureType xlink:href="model.xml#ft_2"/>
<ber:featureType xlink:href="model.xml#ft_3"/>
</ber:sketchTask>
</ber:group>
<ber:group name="Group2">
<ber:sketchTask>
<ber:featureType xlink:href="model.xml#ft_4"/>
<ber:featureType xlink:href="model.xml#ft_5"/>
</ber:sketchTask>
</ber:group>
</ber:sketchTaskArray>
<ber:groupArray>
<group key="searchMetaGroup" value="group_id"/>
</ber:groupArray>
<ber:offlineSearchArray>
<ber:indexedFeatureTypes>
<ber:indexedFeatureType xlink:href="model.xml#ft_1"/>
<ber:indexedFeatureType xlink:href="model.xml#ft_2"/>
<ber:indexedFeatureType xlink:href="model.xml#ft_3"/>
</ber:indexedFeatureTypes>
<ber:indexedFeatureAttributes>
<ber:indexedFeatureAttribute xlink:href="model.xml#at_1"/>
<ber:indexedFeatureAttribute xlink:href="model.xml#at_2"/>
<ber:indexedFeatureAttribute xlink:href="model.xml#at_3"/>
<ber:indexedFeatureAttribute xlink:href="model.xml#at_4"/>
</ber:indexedFeatureAttributes>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

309

</ber:offlineSearchArray>
</ber:modelMobile>

24.1 Project info
Defines general properties of the project.
• name – project name displayed in the application
• srs – coordinate system
• initialSituation – default position of map window centre
• zoomLevel
–
optional
default
zoom
http://wiki.openstreetmap.org/wiki/Zoom_levels

level

according

to

Example:
<ber:projectInfo name="Project name">
<ber:spatialInfo srs="EPSG:31467">
<ber:initialSituation zoomLevel="18.75">3451628.500000
5481750.586765</ber:initialSituation>
</ber:spatialInfo>
</ber:projectInfo>

24.2 Layers
Layers contain graphical data available for displaying in map window. List of layers can contain data
from LIDS project or from external map services. Individual layers are sorted by groups called servers.
•
•
•

name – name displayed in the application
id – optional identifier. Needed if layer is referred by e.g. offlineServerRefArray
type – server type depends (apart from the providers capability) on the usage in the application.
• LIDS-WMS
o good for frequently changed data
o symbology evaluated by application server
o can't be used in offline mode
• LIDS-WMTS
o good performance
o data can be out-of-date
o symbology evaluated by application server
o can be used in offline mode, but a lot of raster tiles can be downloaded
• LIDS-VECTOR
o good for frequently changed data
o symbology limited - evaluated by client
o optimal for offline mode

Implementation Guide

24 – LIDS MOBILE

310
•
•
•
•
•

•
•
•
•
•
•
•
•

WMS, WMTS
o Used for accessing external map sevices
xlink:href – URL for sending GetCapabilities request. Relative path should be used for LIDS-WMS
and LIDS-WMTS, not used at all for LIDS-VECTOR
defaultTurnOn – true / false attribute. Defines, if the layer is turned on by default
showAsOneLayer – true / false attribute. If true, it’s not possible to display list of individual layers
in client application
defaultQueryLayer – true / false attribute. If true, the layer is used for selecting features in graphics
by default. Several layers can be set to true. Default value is true; it makes sense to define this
attribute just for the false case
queryLayer – true / false attribute, defines, if the layer can be set as queriable. Default value is true;
it makes sense to define this attribute just for the false case, especially in case of backdrop layers
defaultSnapLayer – true / false attribute. If true, the layer is activated for snapping. Just one layer
can be set to true. Default value is false
snappable – true / false attribute, defines, if the layer can be set as snappable. Default value is true;
it makes sense to define this attribute just for the false case
maxScaleDenominator, minScaleDenominator – optional values defining visibility range
opacity – optional transparency setting
featureInfoOutput – format of feature info; used only for external WMS / WMTS
layerArray – list of individual layers provided by particular server
paramsArray – optional array of parameters included in the WMS / WMTS request. The possible
parameters include srs, format, login, password and any other value specified in additionalParams
element. If value of parameter is excluded, the parameter can be defined for each layer
independently

Example:
<ber:serverArray>
<ber:server name="LIDS WMS" defaultTurnOn="false" showAsOneLayer="false"
defaultQueryLayer="true" type="LIDS-WMS" xlink:href="address">
<ber:layerArray>
<ber:layer id="l_1" name="" defaultTurnOn="true"/>
<ber:layer id="l_2" name="" defaultTurnOn="false"/>
<ber:layer id="l_3" name="" defaultTurnOn="false"/>
</ber:layerArray>
</ber:server>
<ber:server defaultTurnOn="true" name="Orthophoto" showAsOneLayer="true"
type="LIDS-WMTS"
xlink:href="WMTS?SERVICE=WMTS&amp;VERSION=1.0.0&amp;REQUEST=GetCapabilities">
<ber:layerArray>
<ber:layer id="tms_orthophoto"/>
</ber:layerArray>
</ber:server>
<ber:server defaultQueryLayer="false" defaultTurnOn="false" name="Utility
networks" showAsOneLayer="false" type="LIDS-VECTOR">
<ber:layerArray>
<ber:layer defaultTurnOn="true" id="cat_5010000" name="Water"/>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

311

<ber:layer defaultTurnOn="false" id="cat_5020000" name="Electricity"/>
</ber:layerArray>
</ber:server>
<ber:server name="External WMS" defaultTurnOn="false" showAsOneLayer="false"
opacity="0.8" defaultQueryLayer="false" type="WMS"
xlink:href="http://server.com/map?SERVICE=WMS&amp;REQUEST=GetCapabilities&amp;VERSI
ON=1.1.1">
<ber:layerArray>
<ber:layer id="l_7" name="" defaultTurnOn="true"/>
<ber:layer id="l_8" name="" defaultTurnOn="false"/>
<ber:layer id="l_9" name="" defaultTurnOn="true"/>
</ber:layerArray>
<ber:paramsArray>
<ber:srs>EPSG:5514</ber:srs>
<ber:format>image/jpeg</ber:format>
<ber:additionalParamsArray>
<ber:param key="STYLES" value="default"/>
</ber:additionalParamsArray>
</ber:paramsArray>
</ber:server>
<ber:server name="External WMTS with additional parameters"
defaultTurnOn="false" showAsOneLayer="true" opacity="0.7" defaultQueryLayer="false"
type="WMTS" featureInfoOutput="text/html"
xlink:href="http://adddress.com/pl?service=WMTS&request=GetCapabilities">
<ber:layerArray>
<ber:layer id="orto" defaultTurnOn="true" params="STYLES:abc"/>
<ber:layer id="tes" defaultTurnOn="true" params"STYLES:def,AAA:bb,XXX:yy"/>
<ber:layer id="terrain" defaultTurnOn="true" params="STYLES:abc"/>
</ber:layerArray>
<ber:paramsArray>
<ber:srs>EPSG:5514</ber:srs>
<ber:format>image/jpeg</ber:format>
<ber:login>username</ber:login>
<ber:password>password</ber:password>
<ber:additionalParamsArray>
<ber:param key="STYLES"/>
<ber:param key="TIME" value="1234"/>
</ber:additionalParamsArray>
</ber:paramsArray>
</ber:server>
</ber:serverArray>

Implementation Guide

24 – LIDS MOBILE

312

24.3 Offline map
The list of layers cached for offline mode can be preconfigured. If the configuration exists, the window
for selecting layers for caching is not displayed and the data is cached according to the definition.
Example:
...
<ber:server id="vector" name=....
<ber:server id="wmts" name=....
<ber:server id="orthophoto" name=....
</ber:serverArray>
<ber:offlineMap>
<ber:offlineServerRefArray>
<ber:offlineServerRef refId="wmts" includeSemantics="true"/>
<ber:offlineServerRef refId="orthophoto"/>
<ber:offlineServerRef refId="vector"/>
</ber:offlineServerRefArray>
</ber:offlineMap>

24.4 Features lists



This definition is prepared for the future versions. It doesn’t work in version 8.25 yet.
Section defines preconfigured selection sets, which can be displayed in full featured lists – browses. The
browse content is defined either by template setting in the store or by filter directly in mobile.xml.
• name – mandatory attribute; name displayed in the application
• groupName – optional attribute; defines the collapsible group under which the list is displayed
• pageSize – optional attribute; number of rows loaded per page. If it’s not specified, paging is not
used and all rows are loaded at once
• dataSource – mandatory definition; defines either preset or filter.
• preset includes a link to selection set in settings by setDefinition
• filter definition consists of:
• featureTypeArray – mandatory definition of feature types to be loaded
• condition – optional attribute filter. The syntax is the same as in case of featureBrowse tool
• orderBy – optional definition of attributes for default ordering
• orderByAttribute – optional list of attributes to be available for interactive ordering for this browse;
defined as path including featureType
• filterAttribute – optional list of attributes to be available for interactive filtering for this browse;
defined as path including featureType
• groupByAttribute – optional attribute to group features by; defined as path including featureType

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

313

Example:
<ber:browseArray>
<ber:browse id="b1" name="List 1" groupName="Group 1" pageSize="50">
<ber:description>List defined by template</ber:description>
<ber:dataSource>
<ber:preset>
<ber:setDefinition id="123456789"/>
</ber:preset>
<ber:orderByArray>
<ber:orderBy direction="descending" xlink:href="model.xml#at_01"/>
<ber:orderBy xlink:href="model.xml#at_02"/>
</ber:orderByArray>
</ber:dataSource>
<ber:orderByAttributeArray>
<ber:orderByAttribute xlink:href="model.xml#ft_01/at_02"/>
<ber:orderByAttribute xlink:href="model.xml#ft_01/at_03"/>
</ber:orderByAttributeArray>
<ber:filterAttributeArray>
<ber:filterAttribute xlink:href="model.xml#ft_01/at_02"/>
<ber:filterAttribute xlink:href="model.xml#ft_01/at_04"/>
</ber:filterAttributeArray>
<ber:groupByAttribute xlink:href="model.xml#ft_01/at_05"/>
</ber:browse>
<ber:browse id="b2" name="List 2" groupName="Group 1">
<ber:description>List defined by filter</ber:description>
<ber:dataSource>
<ber:filter>
<ber:featureTypeArray>
<ber:featureType xlink:href="model.xml#ft_01"/>
<ber:featureType xlink:href="model.xml#ft_02"/>
<ber:featureType xlink:href="model.xml#ft_03"/>
</ber:featureTypeArray>
<ber:condition>('at_01' = '-1' OR 'at_01' = '1' OR 'at_01' = '2') AND
'createdBy' = '%%USERID%%'</ber:condition>
</ber:filter>
<ber:orderByArray>
<ber:orderBy direction="descending" xlink:href="model.xml#at_01"/>
<ber:orderBy xlink:href="model.xml#ft_02"/>
</ber:orderByArray>
</ber:dataSource>
<ber:orderByAttributeArray>
<ber:orderByAttribute xlink:href="model.xml#ft_01/at_02"/>
<ber:orderByAttribute xlink:href="model.xml#ft_01/at_03"/>

Implementation Guide

314

24 – LIDS MOBILE
</ber:orderByAttributeArray>
<ber:filterAttributeArray>
<ber:filterAttribute xlink:href="model.xml#ft_01/at_02"/>
<ber:filterAttribute xlink:href="model.xml#ft_01/at_04"/>
</ber:filterAttributeArray>
<ber:groupByAttribute xlink:href="model.xml#ft_01/at_05"/>
</ber:browse>

</ber:browseArray>

24.5 Relationships
The function for displaying related features displays all possible relationship types defined for particular
feature type. It’s possible to limit the displayed relationship types by configuring
relationViewMetaGroup in groupArray. More comma separated metadata groups can be defined in this
way:
• if relationViewMetaGroup definition doesn’t exist, all relationship types are displayed
• if relationViewMetaGroup definition exists, only the relationship types from these groups are
displayed

24.5.1

Relationships in offline
Only relationship types defined in relationOfflineMetaGroup are cached into offline and can be
displayed in offline mode. More comma separated metadata groups can be defined in this way.

24.6 Sketch Tasks
Section defines list of feature types offered for construction in graphics. List can be organized into
groups.



In case of shared semantics, the definition must include the shared semantics parent.

Example:
<ber:sketchTaskArray>
<ber:group name="Group1">
<ber:sketchTask>
<ber:featureType xlink:href="model.xml#ft_1"/>
<ber:featureType xlink:href="model.xml#ft_2"/>
<!—Example of feature type with shared semantics -->
<ber:featureType xlink:href="model.xml#ft_s3/ft_3"/>
</ber:sketchTask>
</ber:group>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

315

<ber:group name="Group2">
<ber:sketchTask>
<ber:featureType xlink:href="model.xml#ft_4"/>
<ber:featureType xlink:href="model.xml#ft_5"/>
</ber:sketchTask>
</ber:group>
</ber:sketchTaskArray>

24.7 Search Configuration
List of feature types queried by LIDS Mobile can be limited by specifying comma separated metadata
groups ids in groupArray of mobile.xml. If this configuration exists, only feature types included in the
specified groups will be evaluated during search
Example:
<ber:groupArray>
<group key="searchMetaGroup" value="group_1,group_2"/>
</ber:groupArray>

If this definition doesn’t exist, all indexed feature types will be evaluated during search.

24.7.1

Search extension configuration for LIDS Mobile
The Search extension is used on LIDS Mobile for evaluating the attribute query only. After the data is
found using this mechanism, it's displayed in the simple list with feature type name and feature info
only. The other attributes in the detail form are downloaded from LIDS AS directly, so they don't need
to be indexed.
The Search extension is not used for:
• displaying geometry of layers
• displaying attributes in forms
• displaying attributes in list of features found from map
Attributes needed to be included in the index:
• "type"
• "id"
• "featureInfo"
• attributes needed for evaluating the query
Indexing of feature geometry and indexing of codelists is not necessary for LIDS Mobile.

24.8 Offline Search
LIDS Mobile is capable of searching data according to attribute filter also in offline mode. Such data
has to be indexed specific way. This definition is independent on the standard Elastic Search
configuration.
Implementation Guide

316

24 – LIDS MOBILE

It’s necessary to specify feature types and their attributes which will be evaluated when executing the
attribute search in offline mode. Only the specified attributes of the specified feature types are indexed.
Example:
<ber:offlineSearchArray>
<ber:indexedFeatureTypes>
<ber:indexedFeatureType xlink:href="model.xml#ft_1"/>
<ber:indexedFeatureType xlink:href="model.xml#ft_2"/>
<ber:indexedFeatureType xlink:href="model.xml#ft_3"/>
</ber:indexedFeatureTypes>
<ber:indexedFeatureAttributes>
<ber:indexedFeatureAttribute xlink:href="model.xml#at_1"/>
<ber:indexedFeatureAttribute xlink:href="model.xml#at_2"/>
<ber:indexedFeatureAttribute xlink:href="model.xml#at_3"/>
<ber:indexedFeatureAttribute xlink:href="model.xml#at_4"/>
</ber:indexedFeatureAttributes>
</ber:offlineSearchArray>

24.9 Fonts
LIDS Mobile is working with standard TTF fonts for text and point geometries as all other LIDS clients.
However, there are some specific requirements for fonts which will be used in LIDS Mobile:




Platform list (menu Format → Platform Manager) need to be expanded by adding Microsoft Unicode
BMP (UCS-2).

Fonts used for text geometries need to be registered in the application server resources the same way as
all the other symbol fonts. Even the well-known Windows fonts like e.g., Arial don’t exist on Android
by default, so they need to be loaded from the application server. The server-based way of installation
incl. file registration is necessary.

24.10 Project tools
It’s possible to define following types of project tools to be used in LIDS Mobile:
• tool – function is available directly in the application menu
• featureTool – function is available in the form of particular feature
• browseTool – function is available in the list of features integrated in light form
The tools definitions include common properties:
• name
• icon – reference to resources. Supported formats are svg, png, jpg, bmp and ico for iOS, svg, png,
jpg and bmp for Android. Svg format is suggested to have the icon nice looking
• function id possible values and parameters depend on particular function
Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6
•

317

additionally, featureTool definition includes featureTypeArray – list of feature types, whose forms
the tool should appear in

24.10.1 Construct new feature
Tool to start capturing of particular feature type.
function id="constructNewFeature"
Parameters
Parameter

Meaning

Mandatory

featureType

Feature type to be captured

yes

Example:
<ber:toolArray>
...
<ber:tool name="New Station">
<ber:icon xlink:href="resource.xml#ic_station"/>
<ber:script>
<ber:function id="constructNewFeature"/>
<ber:parameterArray>
<ber:parameter name="featureType" value="ft_station"/>
</ber:parameterArray>
</ber:script>
</ber:tool>
...
</ber:toolArray>

24.10.2 Display features in the list
Tool to display features directly in the list. Maximum number of features to be displayed is 200.
function id="featureBrowse"
Parameters
Parameter

Meaning

Mandatory

featureTypes Comma separated list of feature types to be displayed

yes

condition

no

Attribute condition. Possible options are:
- Simple 'att_name' and 'value' comparison using =, < or >:

Implementation Guide

318

24 – LIDS MOBILE
- Logical operators AND, OR in combination with brackets
- %%USERID%% as the variable replaced by current user id

Example:
<ber:toolArray>
<ber:tool name="My features filtered">
<ber:icon xlink:href="resource.xml#ic_abc"/>
<ber:script>
<ber:function id="featureBrowse"/>
<ber:parameterArray>
<ber:parameter name="featureTypes" value="ft_1,ft_2,ft_3"/>
<!-- Optional attribute condition -->
<ber:parameter name="condition" value="('at_a' = '1' OR 'at_2' > '2') AND
'createdBy' = '%%USERID%%'"/>
</ber:parameterArray>
</ber:script>
</ber:tool>

24.10.3 Construct new related feature
Feature tool to start capturing of new related feature from an existing feature form. The newly created
feature will be related to the feature the creation is started from.
function id="constructNewRelatedFeature"
Parameters
Parameter

Meaning

Mandatory

relationType Relation association used to relate the source feature with the
captured feature

yes

roleType

Relation role of the to-be-captured feature

yes

featureType

To-be-captured feature type

yes

attributes

Predefined attribute values of to-be-captured feature

no

Pairs attributeId:value separated by commas
Value can be:
- constant - direct value for attribute (for null value use empty
space – at_1:,at_2...)
- variable – enclosed in doubled percent characters - supported
variables:

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

319

- %%CURRENTDATE%% - current date time
- %%USERID%% - logged user id
- %%USER%% - logger user feature - must be used only
on featureRef attribute related to user feature defined in
mobile.xml/mobile-workforce.xml in user tag
- attribute - value can be taken over from another feature
attribute - attribute id must be enclosed in in doubled hash
characters
Example:
<ber:featureTool name="New inspection">
<ber:icon xlink:href="resource.xml#ic_inspection"/>
<ber:featureTypeArray>
<ber:featureType xlink:href="model.xml#ft_building"/>
<ber:featureType xlink:href="model.xml#ft_station"/>
<ber:featureType xlink:href="model.xml#ft_bus_stop"/>
</ber:featureTypeArray>
<ber:script>
<ber:function id="constructNewRelatedFeature"/>
<ber:parameterArray>
<ber:parameter name="relationType" value="r_house_inspection"/>
<ber:parameter name="roleType" value="rt_inspection"/>
<ber:parameter name="featureType" value="ft_inspection"/>
<ber:parameter name="attributes"
value="at_1:1,at_2:abc,at_3:,at_4:%%CURRENTDATE%%,at_5:##at_sourceAt_1##""/>
</ber:parameterArray>
</ber:script>
</ber:featureTool>

24.10.4 Display related features in the list
Feature tool to display features related to a feature shown in form.
function id="showRelatedFeatures"
Parameters
Parameter

Meaning

Mandatory

relationType Relation association used to find the to-be-displayed features

yes

roleType

yes

Relation role of the to-be-displayed feature

Implementation Guide

320

24 – LIDS MOBILE

Example:
<ber:featureTool name="Show existing inspections">
<ber:icon xlink:href="resource.xml#ic_inspection"/>
<ber:featureTypeArray>
<ber:featureType xlink:href="model.xml#ft_building"/>
<ber:featureType xlink:href="model.xml#ft_station"/>
<ber:featureType xlink:href="model.xml#ft_bus_stop"/>
</ber:featureTypeArray>
<ber:script>
<ber:function id="showRelatedFeatures"/>
<ber:parameterArray>
<ber:parameter name="relationType" value="r_house_inspection"/>
<ber:parameter name="roleType" value="rt_inspection"/>
</ber:parameterArray>
</ber:script>
</ber:featureTool>

24.11 Feature presentation
It’s possible to specify for a feature type:
• color – attribute containing RGB color code. The color will be used for the icon representing the
features in the list
• formPicture – link to resource containing raster image. The image will be displayed in the editing
form header
Example:
<ber:featurePresentation>
<ber:featureType xlink:href="model.xml#ft_aaa">
<!—- Resource containing the picture -->
<ber:formPicture xlink:href="resource.xml#resource_id"/>
<ber:attributeArray>
<!—- Attribute containing color -->
<ber:attribute id="color" xlink:href="model.xml#at_123"/>
</ber:attributeArray>
</ber:featureType>
<ber:featureType xlink:href="model.xml#ft_bbb">
<ber:attributeArray>
<!—- Attribute containing color code in related codelist column -->
<ber:attribute id="color" xlink:href="model.xml#at_456/ca_010_color "/>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

321

</ber:attributeArray>
</ber:featurePresentation>

24.12 TELCO in LIDS Mobile
List of feature types containing TELCO structure considered by LIDS Mobile is defined by specifying
metadata group id in groupArray of mobile.xml.
Example:
<ber:groupArray>
<group key="telcoNodeElements" value="telcoDevices"/>
</ber:groupArray>

24.13 Parameters
•
•

•

tenant – optional paramater for calling Business server; default value is asseco-ce
offlineChangesTimeLimit – optional parameter [hours] setting the oldest possible change done in
offline which can be synchronized when switching to online. If the oldest change is older than the
parameter, the synchronizing is rejected
myPlacesFolder – optional parameter includes folder id in store. If defined, My Places settings are
saved in this folder instead of the root folder

Example:
<ber:parameterArray>
<ber:parameter name="tenant" value="business"/>
<ber:parameter name="offlineChangesTimeLimit" value="24"/>
<ber:parameter name="myPlacesFolder" value="8888888888"/>
</ber:parameterArray>

24.14 Monitoring user position
If following configuration is defined, LIDS Mobile updates geometry of a feature representing logged
user according to the real position.
• updatePositionInterval – time in seconds. If the position changed after given time, update is sent
• featureType – feature type whose geometry is to be updated
• graphicComponentType – graphical child feature type to be updated in case of feature type with
shared semantics
• userId – attribute which includes ID of the user (corresponding to SEC_USER.USER_ID)

Implementation Guide

322

24 – LIDS MOBILE

Example:
<ber:user updatePositionInterval="20">
<ber:featureType xlink:href="model.xml#ft_employee">
<ber:graphicComponentType xlink:href="model.xml#ft_g_employee_curPos"/>
</ber:featureType>
<ber:attributeArray>
<ber:attribute id="userId" xlink:href="model.xml#at_employee_userId"/>
</ber:attributeArray>
</ber:user>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

323

Implementation Guide

Chapter 25
Search Extension

IMPLEMENTATION GUIDE VERSION 9.6

25.

327

Search Extension
LIDS Search extension provides Elasticsearch functionality to standard LIDS and SAMO clients.
Elasticsearch is a distributed, RESTful search and analytics engine. It provides scale and high
availability. Elasticsearch has the ability to be schema-less, which means that documents can be indexed
without explicitly providing a schema.
Elasticsearch stores data to be evaluated in the embedded database. This is secondary data storage
necessary to provide the functionality and this data storage must be synchronized with the primary data
storage in LIDS.
Search extension is responsible for communication between LIDS and Elasticsearch engine. The
functionality of Search extension include:
• on demand updating the data in Elasticsearch database
• on the fly updating the data in Elasticsearch database during standard data manipulation in LIDS
• evaluating queries from clients and providing the query result from Elasticsearch

Example: Structure of search.xml.
<?xml version="1.0" encoding="utf-8"?>
<ber:search xmlns:ber="http://www.berit.com/ber"
xmlns:xlink="http://www.w3.org/1999/xlink">
<ber:version>
<ber:metadata>1</ber:metadata>
<ber:minClient>5140</ber:minClient>
<ber:minAS>12601</ber:minAS>
</ber:version>
<ber:defaultBulkSize>50</ber:defaultBulkSize>
<ber:locale>cs_CZ</ber:locale>
<ber:esConnection>
<ber:esClusterName>${elasticClusterName}</ber:esClusterName>
<ber:esTransportAddressesArray>
<ber:esTransportAddress address="${elasticHost}" port="${elasticPort}"/>
</ber:esTransportAddressesArray>
<ber:indexPrefix>s__</ber:indexPrefix>
</ber:esConnection>
<ber:featureTypeIndexImageArray>
<ber:featureTypeIndexImage id="fti_1" featureTypeId="*">
<ber:indexedAttributeArray>
<ber:indexedAttribute>
<ber:includeAttribute>*</ber:includeAttribute>
</ber:indexedAttribute>
</ber:indexedAttributeArray>
<ber:indexGeometry>true</ber:indexGeometry>
<ber:indexGeometryForSearch>false</ber:indexGeometryForSearch>

Implementation Guide

328

27 – CHANGE MANAGEMENT
<ber:geometryPrecision>5m</ber:geometryPrecision>
<ber:languageSpecificKeyword>true</ber:languageSpecificKeyword>
</ber:featureTypeIndexImage>
</ber:featureTypeIndexImageArray>
<ber:codelistIndexImageArray>
<ber:codelistIndexImage id="cdi_1" codelistId="*">
<ber:indexedAttributeArray>
<ber:includeAttribute>*</ber:includeAttribute>
</ber:indexedAttributeArray>
</ber:codelistIndexImage>
<ber:codelistIndexImage id="presetsExample" extends=" cdi_1" codelistId="cl_1">
<ber:indexedAttributeArray>
<ber:indexedAttribute>
<ber:includeAttribute>ca_1</ber:includeAttribute>
<ber:fieldPreset>autocomplete</ber:fieldPreset>
<ber:fieldPreset>startswith</ber:fieldPreset>
<ber:fieldPreset>withoutdiacritics</ber:fieldPreset>
</ber:indexedAttribute>
<ber:indexedAttribute>
<ber:includeAttribute>*</ber:includeAttribute>
</ber:indexedAttribute>
</ber:indexedAttributeArray>
</ber:codelistIndexImage>
</ber:codelistIndexImageArray>
<ber:indexedCodelistsArray>
<ber:indexedGroup groupId="gr_1"/>
<ber:indexedCodelist codelistId="cl_1"/>
<ber:indexedCodelist codelistId="cl_2"/>
<ber:indexedCodelist codelistId="cl_abc*"/>
</ber:indexedCodelistsArray>
<ber:indexedFeaturesArray>
<ber:indexedGroup groupId="gr_1"/>
<ber:indexedGroup groupId="gr_2"/>
<ber:indexedFeatureType featureTypeId="ft_abc*"/>
<ber:indexedFeatureType featureTypeId="ft_1"/>
</ber:indexedFeaturesArray>
<ber:cronTriggerArray>
<ber:cronTrigger id="everyHour">
<ber:cronExpression>0 0 * ? * *</ber:cronExpression>
<ber:type>full</ber:type>
<ber:codelistsArray>
<ber:codelist codelistId="cl_1"/>
<ber:codelist codelistId="cl_2"/>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

329

</ber:codelistsArray>
</ber:cronTrigger>
</ber:cronTriggerArray>
</ber:search>

25.1 Elastic Search Connection
Defines connection to the Elasticsearch engine, which needs to be installed and configured separately.




These parameters can be also defined using variables so that various instances of the same project can
share common defintion. Values of these variables are then set by environment properties for each
environment.

Elasticsearch provides REST API which enables health check. It’s possible to use this API to evaluate,
if the connection parameters are set correct.
•
•
•

esClusterName – name of Elasticsearch cluster
address port – URL + port of the running Elastic search
indexPrefix – prefix for index names. Necessary when one Elasticsearch serves more projects (with
different data) to ensure unique index names. Index prefix must be lowercase.

Example:
<ber:esConnection>
<ber:esClusterName>elasticsearch</ber:esClusterName>
<ber:esTransportAddressesArray>
<ber:esTransportAddress address="project.domain.com" port="10150"/>
</ber:esTransportAddressesArray>
<ber:indexPrefix>s__</ber:indexPrefix>
</ber:esConnection>

Example: Connection defined by parameters
<ber:esConnection>
<ber:esClusterName>${elasticClusterName}</ber:esClusterName>
<ber:esTransportAddressesArray>
<ber:esTransportAddress address="${elasticHost}" port="${elasticPort}"/>
</ber:esTransportAddressesArray>
<ber:indexPrefix>s__</ber:indexPrefix>
</ber:esConnection>

25.2 Feature Indexing Configuration
It’s necessary to define, what data and how is indexed in Elasticsearch.
Implementation Guide

330
25.2.1

27 – CHANGE MANAGEMENT
indexedFeaturesArray

The list of feature types to be indexed can be specified either by including individual feature types or
groups. Definition using categories shouldn’t be used anymore.




In both cases, when defining feature type ID or groupID it’s possible to use mask with asterisk “*” as a
wildcard.

In case of shared semantics, the semantic parent should be included in the configuration (both in explicit
feature type IDs list or as group member definition). Graphic feature types from shared semantics group
are not processed when evaluating the search queries.

Example:
<ber:indexedFeaturesArray>
<ber:indexedGroup groupId="gr_1"/>
<ber:indexedGroup groupId="gr_2*"/>
<ber:indexedFeatureType featureTypeId="ft_abc*"/>
<ber:indexedFeatureType featureTypeId="ft_1"/>
</ber:indexedFeaturesArray>



The list of feature types to be searched from particular application (e.g.LIDS Explorer or LIDS Mobile)
can be further narrowed down in the applications specific configuration.

25.2.2

featureTypeIndexImageArray
The way, how individual
featureTypeIndexImage.



features

of

particular

type

are

indexed

is

configured

in

Individual featureTypeIndexImages can be organized in a hierarchy to allow inheriting common
properties from parent images and defining specific properties at children images. In the end, every
feature type is indexed just once according to one definition, even if it falls into more index images.
•
•
•
•
•
•

id – identifier of index image
extends – identifier of parent image definition. If defined, the parameters defined in parent image
definition are inherited. If not defined, no parameters are inherited and have to be defined
featureTypeId – particular feature type id or mask using wildcard
includeAttribute – particular attribute id or mask for defining set of attributes included in the
definition
excludeAttribute – particular attribute id or mask for defining set of attributes excluded from the
definition
addToAllField – defined attributes will be added to the allField index, which is evaluated if no
particular attribute is defined in the query. Default is true

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6
•

•
•
•
•
•
•
•
•

331

allFieldDateFormat – optional definition of the date attribute for adding into allField index. If more
definitions exist for the same attribute, the same value is added more times to the index. When not
defined, then default format (DateTimeFormatter.ISO_LOCAL_DATE e.g. '2011-12-03') is used
fieldPreset – parameters to influence the Elasticsearch filter and tokenizer. For possibilities refer to
Elasticsearch documentation
indexGeometry – defines, if the feature geometry is stored in the index
indexGeometryForSearch – defines if feature geometry is stored in the index the way which enables
searching for features also according to spatial condition
geometryPrecision – parameter to define precission when indexing geometry for search. Setting the
value of the precission to higher number means lower precission, but also lower RAM consumption
repairGeometryForSearch - option that automatically repairs geometry after conversion to WGS84
languageSpecificKeyword – has to be set to true to make the language specific letters to be ordered
correctly. If set to false, the specific letters appear at the end of the ordered list
allFieldTemplate – sophisticated formating definition when adding to allField index
filterWithoutDiacritics – if set to true, whole index is created using asciifolding so that the search
filter ignores diacritics

Example:
<ber:featureTypeIndexImageArray>
<ber:featureTypeIndexImage id="fti_1" featureTypeId="ft_abc*">
<ber:indexedAttributeArray>
<ber:indexedAttribute>
<ber:includeAttribute>*</ber:includeAttribute>
<ber:excludeAttribute>atTest*</ber:excludeAttribute>
<ber:excludeAttribute>createdBy</ber:excludeAttribute>
<ber:excludeAttribute>updatedBy</ber:excludeAttribute>
<ber:allFieldDateFormatArray>
<ber:allFieldDateFormat>dd-MM-yyyy</ber:allFieldDateFormat>
<!-- for cs locale will produce e.g. 23.srpen 2017 -->
<ber:allFieldDateFormat>dd.LLLL yyyy</ber:allFieldDateFormat>
</ber:allFieldDateFormatArray>
</ber:indexedAttribute>
</ber:indexedAttributeArray>
<ber:indexGeometry>false</ber:indexGeometry>
<ber:indexGeometryForSearch>false</ber:indexGeometryForSearch>
<ber:allFieldTemplate>
<![CDATA[<#if at_12??>${at_12?number_to_date?string["dd.MM.yyyy"]}</#if>]]>
</ber:allFieldTemplate>
</ber:featureTypeIndexImage>
<ber:featureTypeIndexImage id="fti_2" extends="fti_1" featureTypeId="ft_abc*">
<ber:indexedAttributeArray>
<ber:indexedAttribute>
<ber:includeAttribute>at_1</ber:includeAttribute>
<ber:addToAllField>false</ber:addToAllField>

Implementation Guide

332

27 – CHANGE MANAGEMENT
<ber:fieldPreset>autocomplete</ber:fieldPreset>
<ber:fieldPreset>startswith</ber:fieldPreset>
<ber:fieldPreset>withoutdiacritics</ber:fieldPreset>
</ber:indexedAttribute>
</ber:indexedAttributeArray>
<ber:indexGeometry>true</ber:indexGeometry>
<ber:indexGeometryForSearch>true</ber:indexGeometryForSearch>
<ber:geometryPrecision>5m</ber:geometryPrecision>
<ber:repairGeometryForSearch>true</ber:repairGeometryForSearch>
</ber:featureTypeIndexImage>
<ber:featureTypeIndexImage id="fti_3" featureTypeId="ft_def">
<ber:indexedAttributeArray>
<ber:indexedAttribute>
<ber:includeAttribute>atFoo*</ber:includeAttribute>
<ber:includeAttribute>atBar*</ber:includeAttribute>
<ber:excludeAttribute>atFoo123</ber:excludeAttribute>
<ber:excludeAttribute>atBar123</ber:excludeAttribute>
</ber:indexedAttribute>
</ber:indexedAttributeArray>
<ber:indexGeometry>false</ber:indexGeometry>
<ber:indexGeometryForSearch>false</ber:indexGeometryForSearch>
<ber:filterWithoutDiacritics>true</ber:filterWithoutDiacritics>
</ber:featureTypeIndexImage>

</ber:featureTypeIndexImageArray>

25.3 Codelists Indexing Configuration



For usage in standard LIDS clients it’s not necessary to index codelists at all. They are currently used
by SAMO dynamic client only.
The definition of codelists indexing is very similar to the feature types indexing definition.

25.3.1

indexedCodelistsArray
The list of codelists to be indexed is specified either by including individual codelist IDs or groups, with
the possibility to use asterisk “*” as a wildcard.
Example:
<ber:indexedCodelistsArray>
<ber:indexedGroup groupId="gr_1"/>
<ber:indexedGroup groupId="gr_2"/>
<ber:indexedCodelist codelistId="cl_1"/>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

333

<ber:indexedCodelist codelistId="cl_2"/>
<ber:indexedCodelist codelistId="cl_abc*"/>
</ber:indexedCodelistsArray>

25.3.2

codelistIndexImageArray
The way, how individual codelists are indexed is configured in codelistIndexImage. Individual
codelistIndexImages can be organized in a hierarchy to allow inheriting common properties from parent
images and defining specific properties at children images.
•
•
•
•
•
•

id – identifier of index image
extends – identifier of parent image definition
codelistId – particular codelist id or mask using wildcard
includeAttribute – particular attribute id or mask for defining set of attributes included in the
definition
excludeAttribute – particular attribute id or mask for defining set of attributes excluded from the
definition
fieldPreset – parameters to influence the Elasticsearch filter and tokenizer. For possibilities refer to
Elasticsearch documentation

Example:
<ber:codelistIndexImageArray>
<ber:codelistIndexImage id="cdi_1" codelistId="cl_abc*">
<ber:indexedAttributeArray>
<ber:includeAttribute>*</ber:includeAttribute>
<ber:excludeAttribute>caTest*</ber:excludeAttribute>
</ber:indexedAttributeArray>
</ber:codelistIndexImage>
<ber:codelistIndexImage id="presetsExample" extends=" cdi_1" codelistId="cl_1">
<ber:indexedAttributeArray>
<ber:indexedAttribute>
<ber:includeAttribute>ca_1</ber:includeAttribute>
<ber:fieldPreset>autocomplete</ber:fieldPreset>
<ber:fieldPreset>startswith</ber:fieldPreset>
<ber:fieldPreset>withoutdiacritics</ber:fieldPreset>
</ber:indexedAttribute>
</ber:indexedAttributeArray>
</ber:codelistIndexImage>
<ber:codelistIndexImage id="cdi_2" codelistId="cl_xyz">
<ber:indexedAttributeArray>
<ber:includeAttribute>ca2</ber:includeAttribute>
<ber:includeAttribute>ca3</ber:includeAttribute>
<ber:includeAttribute>ca4</ber:includeAttribute>

Implementation Guide

334

27 – CHANGE MANAGEMENT
<ber:fieldPreset>withoutdiacritics</ber:fieldPreset>
</ber:indexedAttributeArray>
</ber:codelistIndexImage>

</ber:codelistIndexImageArray>

25.4 Updating Elasticsearch Index
The consistency between LIDS and Elasticsearch is maintained automatically when working standard
way with LIDS data.
Situations when indexing / reindexing must be executed on demand include:
• Initial indexing after installing Elasticsearch
• Change of Search extension configuration
• Some bulk operations in silent mode, such as import
• Data modification directly in the database
• Change of the attributes definition for indexed feature type
• Change of geometry type for indexed feature type
The indexing / reindexing on demand can be activated:
• in LIDS console
• by calling the REST API
• using a tool like e.g. Postman
• by cron scheduler

25.4.1

Reindexing scheduler configuration
cronTriggerArray enables definition of individual triggers which are processed automatically by cron
scheduler.
•

•

•
•

cronExpression – specifies the firing schedule. The pattern is a list of six single space-separated
fields representing: second, minute, hour, day, month, weekday. Month and weekday names can be
given as the first three letters of the English names. Example patterns:
• "0 0 * * * *" = the top of every hour of every day.
• "*/10 * * * * *" = every ten seconds.
• "0 0 8-10 * * *" = 8, 9 and 10 o'clock of every day.
• "0 0/30 8-10 * * *" = 8:00, 8:30, 9:00, 9:30 and 10 o'clock every day.
• "0 0 9-17 * * MON-FRI" = on the hour nine-to-five weekdays
• "0 0 0 25 12 ?" = every Christmas Day at midnight
type – type of reindexing
• full - does full re-index
• updatedSince - does incremental re-index from the moment when it is started
group – group to be indexed
authoredBy – user login; the re-indexing is running under the identity of defined user

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

335

Example:
<ber:cronTriggerArray>
<ber:cronTrigger id="everyNightAt3">
<ber:cronExpression>0 0 3 * * *</ber:cronExpression>
<ber:type>updatedSince</ber:type>
<ber:groupArray>
<ber:group>group_1</ber:group>
<ber:group>group_2</ber:group>
</ber:groupArray>
<ber:authoredBy>administrator</ber:authoredBy>
</ber:cronTrigger>
<ber:cronTrigger id="everySaturdayAt12">
<ber:cronExpression>0 0 12 * * SAT</ber:cronExpression>
<ber:type>full</ber:type>
<ber:groupArray>
<ber:group>group_3</ber:group>
<ber:group>group_4</ber:group>
</ber:groupArray>
<ber:authoredBy>superuser</ber:authoredBy>
</ber:cronTrigger>
</ber:cronTriggerArray>



Scheduler is enabled only when Environment or System property masterNode is set to true. masterNode
can be overridden by:
•
•
•
•
•
•
•
•
•

samo.lids.{context}.search. masterNode
samo.lids.{context}.masterNode
lids.{context}.search.masterNode
lids.{context}.masterNode
samo.lids.search.masterNode
samo.lids.masterNode
lids.search.masterNode
lids.masterNode
search.masterNode

25.5 Elasticsearch configuration
Main configuration of Elasticsearch is included in elasticsearch.yml. The suggested parameters to be
added follow:
# cluster name has to correspond to the esClusterName parameter in search.xml
cluster.name: elasticsearch
# default ports after installation are 9200 and 9300. Can be changed following way:

Implementation Guide

336

27 – CHANGE MANAGEMENT

http.port: 6200
transport.tcp.port: 6300
action.auto_create_index:
.security*,.monitoring*,.watches,.triggered_watches,.watcher-history*,.ml*
cluster.routing.allocation.disk.threshold_enabled: false




It’s
a
YAML
file
with
specific
https://docs.ansible.com/ansible/2.4/YAMLSyntax.html

syntax

as

described

here:

Elasticsearch memory usage when running as Windows service is configured by specifying –Xms and
–Xmx parameters under registry key: HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Apache
Software
Foundation\Procrun
x64\Parameters\Java\Options

2.0\elasticsearch-service-

For more information, please, refer to Elasticsearch online documentation.

25.6 Limitations
Search extension fully respects following security settings of LIDS:
• feature type access rights
• attribute access rights
• security codelists
• ownership
The only exception is FILTER access right on attribute. This option is not considered. So if some
attribute shouldn’t be available for filtering, it has to be excluded from the Search extension indexing.

Implementation Guide

Chapter 26
Collaboration

IMPLEMENTATION GUIDE VERSION 9.6

26.

339

Collaboration
Collaboration extension enables two groups of functions:
• Writing comments to individual features
• Sending notifications at defined events
Main configuration is stored in collaboration.xml which is stored in extensions folder.
Example of collaboration.xml:
<?xml version="1.0" encoding="utf-8"?>
<ber:collaboration xmlns:ber="http://www.berit.com/ber"
xmlns:xlink="http://www.w3.org/1999/xlink">
<ber:version>
<ber:metadata>1</ber:metadata>
<ber:minClient>5140</ber:minClient>
<ber:minAS>12601</ber:minAS>
</ber:version>
<ber:subscription>
<ber:notification>
<ber:email>
<ber:smtpHostName>smtp.intranet.local</ber:smtpHostName>
<ber:smtpPort>25</ber:smtpPort>
<!-- <ber:smtpUser>${smtpUser}</ber:smtpUser>
<ber:smtpPassword>${smtpPassword}</ber:smtpPassword>
<ber:smtpUseSSL>${smtpUseSSL}</ber:smtpUseSSL> -->
<ber:senderEmailAddress>SAMO@asseco-ce.com</ber:senderEmailAddress>
</ber:email>
</ber:notification>
<ber:subscriptionConfigurations>
<ber:subscriptionConfiguration>
<ber:featureTypes>
<ber:featureTypeRef id="ft_1"/>
<ber:featureTypeRef id="ft_ab*"/>
</ber:featureTypes>
<ber:defaultEvents>
<ber:event>commentCreated</ber:event>
</ber:defaultEvents>
<ber:autoSubscriptions>
<ber:autoSubscription>
<ber:onEvents>
<ber:event>featureCreated</ber:event>
</ber:onEvents>
<ber:subscribeToEvents>

Implementation Guide

340

27 – CHANGE MANAGEMENT
<ber:event>featureUpdated</ber:event>
<ber:event>commentCreated</ber:event>
<ber:event>commentUpdated</ber:event>
</ber:subscribeToEvents>
</ber:autoSubscription>
<ber:autoSubscription>
<ber:onEvents>
<ber:event>commentCreated</ber:event>
</ber:onEvents>
<ber:subscribeToEvents>
<ber:event>commentCreated</ber:event>
<ber:event>commentUpdated</ber:event>
</ber:subscribeToEvents>
</ber:autoSubscription>
</ber:autoSubscriptions>
</ber:subscriptionConfiguration>
</ber:subscriptionConfigurations>
</ber:subscription>
<ber:commentConfigurations>
<ber:commentConfiguration>
<ber:featureTypes>
<ber:featureTypeRef id="ft_1"/>
<ber:featureTypeRef id="ft_2"/>
<ber:featureTypeRef id="ft_3" />
<ber:featureTypeRef id="ft_4" />
<ber:featureTypeRef id="ft_ab*"/>
</ber:featureTypes>
</ber:commentConfiguration>
</ber:commentConfigurations>

</ber:collaboration>

26.1 Writing comments to individual features
The component for writing comments to features is displayed for feature types defined in
commentConfiguration section.
These feature types are automatically added to the system group collaboration-comments.



When defining feature types it’s possible to use mask with asterisk “*” as a wildcard.

26.2 Sending notifications at defined events
Notifications can be sent to the users at defined events done by other users. These events include creating
of comment, editing of comment, update of feature.
Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6
26.2.1

341

Subscribing to notification
The notifications are sent to the users who subscribed to particular events on individual features. The
subscriptions are stored in SAMO_COLLAB_SUBSCRIPTION table in database.
The table includes following columns:
• ENTITY_ID – FID of the subscribed feature
• ENTITY_TYPE_ID – feature type id of the subscribed feature
• EVENT – subscribed event which should trigger the notification. Possible values: commentCreated,
commentUpdated, featureUpdated
• USER_ID – user, who gets the notification (email is taken from SEC_USER.EMAIL)
The subscriptions (=entries in the table) can be filled by some client functionality or automatically by
collaboration extension.
Configuration of automatic subscription is included in autoSubscriptions in collaboration.xml. This
configuration defines events when the user automatically subscribe to defined events on given feature.
Following configuration defines – the user, who creates the feature, automatically subscribes to
notifications when the created feature is updated, comment is created or updated on the feature
by another user:
<ber:autoSubscription>
<ber:onEvents>
<ber:event>featureCreated</ber:event>
</ber:onEvents>
<ber:subscribeToEvents>
<ber:event>featureUpdated</ber:event>
<ber:event>commentCreated</ber:event>
<ber:event>commentUpdated</ber:event>
</ber:subscribeToEvents>
</ber:autoSubscription>

26.2.2

Notification form
The notification is sent as email message. The sender configuration is included in email section of
collaboration.xml.
The addressee of the message is the email configured for the subscribing user in Security.
The email content is configured by creating templates stored under lids-as\resources\template folder.
The template names are dervied from the event:
• commentCreatedSubject.txt – defines email subject for commentCreated event
• commentCreatedBody.html – defines email body for commentCreated event
• commentUpdatedSubject.txt – defines email subject for commentUpdated event
• commentUpdatedBody.html – defines email body for commentUpdated event
• featureUpdatedSubject.txt – defines email subject for featureUpdated event
Implementation Guide

27 – CHANGE MANAGEMENT

342
•

featureUpdatedBody.html – defines email body for featureUpdated event

The templates can include following variables, which are replaced by appropriate values when creating
the email
• user.username, user.eMail, user.firstName, user.lastName, user.principal – properties of the user
who did the change activating the event
• entity.entityTypeName – feature type name of the affected feature
• entity.featureInfo – feature info of the affected feature
• payload.changedComment.body – new state of the comment
• payload.originalComment.body – original state of the comment (for commentUpdated event)
• payload.changedAttributes.attributeName – changed attribute name
• payload.changedAttributes.attributeType – changed attribute data type
• payload.changedAttributes.attributeId – changed attribute id
• payload.changedAttributes.attributeOriginalValue – original attribute value
• payload.changedAttributes.attributeChangedValue – new attribute value
Example of commentCreatedSubject.txt:
User ${user.username} created comment to ${entity.entityTypeName}
(${(entity.featureInfo)!})

Example of featureUpdatedBody.html:
<#assign s = 'border: 1px solid black; border-collapse: collapse; padding: 10px;'>
<p>
User ${user.username} updated ${entity.entityTypeName}
(${(entity.featureInfo)!}).
</p>
<#assign s = 'border: 1px solid black; border-collapse: collapse; padding: 10px;'>

<table style="${s}">
<tr>
<th style="${s}">Attribute</th>
<th style="${s}">Original value</th>
<th style="${s}">Updated value</th>
</tr>
<#list payload.changedAttributes as changedAttr>
<tr>
<td style="${s}">${changedAttr.attributeName}</td>
<td style="${s}">
<#if changedAttr.attributeType == "DATE" ||
changedAttr.attributeType == "SHORT_DATE">
${(changedAttr.attributeOriginalValue?number_to_datetime)!}
<#else>
${(changedAttr.attributeOriginalValue)!}

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

343

</#if>
</td>
<td style="${s}">
<#if changedAttr.attributeType == "DATE" ||
changedAttr.attributeType == "SHORT_DATE">
${(changedAttr.attributeChangedValue?number_to_datetime)!}
<#else>
${(changedAttr.attributeChangedValue)!}
</#if>
</td>
</tr>
</#list>
</table>

Implementation Guide

344

27 – CHANGE MANAGEMENT

Implementation Guide

Chapter 27
Change Management

346

27.

27 – CHANGE MANAGEMENT

Change Management
Change Management extension is used to expand the functionality of long transactions. It encapsulates
pure long transactions functionality and adds following possibilities:
- Definition of project specific long transactions states – workflow
- Definition of access rights using user groups in LIDS Security
- Assignment of individual users to individual long transactions
- Define spatial restriction for editable data
- Define type restriction for editable data
- Optimize client user interface by automating some steps
Main configuration is stored in change-management.xml which is stored in extensions folder.
If change-management.xml extension is defined on a project, the pure functionality of long transactions
is not available to the end user and is completely replaced by the interface of change management. User
is working with change managements instead of long transactions.
The extension defines one or more feature types. Features of these types are related to system long
transation in 1:1 cardinality. The features expand properties of long transactions by project specific
attributes.
Example of change-management.xml:
<?xml version="1.0" encoding="UTF-8"?>
<ber:changeManagement xmlns:xlink="http://www.w3.org/1999/xlink"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:gml="http://www.opengis.net/gml" xmlns:ber="http://www.berit.com/ber">
<ber:version>
<ber:metadata>1</ber:metadata>
<ber:minClient>8888</ber:minClient>
<ber:minAS>12517</ber:minAS>
</ber:version>
<ber:parametersArray>
<ber:parameter name="useSystemToolbar" value="false"/>
<ber:parameter name="allowLoadDataOption" value="false"/>
<ber:parameter name="allowSituationSave" value="true"/>
</ber:parametersArray>
<ber:changeManagementTypeArray>
<ber:changeManagementType>
<ber:featureType xlink:href="model.xml#ft_change_management_simple"/>
<ber:attributeArray>
<ber:attribute id="transactionId" xlink:href="model.xml#at_lt_id"/>
</ber:attributeArray>
<ber:settingArray>
<ber:setting id="initialTemplate" settingId="id_1"/>
</ber:settingArray>
</ber:changeManagementType>
<ber:changeManagementType>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

347

<ber:featureType xlink:href="model.xml#ft_change_management_complex"/>
<ber:attributeArray>
<ber:attribute id="transactionId" xlink:href="model.xml#at_lt_id"/>
<ber:attribute id="lockedById" xlink:href="model.xml#at_locked_by"/>
<ber:attribute id="name" xlink:href="model.xml#at_name"/>
<ber:attribute id="spatialExtent"
xlink:href="model.xml#at_master_feature"/>
<ber:attribute id="layerMagicTool" xlink:href="tool.xml#ti_1"/>
</ber:attributeArray>
<ber:userRestriction>
<ber:relationAssoc xlink:href="model.xml#as_changemngmc_changemngmu"/>
<ber:attributeArray>
<ber:attribute id="userId" xlink:href="model.xml#at_user"/>
<ber:attribute id="writeableId" xlink:href="model.xml#at_writable">
<ber:values false="2" true="1"/>
</ber:attribute>
</ber:attributeArray>
</ber:userRestriction>
<ber:spatialRestriction templateBuffer="1000"/>
<ber:settingArray>
<ber:setting id="typeRestriction" settingId="id_2"/>
<ber:setting id="visualizationModel" settingId="id_3"/>
</ber:settingArray>
</ber:changeManagementType>
</ber:changeManagementTypeArray>
</ber:changeManagement>

Following parameters are common for whole project:
• useSystemToolbar – true / false parameter; default is true. If set to false, the system toolbar Change
Management is disabled & hidden in the client GUI. It’s useful, if the toolbar functions are replaced
by the project tools
• allowLoadDataOption – true / false parameter; default is true. If set to false, the checkbox Load
data when logging in is disabled & hidden in in the client GUI
• allowSituationSave – true / false parameter; default is false. If set to true, a situation is saved every
time user closes Change Management window in the client. The situation is saved under root folder
in settings for every user and every change management feature.
• If the situation for the user & change management exists, it's overwritten
• The short value includes the necessary identifiers
• The situations are never deleted automatically
• The situation is loaded automatically when the user opens the Change Management window
again
• It means the list of layers, which layers are displayed and the position of graphical views
• In this case the visualisationModel from change-management.xml is not applied

Implementation Guide

348

27 – CHANGE MANAGEMENT

Following definitions are independent for individual change management feature types:
• featureType – feature type representing change management / long transaction
• transactionId – feature attribute for storing id of long transaction – link to LIDS_LONG_TRANS
table
• lockedById – feature attribute used to store information about user who has the change management
opened in read write mode. If such change management is opened by another user, client displays
info and asks if to open the change management in read only mode. The attribute has to be filled by
project specific script. This configuration makes sense only when more read / write sessions in one
long transaction are not allowed - lids.longTransaction.allowMultipleWritableSessions property
• name – feature attribute. The value from this attribute is used on two places in client:
• Replaces %%name%% variable in attribute condition
• Is used as prefix for template names if visualizationModel or initialTemplate are used
• spatialExtent – featureRef attribute to the master feature with geometry. The geometry is then used
for spatialRestriction. The master feature can’t use shared semantics!
• layerMagicTool – link to tool.xml to a layerMagic tool which is activated when opening change
management
• initialTemplate – link to a template setting, which is automatically added to data management when
opening change management
• visualizationModel – link to a display model setting, which is automatically activated when opening
change management
• userRestriction – section which defines assignment of individual users to individual change
management
• relationAssoc – featureRef relation between the change management feature (master) and
binding feature between users and change management (child)
• userId – attribute of the binding feature for storing user id
• writeableId – attribute of the binding feature storing the information about read only access
(false) and read / write access (true). If this element is not defined, the assigned users are
considered to have read / write access and it’s not possible to define read only access for
particular user
• typeRestriction – limits feature types editable in change management. Link to a
featuretypefiltercollection setting. Without this definition, it's possible to edit any data after opening
a change management. The non-versioned data will be visible to everybody immediately after
committing the short transaction
• spatialRestriction – this element activates spatial restriction handling.
• If the related feature loaded using spatialExtent has geometry – the geometry of related feature
is used for spatial restriction, optionally expanded by templateBuffer attribute
• If the change management feature has geometry – the geometry is used for spatial restriction. If
the gometry type is not polygon, MBR is calculated. templateBuffer attribute is not applied if
the change management has its own geometry
• The spatial restriction is applied as spatial condition to all templates automatically loaded when
opening change management
• The spatial restriction is used to fit all opened graphical views when opening change
management if visualizationModel or initialTemplate are used. If a situation is already saved
for the change management, the position of graphical views is loaded from the situation

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

349

27.1 Workflow – states
If change-management.xml extension is defined on a project, it’s possible to define project specific
workflow of handling long transactions, define specific states and conditions, when and how the states
can be changed. But this brings also limitations – the states manipulation has to be implemented by the
project scripts, including creating and committing long transactions. Only the standard functions for
rolling back and deleting long transactions are available.

Implementation Guide

Chapter 28
Appendix A – True
Type Fonts in LIDS
System

IMPLEMENTATION GUIDE VERSION 9.6

28.

351

Appendix A - True Type Fonts in LIDS System
The LIDS system uses True Type fonts (TTF) for displaying symbols and texts. This document describes
the technology of using True Type fonts in the LIDS system.

28.1 Why TTF?
Main argument for TTF using:
• Vector format
• "Open" format (supported in OS)
• Widely accepted (Autodesk, ESRI, Bentley etc.)
Asseco CE applications use TTF:
• LIDS Edit
• LIDS Explorer
• LIDS Browser (TTF are installed in LIDS AS machine)
• LIDS Mobile

28.2 TTF Fundamentals
Basic TTF fundamentals:
• TTF is file with TTF-extension (e.g. Berit_CSN013411.ttf)
• TTF has name – usually the same as file name (e.g. Berit_CSN013411)
• TTF may be installed (putted) in %Windows%\Fonts directory
• TTF (Unicode fonts) can contain more than 65000 symbols (glyphs)

28.3 Creating of TTF
Automatic TTF creating from MicroStation RSC-fonts is impossible because:
• RSC-fonts are based on lines and TTF are based on filled areas
• Testing software for RSC-fonts to TTF conversion was without acceptable results
Tips for using FontCreator software for TTF creating:
• Don't create new font as an empty project, copy it from correct/valid example (e.g.,
Berit_CSN013411.ttf)
• Name of the font file – any valid Windows file name with TTF as a suffix (recommended rule:
Berit_<project_depended_id>.ttf)
• Platform list (menu Format → Platform Manager) should include at least Microsoft Symbol,
Microsoft Unicode BMP (UCS-2) and Macintosh Roman
• Name of the font (full font name) should be the same as the file name and should be the same for
all platforms, see menu Format → Naming ...

Implementation Guide

352

28 – APPENDIX A – TRUE TYPE FONTS IN LIDS SYSTEM
Example of naming properties window:

28.4 Glyph Drawing
Tips for glyph drawing:
• Draw glyphs at least 128 units thick. Thinner doesn't look well when displayed at size < 10 pt
• Use predefined primitives from FontCreator toolbar to construct basic shapes (circle, line ...). Use
geometrics transformation (rotate, scale, translate ...) to modify it
• Align control points to grid 128 x 128 (or 64 x 64)
• Don't forget check glyphs (see menu Font → Validate). Frequently problems are contour with wrong
direction and intersecting edges. Repair it – change direction in right-click menu or function
Union/Intersect/Exclusive contours

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6
28.4.1

353

Example of Glyph

Implementation Guide

354
28.4.2

28 – APPENDIX A – TRUE TYPE FONTS IN LIDS SYSTEM
Glyph width

The glyph width is calculated different way in MicroStation and in the other clients.
Character width in MicroStation is calculated as distance from the left glyph bearing to the right glyph
bounding:

•
•
•
•

MicroStation computes the anchor point in horizontal direction from actual glyph width. It
completely ignores the right bearing.
LIDS Explorer works correctly with the bearings.
Most important is, that if you want to have same look of symbols in LIDS Edit and LIDS Explorer,
you must combine rules for both clients – it means have right bearing equal with right bounding.
So if you want anchor point to be right part of the glyph:
set justification to right center – AnchorPointX = 1 AnchorPointY = 0.5
set left bearings to 0
set right bearing = width of the glyph

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6
28.4.3

355

Glyph height
Basic (unit) font height is calculated as height of the 'A' character (or the first one if missing). The other
glyphs in the font shouldn’t be bigger than this glyph.

28.4.4

Problems with glyphs
Glyph as symbol in TTF has specific problem – leave first glyph (index 0 or $0000 in Hex) empty.
MicroStation has a problem with glyph on this position. Theoretically, font can contain over 65000
glyphs, practically is recommended fill up maximum 100 glyphs.



Glyph must be mapped into any char (or chars) from charset (see menu Format → Mappings ...).

Implementation Guide

356



28 – APPENDIX A – TRUE TYPE FONTS IN LIDS SYSTEM

MicroStation and LIDS Explorer can have problems with some char code ranges. It has been verified
that range between 33 and 126 can be used. It is necessary to map glyphs into usual chars (such as !#+–
*/ signs, digits, uppercase chars and lowercase chars).
•

•
•
•

Center position of each glyph is at coordinate [1024, 1024]. If property align in metadata definition
for feature type is [center, center] (usually case), this coordinate is reference point for placing
symbol.
The drawing of glyph can exceed bounding box [0..2048, 0..2048], but it's not recommended,
because of problem rendering on some devices (plotters ...).
The best is filling whole 2048 x 2048 px area.
Size in meters from metadata is related to height 2048.

28.5 Tips for migration from LIDS 6:
When creating single symbol, it is necessary to take original symbol drawing in RSC into consideration.
Especially its size (was the bounding box filled by symbol completely or not?) and reference point (on
what position of bounding box the reference point was?).
The size and reference point for symbol in TTF must be modified according to this.
Example:
LIDS 6 definition – the reference point is in the center of bounding box; metadata definition contains
center-center and symbol height 2.0:

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

357

Corresponding symbol in TTF – metadata definition contains center-center and symbol height 3.34:

When enlarging symbol, also drawing width will be enlarged in appropriate rate. It can lead to customer's
requirement to thin symbol, i.e. to draw symbol shapes e.g. 96 pixels width.
•

Arial font is used by default when migrating texts and displayable attributes. It can look too thick.
For most of fonts their light version exist (e.g. Arial Light or Swiss 721 Lt BT ). In metadata their
logical name (displayed in MicroStation) must be used.

Example: Font in model.xml.
<se:Font>
<se:SvgParameter name="font-family">Swis721 Lt BT</se:SvgParameter>
</se:Font>

Implementation Guide

358

28 – APPENDIX A – TRUE TYPE FONTS IN LIDS SYSTEM

28.6 Installation of TTF in LIDS
There are two ways of installation TTF into LIDS.

28.6.1

Server based installation
The font is placed in resources directory of LIDS Application Server and referenced from resource.xml
metadata file. LIDS clients then download TTF file from application server and store the files in the
client cache. This is recommended way of fonts installation as they can be centrally managed and
distributed.
Example: Resource.xml for server based installed TTF.
<ber:symbolFontArray>
<ber:symbolFont id="ber_LIDSdemo" name="ber_LIDSdemo">
<ber:formatArray>
<ber:format name="ttf" file="ber_LIDSdemo.ttf" />
</ber:formatArray>
</ber:symbolFont>
</ber:symbolFontArray>


28.6.2

After any TTF update, refresh resource timestamp by LIDS Application Server Console. Then all LIDS
clients update their local copies of TTF in the cache.

Client based installation
The font is only registered in resource.xml without physical reference to TTF file. Then it must be
installed into operating systems of all clients and application server computers.





Fonts should be installed into operating system in a standard way. On Windows you can just copy fonts
manually into %Windows%\Fonts directory. You should rather use Windows Explorer as some of file
managers don't work properly in this case.

If a font is installed both in the operating system and registered in the LIDS Application server resources,
it’s read from the local operating system installation.

After replacing an old font with a new one (installation into operating system), it is necessary to reboot
the PC. Otherwise, the change won’t be detected by LIDS Explorer.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

359

Example: Resource.xml for client based installed TTF.
<ber:symbolFontArray>
<ber:symbolFont id="ber_LIDSdemo" name="ber_LIDSdemo">
<ber:formatArray>
<ber:format name="ttf"/>
</ber:formatArray>
</ber:symbolFont>
</ber:symbolFontArray>

Implementation Guide

360

28 – APPENDIX A – TRUE TYPE FONTS IN LIDS SYSTEM

Implementation Guide

Chapter 29
Appendix B – Advanced Data
Checks

IMPLEMENTATION GUIDE VERSION 9.6

29.

363

Appendix B – Advanced Data Checks
This document describes basic principles of LIDS advanced data checks option and necessary steps for
implementing advanced data checks into LIDS project.

29.1 Advanced Data Checks Principles
•

•

•
•

Advanced data checks are performed by means of database procedures which are stored in database
package LIDS_CHECKS. This package contains only basic set of predefined types of checks. Other
new checks designed based on custom project requirements can be added to the package by
implementer.
Checked data can be any feature type data in given LIDS project. Checked feature data may not be
included in graph structures. Within advanced data checks can be checked any property of feature
data (geometry, attributes values, relation rules etc.)
Special LIDS metadata extension and LIDS settings are used for configuration of advanced data
checks as well.
GUI for handling advanced data check is available in LIDS Edit and LIDS Explorer clients. It allows
the user to select a proper type of check and define the scope of controlled data by means of spatial
condition.

29.2 Advanced Data Checks Configuration in LIDS Project
Configuration of advanced data checks in given LIDS project consists from these basic areas:
LIDS database schema:
•
•
•

Creating auxiliary tables for advanced data checks.
Creating / updating package LIDS_CHECKS.
Fill table FEATURE_TYPES with records.

LIDS settings configuration:
•
•

Creating LIDS settings ”folders” for advanced checks.
Creating LIDS settings “setdefinitions” for advanced checks.

LIDS project metadata configuration:
•
•

Config.xml project configuration file adjustment.
Creating ext-data-checks.xml extended metadata file.

Implementation Guide

29 – APPENDIX B – ADVANCED DATA CHECKS

364
29.2.1

LIDS database schema configuration

Creating logging table
Logging table APL_CHECKS_LOG serves for logging performed advanded checks. For creating this
table you can use script 01_CREATE_TABLE_Apl_Checks_log.sql which is a part of instalation folder
Extended_data_checks.
APL_CHECKS_LOG table structure:
Column_name

Data type

Column description

TASK_ID

NUMBER(10)

Task identifier (from APL_TASK_SEQ sequence);
orimary key

PROCEDURE_NAME VARCHAR2(100)

Name of DB procedure which represents given
check type

START_DATE

DATE

Date, time when given check procedure was started

END_DATE

DATE

Date, time when given check procedure was
finished

ERROR_ID

NUMBER(5)

Identifier of error if procedure was finidshed with
error

LOG

CLOB

Detailed logging information about procedure
running

RESULT

CLOB

List of result (erroneous) features

Creating feature types table
Table FEATURE_TYPES stores basic information about feature types from given project. This set of
information have to be relevant to LIDS project data model and is utilized within database procedures.
For creating this table you can use script 02_CREATE_TABLE_Feature_types.sql which is a part of
instalation folder Extended_data_checks.
FEATURE_TYPES table structure:
Column_name

Data type

Column description

FEATURE_CODE

VARCHAR2(100)

Feature type identifier (FTID)

FEATURE_NAME VARCHAR2(100)

Feature type name (not used in procedures)

SEM_TABLE

VARCHAR2(30)

Semantic table name for given feature type

FEA_TABLE

VARCHAR2(30)

Name of feature container table for given feature type
(without _F, _GR suffix, e.g. GC_WAS)

Only feature types which are used in advanced data checks need to be recorded in this table.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

365

Creating package LIDS_CHECKS
Package LIDS_CHECKS need to be created in LIDS data schema. For creating package you can use
scripts lids_checks_API.sql and lids_checks_BODY.sql which are a part of instalation folder
Extended_data_checks.
This database package contains these data check procedures after installation:
•
•
•
•

find_duplicate_elems_1ftid – Seeks spatially coincident elements of the same feature type.
find_duplicate_elems_nftid – Seeks spatially coincident elements for specified set of feature types.
find_overlap_elems_1ftid – Seeks spatially overlapping elements of the same feature type.
find_overlap_elems_nftid – Seeks spatially overlapping elements for specified set of feature types.

Filling feature types table
Table FEATURE_TYPES must contain basic information about feature types which are used in advanced
check procedures (database procedures in LIDS_CHECKS package).
Example: SQL insert command.
INSERT INTO feature_types (feature_code, feature_name, sem_table, fea_table) VALUES
('ft_g_20800', 'WAS Hydraulischer Strang', 'WAS_HYD_STRANG', 'GC_WAS');
INSERT INTO feature_types (feature_code, feature_name, sem_table, fea_table) VALUES
('ft_g_20801', 'WAS Hydraulischer Knoten', 'WAS_HYD_KNOTEN', 'GC_WAS');
INSERT INTO feature_types (feature_code, feature_name, sem_table, fea_table) VALUES
('ft_g_20100', 'WAW Leitung', 'WAS_LEITUNG', 'GC_WAS');

29.2.2

LIDS settings configuration
Hierarchy of advanced data check types and individual checks for specified data scope is configured by
means of LIDS settings which are stored in LIDS_SETTINGS table.

Creating LIDS settings for advanced checks – „folders”
Hierarchy, i.e. data check types are specified by means of settings with type „folder“. Each type of
advanced data check (e.g. „Finding duplicate elements for 1 FTID“) should have defined 1 folder. It’s
suitable to define 1 “root” setting folder for other folders used for particular data check types.
Example: Folders/setdefinitions hierarchy defined for advanced checks.
Name / Hierarchy

Setting type

Description of meaning

LIDS Check settings

folder

Root folder for all advanced checks

Find_duplicate_elems_1ftid folder

Folder for Find_duplicate_elems_1ftid check type;
parent folder = “LIDS Check setting” folder

Implementation Guide

29 – APPENDIX B – ADVANCED DATA CHECKS

366

Name / Hierarchy

Setting type

Description of meaning

Water category

setDefinition

It defines 1 specific check for
“Find_duplicate_elems_1ftid”check type; data
content is represented by all graphic feature types in
Water category

xxx

setDefinition

Other specific check for given check type

Find_duplicate_elems_nftid folder

Folder for Find_duplicate_elems_Nftid check type;
parent folder = “LIDS Check setting” folder

Water category

setDefinition

It defines 1 specific check for
“Find_duplicate_elems_Nftid” check type; data
content is represented by all graphic feature types in
Water category

xxx

setDefinition

Other specific check for given check type

How such data checks hierachy looks in LIDS Explorer tool GUI you can see below.

You can see on picture above two-levels list of defined advanced data checks. On the first level are
displayed data check types (defined “folder” settings) and on the second level are displayed particulars
data checks (defined “setDefinitions” settings for data checks).
Example: SQL insert command for definition of “folder” settings for exmaple above.
--- Root folder for LIDS Advanced Data Checks
-INSERT INTO lids_settings (id, folder_id, type, user_access, name, description,
owner, create_date, storage, value) VALUES (100, -1, 'folder', 'shared', 'LIDS
Check settings', 'LIDS Check settings', 0, SYSDATE, 'DB', 'ProjectFolder');
--- Subfolders for LIDS Advanced Data Check types
--

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

367

INSERT INTO lids_settings (id, folder_id, type, user_access, name, description,
owner, create_date, storage, value) VALUES (101, 100, 'folder', 'shared', 'Check:
Find_duplicate_elems_1ftid', 'Folder for check setdefinitions:
find_duplicate_elems_1ftid', 0, SYSDATE, 'DB', 'ProjectFolder');
INSERT INTO lids_settings (id, folder_id, type, user_access, name, description,
owner, create_date, storage, value) VALUES (102, 100, 'folder', 'shared', 'Check:
Find_duplicate_elems_Nftid', 'Folder for check setdefinitions:
find_duplicate_elems_Nftid', 0, SYSDATE, 'DB', 'ProjectFolder');

Creating LIDS settings for advanced checks – “setDefinitions”
Specific data checks are defined by particular setting with type „setdefinition“. This type of settings
defines the scope of data for checking with using of type (feature types) and attribute condition. The
„setdefinition“ setting must be assigned to some folder intended for given data check type. More specific
data checks (setdefinitions) can be assigned to 1 data check folder – see previous chapter.
Example: SQL insert command for creating one “setDefinition” setting – one data check.
SET DEFINE OFF;
INSERT INTO lids_settings (id, folder_id, type, user_access, name, description,
owner, create_date, storage, value) VALUES
(1001, 101, 'setdefinition', 'shared', 'Water category', 'Checked features: Water
category', 0, SYSDATE, 'DB',
'&lt;ber:setDefinition version="1.2.0" xmlns:ber=”http://www.berit.com/ber”
xmlns:ogc="http://www.opengis.net/ogc" xmlns:gml=”http://www.opengis.net/gml”
xmlns:xlink="http://www.w3.org/1999/xlink"&gt;'||CHR(10)||
'&lt;ber:featureTypes includeGraphicTags="True"&gt;'||CHR(10)||
'&lt;ber:featureType xlink:href="model.xml#ft_g_20100" /&gt;'||CHR(10)||
'&lt;ber:featureType xlink:href="model.xml#ft_g_20102" /&gt;'||CHR(10)||
'&lt;ber:featureType xlink:href="model.xml#ft_g_20200" /&gt;'||CHR(10)||
'&lt;ber:featureType xlink:href="model.xml#ft_g_20210" /&gt;'||CHR(10)||
'&lt;/ber:featureTypes&gt;'||CHR(10)||
'&lt;ber:semanticConditions /&gt;'||CHR(10)||
'&lt;/ber:setDefinition&gt;' );
COMMIT;
SET DEFINR ON


29.2.3

Of course, LIDS settings can be created via GUI in LIDS Explorer or LIDS Edit as well.

LIDS project metadata configuration

Config.xml project configuration file adjustment
Config.xml file for given LIDS project must contain this definition in section <services><modules>.

Implementation Guide

368

29 – APPENDIX B – ADVANCED DATA CHECKS

Example: Config.xml.
<module name="DbQuery">
<moduleClass>com.berit.lids.service.dbquery.DbQueryModule</moduleClass>
<service name="DbQueryService" servletName="DbQueryService" title="DB Query
Service”>
<requests>
<request name="selectQuery" postServletName="DbQueryService" />
</requests>
</service>
</module>

Creating ext-data-checks.xml extended metadata file
For using advanced data checks in LIDS, extended metadata ext-data-checks.xml file must be added to
LIDS project metadata. After performing previous step concerning config.xml files adjustment newly
created (e.g. empty) ext-data-checks.xml file must be add to {project_root_folder}\model\extensions
directory. Updating of ext-data-checks.xml file can be performed then via LIDS AS Administration
Console, in menu Project info and in tab Metadata extension files, under the item Extended Data Checks.
The ext-data-checks.xml file contains these elements and attributes:
•
•

•
•

•
•

•
•
•

<ber:checkArray> - The list of data check types array.
<ber:check> - This element configures 1 data check type; it has these attributes:
id – Identifier of data check type; must be unique within whole ext-data-checks.xml file.
name – Name of data check type; this name is displayed in GUI in Advanced data checks tool
dialog.
templateFolder – Specifies assignment among data check type and setting folder defined for this
check type; value is composed from “id_” prefix and numeric identifier of proper LIDS setting
(LIDS_SETTINGS.ID attribute value).
<ber:description> – Description of data check type; it’s not mandatory.
<ber:serverCheck> - Element defines other parameters for given data chech type (server check).
service – It means a method of processing of advanced check type; it’s mandatory element with
value "DbQueryService.selectQuery".
<ber:checkParam>.name – Must be constant value “select”.
<ber:checkParam>.value – It specifies SQL statement for calling function representing given
typen of data check; the SQL statement has this form:
"select lids_checks.check_type_name ({0},{1}) from dual"
where name of procedure from LIDS_CHECKS package corresponds with given data check type.
wfs:Query – Can contain more elements (each with feature type identifier typeName) for searching
more feature types by means of 1 location form.
ogc:Filter – Possible values are for example PropertyIsLike, PropertyIsEqualTo,
PropertyIsBetween.
ogc:PropertyName – Attribute identifier (ft_parcel_face/at_parcel_number) or codelist attribute
identifier (ft_5060000/at_5060002/ca_00903).

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

369

29.3 Rules for Adding New Procedures to LIDS_CHECKS Package
It’s possible to extend LIDS_CHECKS package of additional procedures – data checks according to
custom project requirements.
Following rules must be observed:
1. The own data check type is represented by means of individual database function declared in API
in LIDS_CHECKS package. Each new function for data check must be declared in
lids_checks_API.sql file in this form – with 2 mandatory input parameters and returning CLOB
value, e.g.
Example: Data check function.
FUNCTION find_duplicate_elems_nftid
(
template_idR

IN NUMBER,

coordinatesR

IN CLOB

) RETURN CLOB;

Input parameter „template_idR“ has NUMBER data type and identifier of „setDefinition“ setting for
given data check must be passed in. Input parameter „coordinatesR“ has CLOB data type and contains
specification of spatial area for data checking as a list of coordinates in the form X,Y X,Y X,Y …..
2. Description / purpose of function should be attached to the function declaration as well.
3. The same declaration of function and body of function is situated in lids_checks_BODY.sql file.
4. Typical parts within individual data check procedure:
• Creating log record in APL_CHECKS_LOG table by means of create_log subprocedure.
• Verification of existence the setDefinition setting entered in input parameter.
• Reading of feature types for check from input setDefinition setting to list_featuresX variable.
• Reading of spatial area from input parameter by means of get_polygon function.
• The own application login for given data check type (temporary tables can be used due to good
performance of data evaluation - fill_tmp_table subprocedure can be used for it).
• Writing evaluated erroneous elements to output CLOB variable.
• Final modification of log record + set result attribute with erroneous elements identifiers.
• RETURN output CLOB variable.
5. Output CLOB variable contains a list of elements evaluated by data check as erroneous in this form:
• FTID_identifier1,FID_identifier1
• FTID_identifier2,FID_identifier2
• FTID_identifier3,FID_identifier3
6. Each data check procedure should have defined with PRAGMA AUTONOMOUS_TRANSACTION;
running of procedure must be finished by COMMIT statement.
7. Each data check procedure should have EXCEPTION block for treatment of various unspecified
procedure running errors; the SQL error code can be logged to protocol by means of modify_log
subprocedure.
8. Various auxiliary functions and subprocedures which are not directly called as data checks
procedures may not be declared in API; it’s sufficient to place the only in package BODY.

Implementation Guide

370

29 – APPENDIX B – ADVANCED DATA CHECKS

29.4 Verify whether JDBC Driver is Installed on JBoss Server
29.4.1

Install JDBC driver
Installation of JDBC driver on JBoss server is necessary for proper working of LIDS advanced data
(server) checks. The installation steps are described for driver library ojdbc7.jar (Oracle JDBC driver
for Java 7) but should work for other drivers as well.

Create driver module
1. Go to JBoss root directory and to subdirectories \modules\system\layers\base and create
subdirectories \com\oracle\db\main. This directory structure defines a module named
com.oracle.db.
2. Put the ojdbc7.jar file in this directory.
3. Create a new file in the same directory named module.xml and write the following text inside. Note
that the name attribute must match the directory structure and resource-root path must match the
name of the driver file.
4. The name of the driver file.
Example: Driver module.
<?xml version="1.0" encoding="UTF-8"?>
<module xmlns="urn:jboss:module:1.0" name="com.oracle.db">
<resources>
<resource-root path="ojdbc7.jar"/>
</resources>
<dependencies>
<module name="javax.api"/>
<module name="javax.transaction.api"/>
<system export="true">
<paths>
<path name="com/sun/rowset"/>
<path name="com/sun/rowset/internal"/>
<path name="com/sun/rowset/providers"/>
</paths>
</system>
</dependencies>
</module>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

371

Register the Driver Module
1. Go to JBoss root directory and open standalone\configuration\standalone.xml.
2. Find element <subsystem xmlns="urn:jboss:domain:datasources:X.Y"> and its subelement
<drivers>.
3. Insert the following element inside and save the file. Note that the module name must match the
module created in the previous step. Also remember the driver name we chose:
OracleJDBCDriver.
Example: Registration of the driver module.
<driver name="OracleJDBCDriver" module="com.oracle.db">
<driver-class>oracle.jdbc.driver.OracleDriver</driver-class>
<xa-datasource-class>oracle.jdbc.xa.client.OracleXADataSource</xa-datasourceclass>
</driver>

29.5 Using Advanced Data Checks in LIDS Client Applications
Advanced data checks can be used, i.e. user interface for it is available in LIDS Edit and LIDS Explorer
clint. Detailed description how advanced data checks are used in LIDS Edit and LIDS Explorer clients
you can find in user’s guide in the chapter Tools Menu -> Advanced data checks.

Implementation Guide

372

29 – APPENDIX B – ADVANCED DATA CHECKS

Implementation Guide

Chapter 30
Appendix C – Backdrop Maps

IMPLEMENTATION GUIDE VERSION 9.6

30.

375

Appendix C – Backdrop Maps
Backdrop maps are auxiliary graphic data lying under the graphic presentation of the active data –
features. They can be both vectors and rasters (special case of raster backdrop is
binaryRasterBackdropType).

30.1 Basic Goals and Principles
•

Downloading raster data with sufficient performance. For this purpose defined tile cache is used,
which is represented by set of pregenerated tiles (PNG pictures with rasterized data).
Structure and store parameters for tile cache and other tiles parameters are defined by LIDS project
metadata.
Generating, updating and downloading tiles are performed by means of standard LIDS AS services.
Files forming a hierarchical structure (tile cache) are stored in specified file folder, which must be
accessible for LIDS Application Server.
This data are provided (downloaded) by TMS or WMTS services.

•
•
•
•

For your project you can use many different types of backdrop maps, which are also implemented
differently. Following summary gives an overview of different implementations of backdrop maps based
on their data source, behaviour and usability in LIDS Explorer and LIDS Browser.

30.2 Raster Backdrop Maps
30.2.1

WMS layer from external data source
If you want to use WMS layer from external data source (for example Open Street Maps) as a backdrop
map for your project, you need to proceed as follows:

Configuration of XML files
First you need to define backdrop map in model.xml. Layer array in this case contains definition of plain
layer with id, name and format. You can also define maximum size (width and height) of the layer in
pixels. Attribute maxParallelRequests defines how many parallel requests can the server handle. This
number affects the loading speed and responsiveness of the display.
Example: Definition of backdrop type for WMS layer in model.xml.
<ber:backdropTypeArray>
...
<ber:rasterBackdropType id="bd_osm_world" name="OpenStreetMap-WMS">
<ber:description>Open street map WMS for whole world</ber:description>
<ber:layerArray>
<ber:plainLayer id="lay_bd_osm_world_png" name="PNG Open Street Map WMS world" format="png">

Implementation Guide

30 – APPENDIX C – BACKDROP MAPS

376

<ber:maxSize width="512" height="512"/>
<ber:maxParallelRequests>3</ber:maxParallelRequests>
</ber:plainLayer>
</ber:layerArray>
</ber:rasterBackdropType>
...
</ber:backdropTypeArray>

You may want to display chosen backdrop map also in LIDS browser. You need to add its reference to
included layers root.
Example: Including WMS layer in browser.xml.
<ber:folder name="Other backdrops" id="rs_folder_back1">
...
<ber:layer refId="bd_osm_world"/>
...
</ber:folder>

Next you need to define wms backdrop type in option.xml.
Example: Definition of WMS layer from external data source in option.xml.
<ber:externalBackdropTypeArray>
...
<ber:wmsBackdropType version="1.1.1">
<ber:backdropType xlink:href="model.xml#bd_osm_world"/>
<ber:url>http://129.206.228.72/cached/osm?</ber:url>
<ber:srs>EPSG:31467</ber:srs>
<ber:format>image/png</ber:format>
<ber:timeout>20000</ber:timeout>
<ber:method>GET</ber:method>
<ber:additionalParams>
<ber:param key="LAYERS" value="osm_auto:all"/>
<ber:param key="STYLES" value=""/>
<ber:param key="TRANSPARENT" value="TRUE"/>
</ber:additionalParams>
</ber:wmsBackdropType>
...
</ber:externalBackdropTypeArray>

Backdrop type tag contains reference to definition of backdrop map in model.xml. URL attribute refers
to storage path of external data source. Other attributes refer to parameters of GetMap request.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6



30.2.2

377

If you work network infrastructure with proxy access there might occur a problem with external wms
layers display (from the internet). You need to define access to the internet through proxy setting in
LIDS Administration Console, see figure below.

WMS layer from external datasource with defined hierarchy
To speed up loading and displaying of backdrop map from external datasource, you can define its
hierarchy and the backdrop map will be devided to tiles, which will than load separately.

Configuring XML files
Configuration of XML files is similar to chapters 30.2.1.1. First you need to define backdrop map in
model.xml, then you need to define wms backdrop type in option.xml. Next you need to define tms layer
in map-service.xml with cache and structure. At last you can include tms layer in browser.xml.



30.2.3

You don´t need to generate hierarchical structure in LIDS Administration Console. You can let the
server to cache data of lower levels on demand – when users are panning over the map in the LIDS
Browser.

Raster layer with hierarchical structure from internal data source (basic
formats tiff, jpeg, png)
Raster layers with predefined hierarchical structure have an advantage of quick loading and displaying,
because the hierarchy is cached beforehand for predefined zoom levels. Following chapters describe
implementation of this backdrop map type.

Implementation Guide

30 – APPENDIX C – BACKDROP MAPS

378

Configuration of XML files
First you need to define backdrop map in model.xml. Layer array in this case contains definition of main
tiled layer and hierarchical layer both with id, name and format. You also need to define hierarchy,
where decrease ratio responds to steps of the hierarchy (higher means bigger steps, less continuity) and
tile width and height (in pixels) respond to the level of detail.
Example: Definition of backdrop type for raster layer with hierarchy in model.xml.
<ber:backdropTypeArray>
...
<ber:rasterBackdropType id="bd_03" name="City map">
<ber:description>Hierarchical raster</ber:description>
<ber:layerArray>
<ber:mainTiledLayer id="lay_bd_03_tiff" name="TIFF City Map" format="tiff">
<ber:hierarchicalLayer id="lay_bd_03_jpeg" name="JPEG City Map"
format="jpeg">
<ber:hierarchy decreaseRatio="3" tileWidth="1000" tileHeight="1000"/>
</ber:hierarchicalLayer>
</ber:mainTiledLayer>
</ber:layerArray>
</ber:rasterBackdropType>
...
</ber:backdropTypeArray>



GIS Explorer uses only hierarchical layer (jpeg pyramide) for display of this backdrop map type. User
can manage the source files in main tiled layer (tiff source files) through the LIDS Administration
Console.

Configuration of folder hierarchy for source files
According to the definition of backdrop maps in model.xml, LIDS Administration Console automatically
creates folder hierarchy for expected source files, on page Backdrops. You can adjust it (and save) for
your needs, but remember to use logical names.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

379

Registration of source files
Source raster files need to be registered in the database in order to generate hierarchical structure. This
can be done either by LIDS Explorer or using LIDS Ultra Light Client that can be found on
http://<LIDS_AS_URL>/ utils/request.html address.

Using LIDS Explorer
This option is used when working with small amount of source data – tens, hundreds of files.
• First you need to start Backdrop Maps Management, than choose specific backdrop map (City Map)
and its main tile layer (TIFF City Map).
• Then you click Add File and choose source TIFF raster files (one or more at once). Source files will
be registered in the database.

Implementation Guide

380

30 – APPENDIX C – BACKDROP MAPS
Using LIDS Ultra Light Client

This option is used when working with large amount of data, approximately more than 1000 files,
gigabytes of data.
First you need to upload chosen source files to the prepared folder (City_map\tiff_main_tiled).Then in
LIDS Ultra Light Client choose Backdrop Service from Core Services and query Register files in layer.
The query looks like this:
<ber:registerBackdropLayer xmlns:ber="http://www.berit.com/ber"
service="RegisterBackdropLayer"
version="1.0.0"
updateMode="true">
<ber:layerId>lay_bd_03_tiff</ber:layerId>
<ber:validFrom>2017-01-01 00:00:00</ber:validFrom>
<ber:validTo>2018-01-01 00:00:00</ber:validTo>
</ber:registerBackdropLayer>

For registering of source files you need to fill in the right layer id (which refers to main tile layer).
Starting with version LIDS 7.4.0, there is also possibility to work with backdrop map history and set
valid period of source files. This way you will be able to display also the old versions of backdrop maps.
These prerequisites must be fulfilled before registering TIFF files to main tile layer:
• All source TIFF files must have a georeference.
• All source TIFF files must have the same color depth and cannot be mixed full colors and
monochromatic TIFFs.
Now you just click Sent request and the source files will be registered in the database.

Generating hierarchical structure
Generation of hierarchical structure is done by LIDS Administration Console from the page Backdrops.
Before start, you need to check if the parameters of generation – input (main tiled structure) and output
(hierarchical structure) are set properly.The own generation of hierarchical structure for given backdrop
map can be activated by this icon:

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

381

The following dialog appears:

Enter the file names of backdrop files, and run Rebuild. Raster JPEG files for the whole hierarchical
structure should be created in your source folder (C:\lids\lidsdemo\backdrops\City
map\jpeg_hierarchical).

Database – table LIDS_BACKDROP
Both registration of source raster files and generation of hierarchical structure makes changes in the
database, specifically in the table LIDS_BACKDROP. Following scripts are used to make sure if the
changes were carried out correctly.
SELECT COUNT(*) FROM lids_backdrop WHERE bt_id = 'bd_03' AND STRUCT LIKE 'tiled';
SELECT COUNT(*) FROM lids_backdrop WHERE bt_id = 'bd_03' AND STRUCT LIKE
'hierarchical';

LIDS Browser
You may want to display chosen backdrop map also in LIDS browser. You need to add its reference to
included layers root.

Implementation Guide

30 – APPENDIX C – BACKDROP MAPS

382

Example: Including raster layer with hierarchy in browser.xml.
<ber:includedLayers>
...
<ber:layer refId="bd_03"/>
...
</ber:includedLayers>

In this definition the backdrop is downloaded via WMS services using the source files, not the
hierarchical tiles. If the source files are big image data, the display can be really slow. Therefore it is
better to use hierarchical structure through the definition of TMS layer in map-service.xml. Remember
that you also must add defined tms layer to included layers root in browser.xml.
Example: Definition of tms for raster layer with hierarchy in browser.xml.
<ber:tms>
...
<ber:tmsLayers>
...
<ber:tmsLayer id="tms_bd_03" sourceWMSLayer="bd_03">
</ber:tmsLayer>
...
</ber:tmsLayers>
...
</ber:tms>

After Browser configuration in LIDS Administration Console, the defined tms layer should display in
the Console, see figure below. Since you have already defined the backdrop hierarchy, defined tms layer
automatically creates referention to it and no further changes are needed.

30.2.4

Raster layer with hierarchical structure from internal datasource
(MicroStation formats hmr, cot, cit)
This type of backdrop map is implemented much the same as the previous type, see chapter 30.2.2. The
only difference is format of source raster data files, which server during the registration automatically
converts to tiff for further processing. In this chapter we only mention configuration of XML files, which
differs a little from the previous backdrop type.
These special MicroStation formats can be uploaded to the server only with LIDS Edit license (valid for
7.4.0 and older version branch).

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

383

Configuration of XML files
First you need to define backdrop map in model.xml. Layer array in this case contains definition of main
tiled layer, hierarchical layer and tiled layers all of them with id, name and format. You also need to
define hierarchy, where decrease ratio responds to steps of the hierarchy (higher means bigger steps,
less continuity) and tile width and height (in pixels) respond to the level of detail. Single tiled layers
refer to different formats of source data, which can be combined together to create main tiled layer.
Example: Definition of backdrop type for raster layer with hierarchy in model.xml.
<ber:backdropTypeArray>
...
<ber:rasterBackdropType id="bd_lkw" name="Tests - raster">
<ber:description>Hierarchical raster - for tests</ber:description>
<ber:layerArray>
<ber:mainTiledLayer id="lay_bd_lkw_tiff" name="TIFF Tests" format="tiff">
<ber:hierarchicalLayer id="lay_bd_lkw_tiff_h" name="TIFF hierarchical
tests" format="tiff">
<ber:hierarchy decreaseRatio="3" tileWidth="1000" tileHeight="1000"/>
</ber:hierarchicalLayer>
</ber:mainTiledLayer>
<ber:tiledLayer id="lay_bd_lkw_hmr" name="HMR Tests" format="hmr"/>
<ber:tiledLayer id="lay_bd_lkw_cot" name="COT Tests" format="cot"/>
<ber:tiledLayer id="lay_bd_lkw_cit" name="CIT Tests" format="cit"/>
</ber:layerArray>
</ber:rasterBackdropType>
...
</ber:backdropTypeArray>

30.2.5

Historically versioned raster layer with hierarchical structure
This type of backdrop map is used when you need to display same data from different time periods. The
implementation is much the same as the previous type, see chapter 30.2.2. In this chapter we only
mention configuration of XML files and usage in LIDS Browser, which differs a little from the previous
backdrop type.

Configuration of XML files
First you need to define backdrop map in model.xml. Difference between unversioned and versioned
backdrop is in definition of raster backdrop type in setting of attribute versioned to “true”. Layer array
in this case contains definition of main tiled layer and hierarchical layers all of them with id, name and
format. You also need to define hierarchy for every hierarchical layer, where decrease ratio responds to
steps of the hierarchy (higher means bigger steps, less continuity) and tile width and height (in pixels)
respond to the level of detail.

Implementation Guide

30 – APPENDIX C – BACKDROP MAPS

384

Example: Definition of backdrop type for versioned raster layer with hierarchy in model.xml.
<ber:backdropTypeArray>
...
<ber:rasterBackdropType id="bd_02" name="Orthophoto" versioned="true">
<ber:description>Hierarchical raster</ber:description>
<ber:featureType refId="ft_b_orthophoto"/>
<ber:layerArray>
<ber:mainTiledLayer id="lay_bd_02_tiff" name="TIFF Orthophoto"
format="tiff">
<ber:hierarchicalLayer id="lay_bd_02_jpeg" name="JPEG Orthophoto"
format="jpeg">
<ber:hierarchy decreaseRatio="3" tileWidth="1000" tileHeight="1000"/>
</ber:hierarchicalLayer>
<ber:hierarchicalLayer id="lay_bd_02_jpeg_2013" name="JPEG Orthophoto 2013" format="jpeg" date="2013-01-01 00:00:00">
<ber:hierarchy decreaseRatio="3" tileWidth="1000" tileHeight="1000"/>
</ber:hierarchicalLayer>
<ber:hierarchicalLayer id="lay_bd_02_jpeg_2014" name="JPEG Orthophoto 2014" format="jpeg" date="2014-01-01 00:00:00">
<ber:hierarchy decreaseRatio="3" tileWidth="1000" tileHeight="1000"/>
</ber:hierarchicalLayer>
</ber:mainTiledLayer>
</ber:layerArray>
</ber:rasterBackdropType>
...
</ber:backdropTypeArray>

Registration of source files
Registration of source files runs similar as in chapter 30.2.3.3. However to support historical versioning,
you have to fill in valid from and valid to parameters. In LIDS Ultra Ligth client you just fill in right
datum in tags validFrom and validTo. In LIDS Explorer following dialog automatically appears:

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

385

LIDS Browser
There are also two possible ways of adding historically versioned raster layer to LIDS Browser. One is
to only add this layer to included layers in browser.xml and the other one is trough the definition of tms
layer in map-service.xml, see chapter 30.2.3.6. However you need to define single tms layer for every
hierarchical layer.
Example: Definition of tms for versioned raster layer with hierarchy in browser.xml.
<ber:tms>
<ber:tmsLayers>
...
<ber:tmsLayer id="tms_orthophoto" sourceWMSLayer="bd_02"/>
<ber:tmsLayer id="tms_orthophoto_2014" sourceWMSLayer="bd_02" date="2014-0101"/>
<ber:tmsLayer id="tms_orthophoto_2013" sourceWMSLayer="bd_02" date="2013-0101"/>
...
</ber:tmsLayers>
...
</ber:tms>

30.3 Vector Backdrop Maps
30.3.1

Backdrop layer from internal vector data
It is also possible to create backdrop layer from internal vector data.

Configuration of XML files
Layer array in this case contains definition of tiled layers with id, name and format. You can combine
source data of different format (DGN and DWG).
Example: Definition of backdrop type for layer from internal vector data in model.xml.
<ber:backdropTypeArray>
...
<ber:vectorBackdropType id="bd_01" name="Overview map">
<ber:description>More detailed vector backdrop</ber:description>
<ber:layerArray>
<ber:tiledLayer id="lay_bd_01_dgn" name="DGN overview map" format="dgn"/>
<ber:tiledLayer id="lay_bd_01_dwg" name="DWG overview map" format="dwg"/>
</ber:layerArray>
</ber:vectorBackdropType>

Implementation Guide

30 – APPENDIX C – BACKDROP MAPS

386
...

</ber:backdropTypeArray>

Registration of source files
After configuring model.xml, LIDS Administration Console automatically created folder hierarchy for
expected source files. You can see it on page Backdrops.
Since you are using internal data, you have to register them in the database, similar as in chapter 30.2.3.3.
After registration you created backdrop layer can be displayed.

LIDS Browser
To display created backdrop map in LIDS browser you need to add this layer to included layers in
browser.xml.
Example: Including raster layer with hierarchy in browser.xml.
<ber:includedLayers>
...
<ber:layer refId="bd_01"/>
...
</ber:includedLayers>

30.3.2

TMS layer from LIDS project vector data
This type of implementation is used when you want to create backdrop map from your own LIDS project
vector data, using predefined feature types.

Configuration of XML files
Assuming you already have data, which you want to use for backdrop, defined in model.xml, the only
adaptations are made in map-service.xml.
First you need to define tms Layer and reference to source.
Source of the data can be defined three ways:
• Setdefinition: refers to created template, which contains choosen feature types
• Category: refers to id of the category (from model.xml), which contains choosen feature types
• Backdrop: refers to id of backdrop type (from model.xml)
You also need to define cache format (for vector data usually png) and structure. Structure tag in mapservice.xml contains reference to structure defined further.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

387

Example: Definition of tms layer from project vector data in map-service.xml.
<ber:tms>
...
<ber:tmsLayers>
...
<ber:tmsLayer id="tms_detailed_plan" sourceWMSLayer="cat_01">
<ber:cache format="png">
<ber:structure refId="fixedDetailedStruct"/>
</ber:cache>
</ber:tmsLayer>
...
</ber:tmsLayers>
...
</ber:tms>

Structure can be defined in two possible ways:
•
•

fixed detailed structure: contains specific values of scale, usually corresponding to defined scales in
browser.xml
level-defined: uses minimal and maximal scale denominater and given number of levels to compute
actual hierarchy

Example: Definition of structures in map-service.xml.
<ber:structure id="fixedDetailedStruct">
<ber:boundingBox minX="3451400" minY="5481600" maxX="3451850"
maxY="5481900"/>
<ber:tileSize width="512" height="512"/>
<ber:fixedScaleDenominators>
<ber:scaleDenominator>200000</ber:scaleDenominator>
<ber:scaleDenominator>100000</ber:scaleDenominator>
<ber:scaleDenominator>50000</ber:scaleDenominator>
<ber:scaleDenominator>20000</ber:scaleDenominator>
<ber:scaleDenominator>10000</ber:scaleDenominator>
<ber:scaleDenominator>5000</ber:scaleDenominator>
<ber:scaleDenominator>2000</ber:scaleDenominator>
<ber:scaleDenominator>1000</ber:scaleDenominator>
<ber:scaleDenominator>500</ber:scaleDenominator>
<ber:scaleDenominator>200</ber:scaleDenominator>
<ber:scaleDenominator>100</ber:scaleDenominator>
</ber:fixedScaleDenominators>
<ber:gridOrigin x="3451605" y="5481732"/>
</ber:structure>
...

Implementation Guide

388

30 – APPENDIX C – BACKDROP MAPS
<ber:structure id="googleStruct" levels="22" srs="EPSG:900913">
<ber:tileSize width="256" height="256"/>
<ber:scaleDenominators min="282" max="591658711"/>
<ber:gridOrigin x="-20037508.34" y="20037508.34"/>
</ber:structure>

You can also define coordinates of a bounding box, which acts as a spatial restriction for created tms
layer.



Id “googleStruct” means the compatible structure with zoom levels of Google Maps or Openstreetmap
is used (20 levels starting from 1 : 1128).

Generating hierarchical structure
After configuring model.xml, LIDS Administration Console automatically created folder hierarchy for
expected source files. You can see it on page Browser & Map services under TMS layers. Since you are
working with created project data, you don´t need to register any source files. However you need to
generate hierarchical structure using following icon:
The following dialog appears:

Run Build selected levels. Raster PNG files for the whole hierarchical structure should be created in
your source folder (C:\lids\lidsdemo\tile-cache\tms_detailed_plan).
User can also Clear all levels – it means to delete all cached data from the backdrop folder.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6



389

The lower levels of the structure (level 8, 9, 10 from the picture) takes to much time to generate, so
sometimes is better to generate only top levels and let the server to cache data of lower levels on demand
– when users are panning over the map in the LIDS Browser.

LIDS Browser
To display created vector backdrop map in LIDS browser you need to add this layer to included layers
in browser.xml.
Example: Including TMS layer from project vector data in browser.xml.
<ber:includedLayers>
...
<ber:layer refId="tms_ detailed_plan" queryable="false"/>
...
</ber:includedLayers>

30.4 map-service.xml Structure and Possibilities
This metadata file is used mainly for serve map services – WMS, TMS, WMTS. Not only for LIDS
itself but also to share services to other systems or public.
Example: map-service.xml.
<?xml version="1.0" encoding="UTF-8"?>
<ber:modelMapService xmlns:ber="http://www.berit.com/ber"
xmlns:xlink="http://www.w3.org/1999/xlink">
<ber:version>
<ber:metadata>1</ber:metadata>
<ber:minClient>8888</ber:minClient>
<ber:minAS>11809</ber:minAS>
</ber:version>
<ber:wms>
<ber:contexts>
<ber:context id="RedliningSketch">
<ber:layer refId="cat_5070000">
<ber:dimension name="time" units="ISO8601" unitSymbol="H" default="201509-03" multipleValues="0" nearestValue="true" current="1" value="1900-01-01/210012-31/P1D"/>
<ber:dimension name="reference_time" default="2015-09-03"
units="ISO8601"/>
</ber:layer>
<ber:layer refId="cat_5080000" title="Sketch"/>
</ber:context>

Implementation Guide

390

30 – APPENDIX C – BACKDROP MAPS
<ber:context id="UtilityNet">
<ber:layer refId="cat_5010000"/>
<ber:layer refId="cat_5020000"/>
</ber:context>
<ber:context id="Water">
<ber:layer refId="cat_5010000"/>
</ber:context>
<ber:context id="Lighting">
<ber:layer refId="cat_lighting"/>
</ber:context>
</ber:contexts>
<ber:referenceTimeMapping>
<ber:referenceTimeAttribute>
<ber:featureType xlink:href="model.xml#ft_b_orthophoto"/>
<ber:attribute xlink:href="model.xml#at_b_ortho_date"/>
</ber:referenceTimeAttribute>
</ber:referenceTimeMapping>
</ber:wms>
<ber:tms>
<ber:tmsLayers>
<ber:tmsLayer id="tms_water" sourceWMSLayer="cat_5010000">
<ber:cache format="png">
<ber:structure refId="fixedDetailedStruct"/>
</ber:cache>
</ber:tmsLayer>
<ber:tmsLayer id="tms_electricity" sourceWMSLayer="cat_5020000">
<ber:cache format="png">
<ber:structure refId="detailedStruct"/>
</ber:cache>
</ber:tmsLayer>
<ber:tmsLayer id="tms_telco" sourceWMSLayer="setdefinition_1978024840483229">
<ber:cache format="png">
<ber:structure refId="detailedStruct"/>
</ber:cache>
</ber:tmsLayer>
<ber:tmsLayer id="tms_detailed_plan" sourceWMSLayer="bd_07">
<ber:cache format="png">
<ber:structure refId="fixedDetailedStruct"/>
</ber:cache>
</ber:tmsLayer>
<ber:tmsLayer id="tms_detailed_plan_v8" sourceWMSLayer="bd_07_v8">
<ber:cache format="png">
<ber:structure refId="fixedDetailedStruct"/>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

391

</ber:cache>
</ber:tmsLayer>
<ber:tmsLayer id="tms_uo" sourceWMSLayer="cat_5010000">
<ber:cache format="png">
<ber:structure refId="googleStruct"/>
</ber:cache>
</ber:tmsLayer>
<ber:tmsLayer id="tms_orthophoto" sourceWMSLayer="bd_02"/>
<ber:tmsLayer id="tms_orthophoto_2014" sourceWMSLayer="bd_02" date="2014-0101"/>
<ber:tmsLayer id="tms_orthophoto_2013" sourceWMSLayer="bd_02" date="2013-0101"/>
<ber:tmsLayer id="tms_citymap" sourceWMSLayer="bd_03"/>
<ber:tmsLayer id="tms_electr_detail"
sourceWMSLayer="setdefinition_99729004563735008">
<ber:cache format="png">
<ber:structure refId="detailedStruct"/>
</ber:cache>
</ber:tmsLayer>
<ber:tmsLayer id="tms_osm_world_mundalis"
sourceWMSLayer="bd_osm_world_mundalis">
<ber:cache format="png">
<ber:structure refId="fixedDetailedStruct"/>
</ber:cache>
</ber:tmsLayer>
</ber:tmsLayers>
<ber:tmsStructures>
<ber:structure id="detailedStruct" levels="11">
<ber:tileSize width="500" height="500"/>
<ber:scaleDenominators min="128" max="131072"/>
<ber:gridOrigin x="3451605" y="5481732"/>
</ber:structure>
<ber:structure id="fixedDetailedStruct">
<ber:tileSize width="512" height="512"/>
<ber:fixedScaleDenominators>
<ber:scaleDenominator>200000</ber:scaleDenominator>
<ber:scaleDenominator>100000</ber:scaleDenominator>
<ber:scaleDenominator>50000</ber:scaleDenominator>
<ber:scaleDenominator>20000</ber:scaleDenominator>
<ber:scaleDenominator>10000</ber:scaleDenominator>
<ber:scaleDenominator>5000</ber:scaleDenominator>
<ber:scaleDenominator>2000</ber:scaleDenominator>
<ber:scaleDenominator>1000</ber:scaleDenominator>
<ber:scaleDenominator>500</ber:scaleDenominator>
<ber:scaleDenominator>200</ber:scaleDenominator>

Implementation Guide

392

30 – APPENDIX C – BACKDROP MAPS
<ber:scaleDenominator>100</ber:scaleDenominator>
</ber:fixedScaleDenominators>
<ber:gridOrigin x="3451605" y="5481732"/>
</ber:structure>
<ber:structure id="googleStruct" levels="22" srs="EPSG:900913">
<ber:tileSize width="256" height="256"/>
<ber:scaleDenominators min="282" max="591658711"/>
<ber:gridOrigin x="-20037508.34" y="20037508.34"/>
</ber:structure>
</ber:tmsStructures>
</ber:tms>
<ber:wmts>
<ber:contexts>
<ber:context id="">
<ber:layer refId="tms_water"/>
<ber:layer refId="tms_electricity"/>
<ber:layer refId="tms_telco"/>
<ber:layer refId="tms_detailed_plan"/>
<ber:layer refId="tms_uo"/>
<ber:layer refId="tms_orthophoto"/>
<ber:layer refId="tms_orthophoto_2014"/>
<ber:layer refId="tms_orthophoto_2013"/>
<ber:layer refId="tms_citymap"/>
<ber:layer refId="tms_electr_detail"/>
</ber:context>
<ber:context id="Water">
<ber:layer refId="tms_water"/>
<ber:layer refId="tms_orthophoto"/>
</ber:context>
</ber:contexts>
</ber:wmts>

</ber:modelMapService>

30.4.1

WMS Contexts and Services
Using the WMS contexts LIDS AS will share specific WMS services created from:
• Category (defined in model.xml)
• Setdefinition (template from database)
• Backdrop (defined in model.xml)
These services can be found on address http://[lids-as]/WebMapService/[context]?&SERVICE=WMS
Optionally it’s possible to define fixed response URL which is not derived from the LIDS AS URL.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

393

<ber:wms>
<ber:contexts>
<ber:context id=" " url="">
<ber:layer refId="category_1"/>
<ber:layer refId="template_1"/>
<ber:layer refId="backdrop_1"/>
...

30.4.2

TMS layers
Using the TMS Layer LIDS AS will share services through TMS specification. TMS services can be
created from:
• Category (defined in model.xml)
• Setdefinition (setting from database)
• Backdrop (defined in model.xml, using own backdrop hierarchy derived from decreaseRatio)
TMS layer can include historical state of data on particular day specified by date attribute.
<ber:tms>
<ber:tmsLayers>
<ber:tmsLayer id="tms_water" sourceWMSLayer="cat_5010000">
<ber:cache format="png">
<ber:structure refId="fixedDetailedStruct"/>
</ber:cache>
</ber:tmsLayer>
...
<ber:tmsLayer id="tms_orthophoto_2017" sourceWMSLayer="bd_02" date="2017-0101"/>
...

TMS Layers use hierarchy defined in structure element. Structure can be define as:
• Using scale denominators
• Using min max scales and number of levels between (openstreetmap, google maps)
• If backdrop with hierarchy is defined as source for TMS, the structure from hierarchical layers is
used (Connected to a backdrop hierarchy – says list of TMS layers)
<ber:tmsStructures>
<ber:structure id="detailedStruct" levels="11">
<ber:boundingBox minX="3449000" minY="5476300" maxX="3464400"
maxY="5490500"/>
<ber:tileSize width="500" height="500"/>
<ber:scaleDenominators min="128" max="131072"/>
<ber:gridOrigin x="3451605" y="5481732"/>
</ber:structure>
<ber:structure id="fixedDetailedStruct">
<ber:tileSize width="512" height="512"/>

Implementation Guide

394

30 – APPENDIX C – BACKDROP MAPS
<ber:fixedScaleDenominators>
<ber:scaleDenominator>20000</ber:scaleDenominator>
<ber:scaleDenominator>10000</ber:scaleDenominator>
<ber:scaleDenominator>5000</ber:scaleDenominator>
<ber:scaleDenominator>2000</ber:scaleDenominator>
<ber:scaleDenominator>1000</ber:scaleDenominator>
</ber:fixedScaleDenominators>
<ber:gridOrigin x="3451605" y="5481732"/>
</ber:structure>
<ber:structure id="googleStruct" levels="22" srs="EPSG:900913">
<ber:tileSize width="256" height="256"/>
<ber:scaleDenominators min="282" max="591658711"/>
<ber:gridOrigin x="-20037508.34" y="20037508.34"/>
</ber:structure>
</ber:tmsStructures>

Every TMS structure can be limited to the defined “boundingBox” but it is not mandatory – the maximal
area can be counted from the source data (rasters) or model range coordinates. If boundingBox is defined,
the coordinates shouldn’t include decimal digits.
The “tileSize” number is in pixels usually between 256x256 and 1024x1024. This is really about how
the data tiles will look like. In some cases small tiles are better for mobile devices and small displays
(even 128x128). Bigger tiles are better for performance. So you can start with 512x512 and check if it
is ok for your project. Also 768x768 can be used.




30.4.3

How many "levels" to use? If you use it with Google Maps or Openstreetmaps, the googleStruct is
suggested, the zoom levels will be the same, it will be better look and feel. But you can use also your
defined levels as you want, just to have maybe not so much data/levels on the server.

It’s possible to publish TMS in coordinate system different from the project default. The coordinate
system is defined by srs attribute in the structure definition. This possibility is limited to the vector
layers only.

Services
TMS Services
The structure uses the matrix and starting coordinates / starting tiles [server]/0/0/0.png. When not
defined, the starting point 0/0 is from bottom left. The starting point can be also defined inside
gridOrigin element. The negative numbers in tiles numbering are allowed.
For gridOrigin you can choose any coordinate, based on your project range from model.xml, where the
0/0/0.png tile will start.
The
final
TMS
structure
is
available
under
the
address:
http://[lidsas]/TileMapService/[tms_layer]/0/0/0.png

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

395

List of TMS layers can be found in LIDS AS console, under Browser & Map services tab.
Request for TMS Services: not defined yet.
WMTS Services
WMTS is OGC standard to serve tiles (the same tiles as TMS). WMTS contexts are defined using refId's
from TMS Layers.
<ber:wmts>
<ber:contexts>
<ber:context id="">
<ber:layer refId="tms_water"/>
<ber:layer refId="tms_electricity"/>
<ber:layer refId="tms_telco"/>
...

Request for WMTS Services:
http://[lids-as]/WMTS?service=WMTS&version=1.0.0&request=GetCapabilities
There are few differences between TMS and WMTS. Precise specifications can be found at:
• http://wiki.osgeo.org/wiki/Tile_Map_Service_Specification
• http://www.opengeospatial.org/standards/wmts

30.4.4

Security
All services used and shared with LIDS AS and defined in map-service.xml are under LIDS Security. It
means the services are available with basic authentication for allowed users.
When accessing WMS service, access rights to data and to template settings are evaluated. Different
users might get different results when accessing the same WMS service.
In case of WMTS / TMS services, the access rights to data are not evaluated, so all users get the same
results.

Implementation Guide

396

30 – APPENDIX C – BACKDROP MAPS

Implementation Guide

Chapter 31
Appendix D – Application
Server Plugins

IMPLEMENTATION GUIDE VERSION 9.6

31.

399

Appendix D – Application Server Plugins
Plugins are extensions to the basic functionality od LIDS. Definition XML files for plugins/extensions
are copied into this metadata directory: {project_folder}\lids-as\model\extensions. The plugins listeners
are registered in config.xml (see chapter 31.1).
These are available plugins in the version 7.4.1:
browser.xml
bulk-update.xml
cross-section.xml
cross-section-schema-com.xml
cross-section-schema-ele.xml
custom-browse.xml
database-hints.xml
db-procedures.xml
discrepancy.xml
ext-data-checks.xml
ext-dimension.xml
free-form.xml
generate-detail.xml
lrs.xml
map-service.xml
mobile.xml
multi-crs.xml
neplan.xml
parallel-da.xml
profile.xml
pw-connector.xml
relation-constraint.xml
spatial-deriving.xml
telco.xml

31.1 Register Plugin on LIDS AS
1. Copy your .xml file (for example relation-constraints.xml) to model/extensions directory.
2. Register constraint listener in config.xml.
The class com.berit.lids.plugin.relconstraint.ConstraintListener acts as feature and association listener,
hence you must register it in both listener sections of config file.

Implementation Guide

400

31 – APPENDIX D – APPLICATION SERVER PLUGINS

Example: Config.xml with registration of constraint listener.
<featureListeners>
...
<listenerClass>com.berit.lids.plugin.relconstraint.ConstraintListener</listenerClas
s>
</featureListeners>
<associationListeners>
...
<listenerClass>com.berit.lids.plugin.relconstraint.ConstraintListener</listenerClas
s>
</associationListeners>

31.2 custom-browse.xml
Extension is used for setting of graphical environment of LIDS Explorer. It can consist of unlimited
number of definitions of conditional formatting. Each of the definitions is tied with one definition of
form (simpleForm or freeForm). Reference to the form (formId) is stated inside browseCustomization.
This part of xml can also contain 3 optional sections:
• grouping (groupDefinition) – list of attributes in the given order.
• sorting (sortDefinition) – list of attributes in the given order with parameter ascending/descending.
• conditional formatting (conditionalFormat).
An attribute, which is formatted, as well as the definition of format itself have to be stated inside
columnCustomization. User can combine more types of formatting and can choose from following:
• colorScale – selection of format from predefined options (see list below) is required, parameters
minValue and maxValue are optional.
List of predefined formats:
RedYellowGreenColorScale
GreenWhiteRedColorScale
RedWhiteGreenColorScale
BlueWhiteRedColorScale
RedWhiteBlueColorScale
WhiteRedColorScale
RedWhiteColorScale
GreenWhiteColorScale
WhiteGreenColorScale
GreenYellowColorScale
YellowGreenColorScale
•

iconSet – selection of format from predefined options (see list below) is required, parameters
minValue and maxValue are optional.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

401

List of predefined formats:
Arrows3ColoredIconSet
Arrows3GrayIconSet
Triangles3IconSet
Arrows4GrayIconSet
Arrows4ColoredIconSet
Arrows5GrayIconSet
Arrows5ColoredIconSet
TrafficLights3UnrimmedIconSet
TrafficLights3RimmedIconSet
Signs3IconSet
TrafficLights4IconSet
RedToBlackIconSet
Symbols3CircledIconSet
Symbols3UncircledIconSet
Flags3IconSet
Stars3IconSet
Ratings4IconSet
Quarters5IconSet
Ratings5IconSet
Boxes5IconSet
PositiveNegativeArrowsColoredIconSet
PositiveNegativeArrowsGrayIconSet
PositiveNegativeTrianglesIconSet
•

dataBar – selection of format from predefined options (see list below) is required, parameters
minValue and maxValue are optional.

List of predefined formats:
BlueGradientDataBar
GreenGradientDataBar
RedGradientDataBar
OrangeGradientDataBar
LightBlueGradientDataBar
PurpleGradientDataBar
BlueSolidDataBar
GreenSolidDataBar
RedSolidDataBar
OrangeSolidDataBar
LightBlueSolidDataBar
PurpleSolidDataBar

Implementation Guide

31 – APPENDIX D – APPLICATION SERVER PLUGINS

402
•

topBottomRule – selection of format from predefined options (see list below) and parameter
ruleType are required, parameter treshold is optional.
conditionRule – selection of format from predefined options (see list below) and parameters value1
and ruleType are required, parameter value2 is optional.

•

List of predefined formats for topBottomRule and conditionRule:
LightRedFillWithDarkRedText
YellowFillWithDarkYellowText
GreenFillWithDarkGreenText
LightRedFill
LightGreenFill
RedText
GreenText
BoldText
ItalicText
StrikethroughText

Example: Structure of custom-browse.xml.
<ber:browseCustomizationArray>
<ber:browseCustomization formId="ff_mp1" version="1">
<ber:groupDefinition>
<ber:column field="at_5012120"/>
<ber:column field="at_5012115"/>
</ber:groupDefinition>
<ber:sortDefinition>
<ber:sort direction="ascending">
<ber:column field="at_5012115"/>
</ber:sort>
...
</ber:sortDefinition>
<ber:columnCustomization>
<ber:column field="at_5012102">
<ber:conditionalFormat>
<ber:colorScale>
<ber:format predefinedName="WhiteGreenColorScale"/>
</ber:colorScale>
<ber:dataBar minValue="0" maxValue="50000">
<ber:format predefinedName="OrangeGradientDataBar"/>
</ber:dataBar>
</ber:conditionalFormat>
</ber:column>
<ber:column field="at_5012103">

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

403

<ber:conditionalFormat>
<ber:conditionRule ruleType="Less" value1="2010-01-01">
<ber:format predefinedName="LightRedFillWithDarkRedText"/>
</ber:conditionRule>
</ber:conditionalFormat>
</ber:column>
<ber:column field="at_5012002">
<ber:conditionalFormat>
<ber:topBottomRule ruleType="TopPercent" treshold="30">
<ber:format predefinedName="GreenText"/>
</ber:topBottomRule>
...
<ber:iconSet>
<ber:format predefinedName="Arrows5GrayIconSet"/>
</ber:iconSet>
</ber:conditionalFormat>
</ber:column>
<ber:column field="at_5012116" visible="false"/>
</ber:columnCustomization>
</ber:browseCustomization>
<ber:browseCustomization formId="fmd_50110" version="1">
...
<ber:columnCustomization>
<ber:column field="createDate" visible="true">
<ber:conditionalFormat>
<ber:colorScale>
<ber:format predefinedName="RedYellowGreenColorScale"/>
</ber:colorScale>
</ber:conditionalFormat>
</ber:column>
<ber:column field="at_5011001" visible="true">
...
</ber:column>
</ber:columnCustomization>
</ber:browseCustomization>
</ber:browseCustomizationArray>

Implementation Guide

404

31 – APPENDIX D – APPLICATION SERVER PLUGINS

31.3 db-procedures.xml
Extension allows user to run existing database procedures from LIDS Edit / Explorer client applications.
Using simple GUI it is possible to select data for processing and select particular function. Extension
serves mainly for operations specific for the given project and operations which can’t be performed with
LIDS client functions.





The extension is activated in LIDS client using a specific project tool (module id="ProjectProcedures",
function id="openDialog"). Data selection or Template must be selected for launching the extension.
The data selection / template doesn’t need to be saved in the store. It’s always saved into the
preconfigured folder under generated name when executing the extension. The output is simple text
response displayed in the client’s GUI.

Editing must be enabled.
•
•

procedureArray – contains one or more procedures distincted by id.
select – selection of a function from a given package.

Example: Structure of db-procedures.xml.
<?xml version="1.0" encoding="UTF-8"?>
<ber:dbProcedures xmlns:ber="http://www.berit.com/ber">
<ber:version>
<ber:metadata>1</ber:metadata>
<ber:minClient>8888</ber:minClient>
<ber:minAS>11503</ber:minAS>
</ber:version>
<ber:folderId>id_123456</ber:folderId>
<ber:procedureArray>
<ber:procedure id="pr_01" name="Name">
<ber:description>Description</ber:description>
<ber:select>"SELECT package_name.function1_name ({0}) FROM DUAL"</ber:select>
</ber:procedure>
<ber:procedure id="pr_02" name="Name">
<ber:description>Description</ber:description>
<ber:select>"SELECT package_name.function2_name ({0}) FROM DUAL"</ber:select>
</ber:procedure>
</ber:procedureArray>
</ber:dbProcedures>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

405

31.4 relation-constraints.xml
This extension shouldn’t be used anymore. It’s replaced by the relation rules definition in standard
model.xml.
Plugin is used for defining constraints for relations associations which are defined in model.xml. Three
constraint types are supported:
• Unique constraint – defines a child feature attribute for related features whose value must be unique.
• Max cardinality constraint – defines a master feature attribute containing max cardinality value (max
features that can be related).
• Semantic condition constraint – defines a semantic condition for features either from source or
destination, only if the condition is met features can be related.
The following elements are used in xml file, they are highlighted in example:
• constraintArray – represents a constraint collection; it contains one or more constraints.
• uniqueConstraint – element contains relation association reference, child role type reference and
XPath expression specifying feature attribute with unique values.
• relationAssoc – contains xlink reference to the relation association defined in the model.xml
file.
• roleType – contains xlink reference to the relation role defined in the model.xml file.
• attribute – element refers feature attribute via xpath expression, e.g. attributeId or
attributeId/codelistColumnId.
• maxCardinalityConstraint – contains a relation association reference, master role type reference
and a XPath expression. The XPath expression specifies feature attribute containing max cardinality
value (features that can be related).
• semanticConditionConstraint – element contains a relation association reference, role type
reference and either comparison or logic operation. This operation specifies a semantic condition
for features either from source or destination role. A feature is related only when this condition is
fulfilled.
Example: Structure of relation-constraints.xml.
<?xml version="1.0" encoding="utf-8"?>
<relationConstraint xmlns="http://www.berit.com/ber"
xmlns:ogc="http://www.opengis.net/ogc"
xmlns:xlink="http://www.w3.org/1999/xlink">
...
<constraintArray>
<uniqueConstraint name="Unique pumping station identification">
<description>Only pumping stations with unique identification can be related
with master</description>
<relationAssoc xlink:href="model.xml#r_5040000_5010100"/>
<roleType xlink:href="model.xml#rt_5010100_d"/>
<attribute xpath="at_5010007"/>
</uniqueConstraint>
<maxCardinalityConstraint name="Number of PSs &lt;= segment count">
<description>Number of related Pumping stations cannot be greater than master
segment count</description>
<relationAssoc xlink:href="model.xml#r_5040000_5010100"/>

Implementation Guide

406

31 – APPENDIX D – APPLICATION SERVER PLUGINS
<roleType xlink:href="model.xml#rt_5040000_s"/>
<attribute xpath="at_5040002"/>
</maxCardinalityConstraint>

<semanticConditionConstraint name="Water variety of Pumping station must not be
'Unknown'">
<description>Water variety of Pumping station must not be
'Unknown'</description>
<relationAssoc xlink:href="model.xml#r_5040000_5010100"/>
<roleType xlink:href="model.xml#rt_5010100_d"/>
<ogc:PropertyIsNotEqualTo>
operator -->

<!-- choice of comparison or logic

<ogc:PropertyName>at_5010008/ca_10902</ogc:PropertyName>
<ogc:Literal>Unknown</ogc:Literal>
</ogc:PropertyIsNotEqualTo>
</semanticConditionConstraint>
<semanticConditionConstraint name="Water variety of Water mains must not be
'Unknown'">
<relationAssoc xlink:href="model.xml#r_5040000_5010100"/>
<roleType xlink:href="model.xml#rt_5040000_s"/>
<ogc:PropertyIsNotEqualTo>
<ogc:PropertyName>at_5040008</ogc:PropertyName>
<ogc:Literal>-1</ogc:Literal>
</ogc:PropertyIsNotEqualTo>
</semanticConditionConstraint>
</constraintArray>
</relationConstraint>

31.5 spatial-deriving.xml
Plugin enables deriving of attributes based on spatial m:n relation. One spatial condition – the longest
intersection – is implemented so far.
• derivedAttributeArray – represents a collection of attributes to derive.
• derivedAttribute – reference to an attribute from model.xml.
• spatialRelationQuery – represents spatial relation query definition.
• attribute – specifies the source attribute, ie. surface feature attribute with surface name.
• spatialRelationAssoc – i.e. faceToLine spatial relation – all features (generally by different feature
types) associated by this relation are considered.
• spatialInteractionOp – specifies a spatial interaction operation; possible values are
maxIntersectionLength and minIntersectionLength.
Example: Structure of spatial-deriving.xml.
<?xml version="1.0" encoding="utf-8"?>
<spatialDeriving xmlns="http://www.berit.com/ber"
xmlns:xlink="http://www.w3.org/1999/xlink">

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

407

<!-- LIDSdemo project example for spatial deriving plugin -->
<version>
<metadata>1</metadata>
<minClient>8888</minClient>
<minAS>11801</minAS>
</version>
<derivedAttributeArray>
<!-- Derived attribute: ft = Main pipeline segment, attr = Service OU intersection -->
<derivedAttribute xlink:href="model.xml#at_5012120">
<spatialRelationQuery>
<!-- Source attribute: service organization unit name -->
<attribute xpath="at_5060002/ca_00903"/>
<!-- faceToLine spatial relation - all features (generally by different
feature types) associated by this relation are considered -->
<spatialRelationAssoc xlink:href="model.xml#sr_ou_mps"/>
<!-- Spatial interaction operation - possible values are
maxIntersectionLength and minIntersectionLength -->
<spatialInteractionOp>maxIntersectionLength</spatialInteractionOp>
</spatialRelationQuery>
...
</derivedAttributeArray>
</spatialDeriving>



For such an attribute, there should be forbidden an update operation:

<ber:attribute id="at_5012120" name="Service OU - intersection"
dbName="OU_INTERSECT">
<ber:dataType>
<ber:string maxLength="100"/>
</ber:dataType>
<ber:forbiddenOperations>
<ber:update/>
</ber:forbiddenOperations>
</ber:attribute>

Implementation Guide

408

31 – APPENDIX D – APPLICATION SERVER PLUGINS

Implementation Guide

Chapter 32
Appendix E – Resources

IMPLEMENTATION GUIDE VERSION 9.6

32.

411

Appendix E – Resources
Resources extend LIDS in different way than plugins. They may consist of styles, tool icons, report
templates or symbols. The resources for LIDS Edit are often in different format compared to both LIDS
Explorer and LIDS Browser. All additional resources needed for project are copied into this metadata
directory {project_folder}\lids-as\resources\.
Each resource in individual formats (except exportshp) are referenced in resource.xml. Here the different
formats are bound under the common resource identifiers, which can be subsequently referenced in
model.xml, thematization.xml, tool.xml or presentation.xml as common definitions.
Example: Structure of resource.xml.
<?xml version="1.0" encoding="UTF-8"?>
<ber:modelResource xmlns:xlink="http://www.w3.org/1999/xlink"
xmlns:sld="http://www.opengis.net/sld" xmlns:ber="http://www.berit.com/ber">
<ber:iconArray>
<ber:symbolFontArray>
<ber:lineStyleArray>
<ber:fillStyleArray>
<ber:customResourceArray type="dimStyle">
<ber:customResourceArray type="importDGN">
<ber:customResourceArray type="importSHP">
<ber:customResourceArray type="seedDgn">
<ber:customResourceArray type="symbolLibrary">
<ber:customResourceArray type="report">
</ber:modelResource>

32.1 dimstyle
Resource is used for definition of a dimension styles for LIDS Edit. Style is stored in DGN file (e.g.
dimStyles.dgn) in {project_folder}\lids-as\resources\dimstyle. This file is referenced in resource.xml.
Example: Reference to a dimstyle file in resource.xml.
<ber:customResourceArray type="dimStyle">
<ber:customResource id="ds_1" name="ft_5031000">
<ber:formatArray>
<ber:format name="dgn" file="dimStyles.dgn" extResId="template_5031000"/>
</ber:formatArray>
</ber:customResource>
</ber:customResourceArray>

Implementation Guide

412

32 – APPENDIX E – RESOURCES

32.2 exportshp
Function "Export to SHP" is used for exporting feature types into ESRI Shapefile format. Output is ZIP
archive containing DBF, SHP and SHX files - one set for one feature type. In addition to identifications
of exported features, all their attribute data and a text for text features, or a symbol for point features are
saved to DBF files.
A CSV file, which contains a table determining mapping between the column in the DBF file and feature
attribute in LIDS, is also saved in the output ZIP archive for each feature type. The table has the
following columns:
• dbfName – name of the column in the DBF file. Because field name in dBASE table cannot be
longer than 10 characters, LIDS has to shorten the longer column names. Numerical postfix is added
to the name to prevent duplicate column names,
• id – identifier of the attribute in LIDS,
• name – name of the attribute in LIDS,
• dbName – name of the table (container) column in LIDS.
If geometry of features is of the collection type, one set of files is created for each type of geometric
elements.
Additional files are stored here: {project_folder}\lids-as\resources\exportshp.

32.2.1

Configuration of export
The list of exported attributes can be limited by the configuration. The list of excluded attributes is stored
in {project_folder}\lids-as\resources\exportshp\csv\attribute_exclusion.csv.
Example: attribute_exclusion.csv
at_1;at_2;at_3

It is also possible to define the names of columns in the DBF file with the aid of configuration on the
application server: {project_folder}\lids-as\resources\exportshp\csv\attribute_name_mapping.csv. If no
names are defined, then they are generated automatically during export.
Example: attribute_name_mapping.csv
at_4;District
at_5;City
at_6;Street

32.3 fillstyle
Resource is used for definition of a fill styles. Style is stored in XML file (e.g. fs_demo.xml) in
{project_folder}\lids-as\resources\fillstyle.
There is also a reference to the particular style in resource.xml.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

413

Example: Definition of a fill style.
<ber:hatchPattern id="fs_hatch_1">
<ber:lines>
<ber:distance>5</ber:distance>
<ber:rotation>45</ber:rotation>
</ber:lines>
<ber:lineSymbolizer>
<se:Stroke>
<se:GraphicStroke>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ls_3"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
</se:GraphicStroke>
<se:SvgParameter name="stroke-width">2</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
</ber:hatchPattern>
<ber:hatchPattern id="fs_hatch_2">
<ber:lines>
<ber:distance>0.5</ber:distance>
<ber:rotation>45</ber:rotation>
</ber:lines>
<ber:lineSymbolizer>
<se:Stroke>
<se:GraphicStroke>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ls_2"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
</se:GraphicStroke>
<se:SvgParameter name="stroke-width">1</se:SvgParameter>
</se:Stroke>
</ber:lineSymbolizer>
</ber:hatchPattern>

Implementation Guide

32 – APPENDIX E – RESOURCES

414

Example: Reference to the style in a resource.xml.
<ber:fillStyleArray>
<ber:fillStyle id="fs_hatch_1" name="Hatch pattern">
<ber:formatArray>
<ber:format name="xml" file="fs_demo.xml"/>
</ber:formatArray>
</ber:fillStyle>
...
</ber:fillStyleArray>

32.4 icon
Resource is used for storing icons for tool.xml. Icons are stored in {project_folder}\lidsas\resources\icon. They are divided into subfolders according to the format of the icon. This format (for
example “bmp16x16”) is also specified in resource.xml.
The following formats can be used:
_16x16
_32x32
_64x64
bmp
bmp16x16
bmp32x32
bmp64x64
gif
gif16x16
gif32x32
gif64x64
jpg
jpg16x16
jpg32x32
jpg64x64
png
png16x16
png32x32
png64x64
Example: Reference to the icon files in a resource.xml.
<ber:iconArray>
<ber:icon id="ic_e" name="ic_e">
<ber:formatArray>
<ber:format file="ic_e.bmp" name="bmp16x16"/>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

415

</ber:formatArray>
</ber:icon>
...
</ber:iconArray>

Example: Use of the icon in tool.xml.
<ber:toolBoxArray>
...
<ber:toolBox id="Tb_ele" name="Electro">
<ber:description>Tools for electro objects including crosssections</ber:description>
<ber:icon xlink:href="resource.xml#ic_e"/>
<ber:subToolArray>
<ber:tool refId="ti_e_route0"/>
<ber:tool refId="ti_e_route1"/>
<ber:tool refId="ti_e_route2"/>
<ber:tool refId="ti_e_route3"/>
<ber:tool refId="ti_e_route4"/>
<ber:tool refId="ti_e_pcs1"/>
<ber:tool refId="ti_e_pcs2"/>
<ber:tool refId="csr_1"/>
<ber:tool refId="csr_2"/>
<ber:tool refId="ti_parallelDA3"/>
<ber:tool refId="reduction_route"/>
<ber:tool refId="rel_showRelated3"/>
<ber:tool refId="rel_showRelated_route"/>
<ber:tool refId="rel_showRelated_route_browse"/>
<ber:tool refId="rel_showRelated_cables_browse"/>
</ber:subToolArray>
</ber:toolBox>
...
</ber:toolBoxArray>

32.5 importdgn
Resource is used for importing CAD data. Configuration XML files are stored in {project_folder}\lidsas\resources\importdgn. All XML files are subsequently referenced in resource.xml.
Example: XML file used for importing DGN data.
<?xml version="1.0" encoding="utf-8"?>
<ber:elementClassification xmlns="http://www.berit.com/ber"
xmlns:ber="http://www.berit.com/ber">
<ber:attributesDefinitionArray>

Implementation Guide

32 – APPENDIX E – RESOURCES

416

<ber:attributeDefinition id="attdef_01" name="Hydrant">
<ber:Description>Atributes - Hydrant</ber:Description>
<ber:attribute refId="at_5011002" importType="constant">
<ber:parametersArray>
<ber:parameter name="constantValue" value="1"/>
</ber:parametersArray>
</ber:attribute>
</ber:attributeDefinition>
...
</ber:attributesDefinitionArray>
<ber:graphicsElementClassification xmlns:ber="http://www.berit.com/ber">
<!--

Green line-->

<ber:elementClass typeID="ft_5075000">
<ber:classFields>
<ber:level>Level 2</ber:level>
<ber:graphicType>4</ber:graphicType>
</ber:classFields>
</ber:elementClass>
...
</ber:graphicsElementClassification>
</ber:elementClassification>

Example: Reference to the import files in resource.xml.
<ber:customResourceArray type="importDGN">
<ber:customResource id="idgn_1" name="DGN Import water with DA">
<ber:formatArray>
<ber:format name="xml" file="WaterWithDA.xml"/>
</ber:formatArray>
</ber:customResource>
<ber:customResource id="idgn_2" name="DGN Import various ftypes">
<ber:formatArray>
<ber:format name="xml" file="demo_1009.xml"/>
</ber:formatArray>
</ber:customResource>
</ber:customResourceArray>

32.6 importshp
Resource is used for configuring SHP data import. Configuration XML files are stored in
{project_folder}\lids-as\resources\importshp. All XML files are subsequently referenced in
resource.xml.

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

417

Example: XML file used for import.
<?xml version="1.0" encoding="utf-8"?>
<ber:elementClassification xmlns="http://www.berit.com/ber"
xmlns:ber="http://www.berit.com/ber">
<ber:attributesDefinitionArray>
<ber:attributeDefinition id="attdef_01" name="Definition 1">
<ber:Description>Attributes - contant</ber:Description>
<ber:attribute refId="at_5080003" importType="constant">
<ber:parametersArray>
<ber:parameter name="constantValue" value="SHP"/>
</ber:parametersArray>
</ber:attribute>
<ber:attribute refId="at_5080002" importType="dbf">
<ber:parametersArray>
<ber:parameter name="columnName" value="ftid"/>
</ber:parametersArray>
</ber:attribute>
</ber:attributeDefinition>
</ber:attributesDefinitionArray>
<ber:graphicsElementClassification>
<ber:elementClass typeID="ft_5083000">
<ber:classFields>
<ber:graphicType>polygon</ber:graphicType>
</ber:classFields>
<ber:attributeDefinition refId="attdef_01"/>
</ber:elementClass>
</ber:graphicsElementClassification>
</ber:elementClassification>

Example: Reference to the import files in resource.xml.
<ber:customResourceArray type="importSHP">
<ber:customResource id="ishp_1" name="SHP Import I">
<ber:formatArray>
<ber:format name="xml" file="demo_03.xml"/>
</ber:formatArray>
</ber:customResource>
</ber:customResourceArray>

Implementation Guide

418

32 – APPENDIX E – RESOURCES

32.7 linestyle
Resource is used for storing information about line styles.
From technological reasons, individual line styles definitions for different clients use different formats:
• LIDS Explorer and Browser line styles are defined in XML (e.g. ls_linestyle3.xml) and are stored
in {project_folder}\lids-as\resources\linestyle\xml
• LIDS Edit line styles are defined in RSC or LIN (e.g. ls_linestyle3.rsc, ls_linestyle.lin) and are
stored
in
{project_folder}\lids-as\resources\linestyle\rsc
or
{project_folder}\lidsas\resources\linestyle\lin
• LIDS Mobile line styles are defined in JSON
Individual line styles definitions have to be registered in resource.xml. Here the different formats are
bound under the common line style identifiers, which are subsequently referenced in, thematization.xml
and model.xml as common definitions.



Exporting to DGN requires line style to be imported directly into the project seed.dgn. This seed is used
by both LIDS Edit and LIDS Explorer. While LIDS Edit can read the line style from external rsc file,
LIDS Explorer can’t do this and requires the line style to be imported into the seed.dgn. In this case, the
line style definition includes format name="rsc", but filename attribute is missing. This tells to the
system to search for the resource in the seed.dgn directly. Also line styles 1-7 are referred this way,
though they don’t have to be imported into the seed dgn.

Example: Definition of line style and its components in XML format.
<ber:component id="comp_kanspl_podtlak"
uom="http://www.opengeospatial.org/se/units/metre">
<ber:stroke-dasharray>1[ber_LIDSdemo2_123] 1[ber_LIDSdemo2_123] -1
1[ber_LIDSdemo2_120]</ber:stroke-dasharray>
<ber:segmentMode>center</ber:segmentMode>
<ber:requiredLength>9</ber:requiredLength>
<ber:outOfStrokeGlue>none</ber:outOfStrokeGlue>
<ber:strokeArray>
<ber:pointStroke id="ber_LIDSdemo2_123">
<ber:pointSymbolizer>
<se:Graphic>
<se:ExternalGraphic>
<!-- Symbol anchor point is always center-center -->
<se:OnlineResource xlink:href="resource.xml#ber_LIDSdemo2/123"/>
<se:Format/>
</se:ExternalGraphic>
<se:Size>2</se:Size>
<se:Displacement>
<se:DisplacementX>0</se:DisplacementX>
<se:DisplacementY>0</se:DisplacementY>
</se:Displacement>
</se:Graphic>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

419

<ber:symbolHeight>2</ber:symbolHeight>
<ber:rotation type="relative">0</ber:rotation>
</ber:pointSymbolizer>
</ber:pointStroke>
<ber:pointStroke id="ber_LIDSdemo2_120">
...
</ber:pointStroke>
</ber:strokeArray>
</ber:component>
...
<ber:lineStyle id="KAN_POD_SPL">
<ber:components>
<ber:component refId="comp_kanspl_podtlak">
<ber:perpendicularOffset>0</ber:perpendicularOffset>
</ber:component>
<ber:component refId="style_0">
<ber:perpendicularOffset>0</ber:perpendicularOffset>
</ber:component>
</ber:components>
</ber:lineStyle>
...
<ber:lineStyleArray>

Example: Reference to the style in resource.xml.
<ber:lineStyleArray>
...
<ber:lineStyle id="ls_3" name="3">
<ber:formatArray>
<!-- Styles 1 – 7 don’t specify file attribute for RSC format -->
<ber:format extResId="3" name="rsc"/>
<ber:format extResId="3" name="lin"/>
<ber:format file="ls_default.xml" name="xml"/>
<ber:format file="ls_default.json" name="json"/>
</ber:formatArray>
</ber:lineStyle>
...
<ber:lineStyle id="KAN_POD_SPL" name="Waste water 7">
<ber:formatArray>
<ber:format extResId="KAN_POD_SPL" file="ls_linestyle3.xml" name="xml"/>
<!-- Following definition is considered by LIDS Edit display only.
This way the linestyle can’t be used for DGN export -->
<ber:format extResId="KAN_POD_SPL" file="ls_linestyle3.rsc" name="rsc"/>
</ber:formatArray>

Implementation Guide

32 – APPENDIX E – RESOURCES

420

</ber:lineStyle>
...
<ber:lineStyle id="STYLE_COMPLEX_3" name="Style complex 3">
<ber:formatArray>
<ber:format extResId="STYLE_C3" file="ls_linestyle3.xml" name="xml"/>
<!-- Following definition means the linestyle is included in the seed.dgn.
It can be used by:
- LIDS Edit for displaying the data
- LIDS Edit / Explorer for DGN export -->
<ber:format extResId="STYLE_COMPLEX_3" name="rsc"/>
</ber:formatArray>
</ber:lineStyle>
...
</ber:lineStyleArray>

Example: Reference to the style in thematization.xml.
<ber:featureTypeStyle id="fs_route" name="Route">
<se:FeatureTypeName>ft_e_route</se:FeatureTypeName>
<ber:combinedRule defaultScale="true" id="route_0" name="Route">
<ber:lineSymbolizer>
<se:Stroke>
<se:GraphicStroke>
<se:Graphic>
<se:ExternalGraphic>
<ber:onlineResource>
<ber:recode fallbackValue="system.linestyle#solid">
<se:LookupValue>
<ogc:PropertyName>at_5120006_s</ogc:PropertyName>
</se:LookupValue>
<ber:mapItem>
<ber:data>1</ber:data>
<ber:value id="r_ls_solid" name="Operation status: In
operation">system.linestyle#solid</ber:value>
</ber:mapItem>
<ber:mapItem>
<ber:data>0</ber:data>
<ber:value id="r_ls_3" name="Operation status: Out of
service">resource.xml#ls_3</ber:value>
</ber:mapItem>
<ber:elseMapItem>
<ber:value
id="r_ls_else">system.linestyle#solid</ber:value>
</ber:elseMapItem>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

421

...
</ber:featureTypeStyle>

Example: Reference to the style in model.xml.
<ber:featureType id="ft_5060000" name="Service OU - polygon"
parentId="ft_5060000_s" abstract="false" sharedSemantics="true">
<ber:description>Area</ber:description>
<ber:masterGraphics nillable="false">
<ber:surfaceGraphicType>
<ber:symbology>
<ber:polygonSymbolizer>
<ber:fill>
<se:SvgParameter name="fill">#808080</se:SvgParameter>
<se:SvgParameter name="fill-opacity">0.5</se:SvgParameter>
<ber:fillStyle>solid</ber:fillStyle>
</ber:fill>
<se:Stroke>
<se:GraphicStroke>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ls_3"/>
<se:Format/>
</se:ExternalGraphic>
...
</ber:masterGraphics>

32.7.1

Linestyle definitions for LIDS Mobile
User line style logically consists of one line component and of an optional start and end symbol.
User line style consists of following parts:
• One line component for which these properties can be singly set:
• optionally symbol to be drawn at the beginning of curve
• optionally symbol to be drawn at the end of curve
Line component definition consists of:
• Used units (e.g. meters or pixels)
• Optionally line component parts, so called dash-stroke, that defines size and relay of single parts.
The parts can be of following types:
• solid line
• gap
• symbol
• text
Implementation Guide

422
•
•

•

32 – APPENDIX E – RESOURCES
Drawing mode
• continuous – the parts are drawn continuously along the whole curve
Optional parameter of minimal length – it can influence whether single parts of line components
will be drawn - a dash-stroke is drawn if a total length of curve is grater or equal to specified minimal
length
Way how to solve situation when there is not enough space for a dash-stroke part or when some of
size conditions (mentioned above) is not fulfilled. Possible ways:
• render solid line
• render nothing (default behavior)

Start / end symbol properties:
• definition of used symbol
• used units (e.g. meters or pixels)
• symbol size
• symbol indent (distance in x and y direction from the beginning / end of curve towards the center
of used symbol)
• symbol rotation - it can be of two types:
• relative – rotation by specified angle towards the given curve's segment
• absolute – rotation towards global coordinate system
Dash-stroke part definition – symbol:
• definition of used symbol
• symbol size - units are taken over from the parent line component
• symbol indent (distance in x and y direction from the dash-stroke part center towards the center
of used symbol)
• symbol rotation - it can be of two types:
• relative – rotation by specified angle towards the given curve's segment
• absolute – rotation towards global coordinate system
Dash-stroke part definition – text:
• displayed text
• used font
• text height – it is taken over from the parent line component
• text indent (distance in x and y direction from the dash-stroke part center towards the center of
used text)
• text rotation - it can be of two types:
• relative – rotation by specified angle towards the given curve's segment
• absolute – rotation towards global coordinate system
Symbols and texts are not clipped within a dash-stroke part (i.e. they can exceed dash-stroke part size).

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

423

Example: Definition of line styles and its components in JSON format – without symbols.
[
{
"id" : "ls_1",
"unit" : "pixel",
"dashArray" : [
{
"type" : "DASH",
"length" : 6
},
{
"type" : "GAP",
"length" : 4
}
]
},
{
"id" : "ls_2",
"unit" : "pixel",
"dashArray" : [
{
"type" : "DASH",
"length" : 10
},
{
"type" : "GAP",
"length" : 7
}
]
},
{
"id" : "ls_3",
"unit" : "pixel",
"dashArray" : [
{
"type" : "DASH",
"length" : 18
},
{
"type" : "GAP",
"length" : 13
}

Implementation Guide

32 – APPENDIX E – RESOURCES

424

]
},
{
"id" : "ls_4",
"unit" : "pixel",
"dashArray" : [
{
"type" : "DASH",
"length" : 14
},
{
"type" : "GAP",
"length" : 5
},
{
"type" : "DASH",
"length" : 2
},
{
"type" : "GAP",
"length" : 5
}
]
},
{
"id" : "ls_5",
"unit" : "pixel",
"dashArray" : [
{
"type" : "DASH",
"length" : 10
},
{
"type" : "GAP",
"length" : 10
}
]
},
{
"id" : "ls_6",
"unit" : "pixel",
"dashArray" : [
{

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

425

"type" : "DASH",
"length" : 10
},
{
"type" : "GAP",
"length" : 5
},
{
"type" : "DASH",
"length" : 2
},
{
"type" : "GAP",
"length" : 5
},
{
"type" : "DASH",
"length" : 2
},
{
"type" : "GAP",
"length" : 5
}
]
},
{
"id" : "ls_7",
"unit" : "pixel",
"dashArray" : [
{
"type" : "DASH",
"length" : 10
},
{
"type" : "GAP",
"length" : 5
},
{
"type" : "DASH",
"length" : 4
},
{
"type" : "GAP",

Implementation Guide

32 – APPENDIX E – RESOURCES

426

"length" : 5
}
]
}
]

Example: Definition of line styles and its components in JSON format – with symbols.
[
{
"id" : "example_1",
"unit" : "metre",
"dashArray" : [
{
"type" : "DASH",
"length" : 0.5
},
{
"type" : "GAP",
"length" : 0.5
}
]
},
{
"id" : "example_3",
"unit" : "pixel",
"startSymbol" : {
"font" : "arial.ttf",
"symbol" : 42,
"size" : 15,
"rotation" : 45,
"displacementX" : 1,
"displacementY" : -1
},
"endSymbol" : {
"font" : "arial.ttf",
"symbol" : 42,
"size" : 15,
"rotation" : 45,
"displacementX" : 1,
"displacementY" : -1
},

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

427

"dashArray" : [
{
"type" : "DASH",
"length" : 18
},
{
"type" : "GAP",
"length" : 13
},
{
"type" : "TEXT",
"length" : 13,
"font" : "arial.ttf",
"text" : "abc",
"size" : 15,
"rotation" : 45,
"displacementX" : 1,
"displacementY" : -1
},
{
"type" : "SYMBOL",
"length" : 2,
"font" : "arial.ttf",
"symbol" : 22,
"size" : 15,
"rotation" : 45,
"displacementX" : 1,
"displacementY" : -1
}
]
}
]

32.8 report
Resource is used for storing report files (JRXML) and additional files (e.g. XSL or XLSX). Files are
stored in {project_folder}\lids-as\resources\report. Reports from this directory are referenced in
presentation.xml (for more information see chapter 18).
Example: Reference to the report in presentation.xml.
<ber:reportArray>
<!-- Default dynamic portrait report. Possible output formats: pdf, html, xls, csv,
rtf -->

Implementation Guide

32 – APPENDIX E – RESOURCES

428

<ber:dynamicReport id="rp_1" name="Default Portrait" orientation="portrait"
default="true">
<ber:description>Default Portrait Report Template</ber:description>
<ber:outputFormatArray>
<ber:outputFormat default="true">pdf</ber:outputFormat>
<ber:outputFormat>html</ber:outputFormat>
<ber:outputFormat>csv</ber:outputFormat>
<ber:outputFormat>xls</ber:outputFormat>
</ber:outputFormatArray>
<ber:inputParameterArray>
<ber:inputParameter id="TITLE" name="Report Title">
<ber:description>The report title</ber:description>
<ber:defaultValue>Feature Report</ber:defaultValue>
</ber:inputParameter>
<ber:inputParameter id="MODEL_NAME" name="Model Name">
<ber:description>The name of the project (footer note)</ber:description>
<ber:defaultValue>LIDSdemo</ber:defaultValue>
</ber:inputParameter>
</ber:inputParameterArray>
<ber:templateName>default.template.jrxml</ber:templateName>
<ber:attributeTemplateName>default.template.xsl</ber:attributeTemplateName>
</ber:dynamicReport>
...
</ber:reportArray>

32.9 seeddgn
Resource is used for storing seed files for LIDS Edit (used for creating active system file and DGN
export) and LIDS Explorer (used for DGN export). Files are stored in {project_folder}\lidsas\resources\seeddgn. Seed files are referenced in resource.xml.
Example: Reference to the seed file in resource.xml.
<ber:customResourceArray type="seedDgn">
<ber:customResource id="seed_1" name="Project seed">
<ber:formatArray>
<ber:format name="dgn" file="seedDEMO.dgn"/>
</ber:formatArray>
</ber:customResource>
</ber:customResourceArray>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

429

32.10 symbolfont
Resource is used for storing information about symbol styles. Configuration XML files for LIDS
Explorer and Browser (e.g. ber_LIDSdemo77.ttf) are stored in {project_folder}\lidsas\resources\symbolfont\ttf. Style files for LIDS Edit (e.g. fonts.rsc) are stored in {project_folder}\lidsas\resources\symbolfont\rsc. Fonts are subsequently referenced in resource.xml, thematization.xml and
model.xml.
Example: Reference to the font in resource.xml.
<ber:symbolFontArray>
<ber:symbolFont id="ber_LIDSdemo" name="ber_LIDSdemo">
<ber:formatArray>
<ber:format file="ber_LIDSdemo.ttf" name="ttf"/>
</ber:formatArray>
</ber:symbolFont>
...
<ber:symbolFont id="ber_LIDSdemo77" name="ber_LIDSdemo77">
<ber:formatArray>
<ber:format file="ber_LIDSdemo77.ttf" name="ttf"/>
<!--Following definition:
- assigns symbol font ber_LIDSdemo77 to source RSC font "Font77" from
"fonts.rsc", when reading DGN file
- tells to use RSC font "font77" from "fonts.rsc", when symbol font
ber_LIDSdemo77 is used during DGN export-->
<ber:format extResId="font77" file="fonts.rsc" name="rsc"/>
</ber:formatArray>
</ber:symbolFont>
...
</ber:symbolFontArray>

Example: Reference to the symbol in thematization.xml.
<ber:featureTypeStyleArray>
...
<ber:featureTypeStyle id="st_t_rcont_1" name="Rack Contact">
<ber:description>Dynamic color</ber:description>
<se:FeatureTypeName>ft_telco_contact</se:FeatureTypeName>
<ber:combinedRule id="st_t_rcont_1_1" name="None">
<ber:pointSymbolizer>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ber_LIDSdemo/35/centercenter"/>
<se:Format/>
</se:ExternalGraphic>

Implementation Guide

32 – APPENDIX E – RESOURCES

430

</se:Graphic>
<ber:rgbColor>
<ber:directLookup fallbackValue="#2AFF00">
<se:LookupValue>
<ogc:PropertyName>at_telco_color</ogc:PropertyName>
</se:LookupValue>
</ber:directLookup>
</ber:rgbColor>
</ber:pointSymbolizer>
</ber:combinedRule>
</ber:featureTypeStyle>
...
</ber:featureTypeStyleArray>

Example: Reference to the symbol in model.xml.
<ber:graphicTypeArray>
...
<ber:graphicType id="freegt_02" name="Scheme">
...
<ber:graphicTypeComponent id="freegt_02_03" name="Point full">
<ber:pointGraphicType>
<ber:symbology>
<ber:pointSymbolizer>
<se:Graphic>
<se:ExternalGraphic>
<se:OnlineResource xlink:href="resource.xml#ber_LIDSdemo/35"/>
<se:Format/>
</se:ExternalGraphic>
</se:Graphic>
<ber:rgbColor>#CC0000</ber:rgbColor>
</ber:pointSymbolizer>
</ber:symbology>
</ber:pointGraphicType>
</ber:graphicTypeComponent>
...
</ber:graphicTypeArray>

Implementation Guide

IMPLEMENTATION GUIDE VERSION 9.6

431

32.11 symbollibrary
Resource is used for storing symbols for LIDS Edit. There are two types of library – cell library is stored
in {project_folder}\lids-as\resources\symbollibrary\dgn, block library is stored in {project_folder}\lidsas\resources\symbollibrary\dwg. Libraries are subsequently referenced in resource.xml.
Example: Reference to the library in resource.xml.
<ber:customResourceArray type="symbolLibrary">
<ber:customResource id="block_demo1" name="Block library from DEMO font 1">
<ber:formatArray>
<ber:format name="dwg" file="block_demo1.dwg"/>
</ber:formatArray>
</ber:customResource>
...
<ber:customResource id="berLIDSDemo" name="DGN Cell library berLIDSDemo.ttf">
<ber:formatArray>
<ber:format name="dgn" file="berLIDSDemo.cel"/>
</ber:formatArray>
</ber:customResource>
...
</ber:customResourceArray>

Implementation Guide

432

32 – APPENDIX E – RESOURCES

Implementation Guide

Chapter 33
Appendix F – Security

IMPLEMENTATION GUIDE VERSION 9.6

33.

435

Appendix F – Security

33.1 Password rules
Rules for password handling are configured by entering the parameters in SEC_CONFIG table. All
parameters are optional:
• password.policy.regex – Regular expression for specifying required password complexity.
• password.policy.trim – If set to true, the empty spaces at the beginning and the end of the entered
password are ignored.
• password.policy.minLength – Minimum password length.
• password.policy.maxLength – Maximum password length.
• password.policy.unique – Number of unique new passwords that must be associated with a user
account before an old password can be reused.
• password.policy.expiration – Period of time (in seconds) that a password can be used before the
system requires the user to change it.
• password.policy.description – String displayed to the user when changing the password

Implementation Guide

436

33 – APPENDIX F – SECURITY

Implementation Guide

